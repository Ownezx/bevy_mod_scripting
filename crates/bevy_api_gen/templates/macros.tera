{% macro vector_index(num_type) %}
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<{{ num_type }}> {
    _self[idx - 1]
}
{% endmacro vector_index %}

{% macro vector_newindex(num_type) %}
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: {{ num_type }}) -> () {
    _self[idx - 1] = val
}
{% endmacro vector_newindex %}

{% macro matrix_index(col_type, mat_type, bms_core_path) %}
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<{{ col_type | prefix_lua }}> {
    let mut curr_ref = _self.0.clone();
    let def_ref = {{bms_core_path}}::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::{{ mat_type }}>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push({{bms_core_path}}::bindings::ReflectionPathElem::new_deferred(def_ref));
    {{ col_type | prefix_lua }}(curr_ref)
}
{% endmacro matrix_index %}

{% macro debug_as_to_string() %}
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
{% endmacro debug_as_to_string %}

{% macro display_as_to_string() %}
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{}", _self)
}
{% endmacro debug_as_to_string %}