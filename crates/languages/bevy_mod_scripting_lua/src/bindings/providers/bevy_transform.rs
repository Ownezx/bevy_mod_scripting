// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::bevy_ecs::*;
use super::bevy_reflect::*;
use super::bevy_core::*;
use super::bevy_math::*;
use super::bevy_hierarchy::*;
use bevy_mod_scripting_core::{
    AddContextInitializer, StoreDocumentation, bindings::ReflectReference,
};
use crate::{
    bindings::proxy::{
        LuaReflectRefProxy, LuaReflectRefMutProxy, LuaReflectValProxy, LuaValProxy,
        LuaIdentityProxy,
    },
    RegisterLua, tealr::mlu::mlua::IntoLua,
};
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::transform::components::GlobalTransform",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::transform::components::GlobalTransform>,
    ) -> LuaReflectValProxy<bevy::transform::components::GlobalTransform>;

"#,
    r#"

    #[lua(
        as_trait = "std::ops::Mul::<bevy::transform::components::Transform>",
        composite = "mul",
    )]
    fn mul(
        _self: LuaReflectValProxy<bevy::transform::components::GlobalTransform>,
        transform: LuaReflectValProxy<bevy::transform::components::Transform>,
    ) -> LuaReflectValProxy<bevy::transform::components::GlobalTransform>;

"#,
    r#"

    #[lua(
        as_trait = "std::ops::Mul::<bevy::transform::components::GlobalTransform>",
        composite = "mul",
    )]
    fn mul(
        _self: LuaReflectValProxy<bevy::transform::components::GlobalTransform>,
        global_transform: LuaReflectValProxy<
            bevy::transform::components::GlobalTransform,
        >,
    ) -> LuaReflectValProxy<bevy::transform::components::GlobalTransform>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::transform::components::GlobalTransform>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::transform::components::GlobalTransform>,
        other: LuaReflectRefProxy<bevy::transform::components::GlobalTransform>,
    ) -> bool;

"#,
    r#"

    #[lua()]
    fn from_xyz(
        x: f32,
        y: f32,
        z: f32,
    ) -> LuaReflectValProxy<bevy::transform::components::GlobalTransform>;

"#,
    r#"
/// Returns the transformation as a [`Transform`].
/// The transform is expected to be non-degenerate and without shearing, or the output
/// will be invalid.

    #[lua()]
    fn compute_transform(
        _self: LuaReflectRefProxy<bevy::transform::components::GlobalTransform>,
    ) -> LuaReflectValProxy<bevy::transform::components::Transform>;

"#,
    r#"
/// Returns the [`Transform`] `self` would have if it was a child of an entity
/// with the `parent` [`GlobalTransform`].
/// This is useful if you want to "reparent" an [`Entity`](bevy_ecs::entity::Entity).
/// Say you have an entity `e1` that you want to turn into a child of `e2`,
/// but you want `e1` to keep the same global transform, even after re-parenting. You would use:
/// ```
/// # use bevy_transform::prelude::{GlobalTransform, Transform};
/// # use bevy_ecs::prelude::{Entity, Query, Component, Commands};
/// # use bevy_hierarchy::{prelude::Parent, BuildChildren};
/// #[derive(Component)]
/// struct ToReparent {
///     new_parent: Entity,
/// }
/// fn reparent_system(
///     mut commands: Commands,
///     mut targets: Query<(&mut Transform, Entity, &GlobalTransform, &ToReparent)>,
///     transforms: Query<&GlobalTransform>,
/// ) {
///     for (mut transform, entity, initial, to_reparent) in targets.iter_mut() {
///         if let Ok(parent_transform) = transforms.get(to_reparent.new_parent) {
///             *transform = initial.reparented_to(parent_transform);
///             commands.entity(entity)
///                 .remove::<ToReparent>()
///                 .set_parent(to_reparent.new_parent);
///         }
///     }
/// }
/// ```
/// The transform is expected to be non-degenerate and without shearing, or the output
/// will be invalid.

    #[lua()]
    fn reparented_to(
        _self: LuaReflectRefProxy<bevy::transform::components::GlobalTransform>,
        parent: LuaReflectRefProxy<bevy::transform::components::GlobalTransform>,
    ) -> LuaReflectValProxy<bevy::transform::components::Transform>;

"#,
    r#"
/// Multiplies `self` with `transform` component by component, returning the
/// resulting [`GlobalTransform`]

    #[lua()]
    fn mul_transform(
        _self: LuaReflectRefProxy<bevy::transform::components::GlobalTransform>,
        transform: LuaReflectValProxy<bevy::transform::components::Transform>,
    ) -> LuaReflectValProxy<bevy::transform::components::GlobalTransform>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GlobalTransform();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::transform::components::Transform",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::transform::components::Transform>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::transform::components::Transform>,
        other: LuaReflectRefProxy<bevy::transform::components::Transform>,
    ) -> bool;

"#,
    r#"

    #[lua(
        as_trait = "std::ops::Mul::<bevy::transform::components::GlobalTransform>",
        composite = "mul",
    )]
    fn mul(
        _self: LuaReflectValProxy<bevy::transform::components::Transform>,
        global_transform: LuaReflectValProxy<
            bevy::transform::components::GlobalTransform,
        >,
    ) -> LuaReflectValProxy<bevy::transform::components::GlobalTransform>;

"#,
    r#"
/// Creates a new [`Transform`] at the position `(x, y, z)`. In 2d, the `z` component
/// is used for z-ordering elements: higher `z`-value will be in front of lower
/// `z`-value.

    #[lua()]
    fn from_xyz(
        x: f32,
        y: f32,
        z: f32,
    ) -> LuaReflectValProxy<bevy::transform::components::Transform>;

"#,
    r#"
/// Rotates this [`Transform`] around the `X` axis by `angle` (in radians).
/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.

    #[lua()]
    fn rotate_x(
        _self: LuaReflectRefMutProxy<bevy::transform::components::Transform>,
        angle: f32,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around the `Y` axis by `angle` (in radians).
/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.

    #[lua()]
    fn rotate_y(
        _self: LuaReflectRefMutProxy<bevy::transform::components::Transform>,
        angle: f32,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around the `Z` axis by `angle` (in radians).
/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.

    #[lua()]
    fn rotate_z(
        _self: LuaReflectRefMutProxy<bevy::transform::components::Transform>,
        angle: f32,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around its local `X` axis by `angle` (in radians).

    #[lua()]
    fn rotate_local_x(
        _self: LuaReflectRefMutProxy<bevy::transform::components::Transform>,
        angle: f32,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around its local `Y` axis by `angle` (in radians).

    #[lua()]
    fn rotate_local_y(
        _self: LuaReflectRefMutProxy<bevy::transform::components::Transform>,
        angle: f32,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around its local `Z` axis by `angle` (in radians).

    #[lua()]
    fn rotate_local_z(
        _self: LuaReflectRefMutProxy<bevy::transform::components::Transform>,
        angle: f32,
    ) -> ();

"#,
    r#"
/// Multiplies `self` with `transform` component by component, returning the
/// resulting [`Transform`]

    #[lua()]
    fn mul_transform(
        _self: LuaReflectRefProxy<bevy::transform::components::Transform>,
        transform: LuaReflectValProxy<bevy::transform::components::Transform>,
    ) -> LuaReflectValProxy<bevy::transform::components::Transform>;

"#,
    r#"
/// Returns `true` if, and only if, translation, rotation and scale all are
/// finite. If any of them contains a `NaN`, positive or negative infinity,
/// this will return `false`.

    #[lua()]
    fn is_finite(
        _self: LuaReflectRefProxy<bevy::transform::components::Transform>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::transform::components::Transform>,
    ) -> LuaReflectValProxy<bevy::transform::components::Transform>;

"#,
    r#"

    #[lua(
        as_trait = "std::ops::Mul::<bevy::transform::components::Transform>",
        composite = "mul",
    )]
    fn mul(
        _self: LuaReflectValProxy<bevy::transform::components::Transform>,
        transform: LuaReflectValProxy<bevy::transform::components::Transform>,
    ) -> LuaReflectValProxy<bevy::transform::components::Transform>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Transform {
    translation: ReflectReference,
    rotation: ReflectReference,
    scale: ReflectReference,
}
#[derive(Default)]
pub(crate) struct Globals;
impl crate::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: crate::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> crate::tealr::mlu::mlua::Result<()> {
        instances
            .add_instance(
                "GlobalTransform",
                crate::tealr::mlu::UserDataProxy::<LuaGlobalTransform>::new,
            )?;
        instances
            .add_instance(
                "Transform",
                crate::tealr::mlu::UserDataProxy::<LuaTransform>::new,
            )?;
        Ok(())
    }
}
fn bevy_transform_context_initializer(
    _: &bevy_mod_scripting_core::script::ScriptId,
    ctx: &mut crate::prelude::Lua,
) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
    crate::tealr::mlu::set_global_env(Globals, ctx)?;
    Ok(())
}
pub struct BevyTransformScriptingPlugin;
impl bevy::app::Plugin for BevyTransformScriptingPlugin {
    fn build(&self, app: &mut bevy::prelude::App) {
        app.register_lua_proxy::<bevy::transform::components::GlobalTransform>();
        app.register_lua_proxy::<bevy::transform::components::Transform>();
        app.add_context_initializer::<()>(bevy_transform_context_initializer);
        app.add_documentation_fragment(
            crate::docs::LuaDocumentationFragment::new(
                "BevyTransformAPI",
                |tw| {
                    tw.document_global_instance::<Globals>()
                        .expect("Something went wrong documenting globals")
                        .process_type::<LuaGlobalTransform>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaGlobalTransform>,
                        >()
                        .process_type::<LuaTransform>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaTransform>>()
                },
            ),
        );
    }
}
