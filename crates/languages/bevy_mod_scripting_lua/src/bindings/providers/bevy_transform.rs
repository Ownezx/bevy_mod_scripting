// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::bevy_ecs::*;
use super::bevy_reflect::*;
use super::bevy_core::*;
use super::bevy_hierarchy::*;
use bevy_mod_scripting_core::{AddContextInitializer, StoreDocumentation};
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    remote = "bevy::transform::components::GlobalTransform",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Mul", composite = "mul")]
    fn mul(
        self,
        #[proxy]
        transform: bevy::transform::components::Transform,
    ) -> bevy::transform::components::GlobalTransform;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(&self) -> bevy::transform::components::GlobalTransform;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq", composite = "eq")]
    fn eq(&self, #[proxy] other: &components::global_transform::GlobalTransform) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul", composite = "mul")]
    fn mul(self, #[proxy] value: bevy::math::Vec3) -> bevy::math::Vec3;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul", composite = "mul")]
    fn mul(
        self,
        #[proxy]
        global_transform: bevy::transform::components::GlobalTransform,
    ) -> bevy::transform::components::GlobalTransform;

"#,
    r#"

    #[lua()]
    fn from_xyz(x: f32, y: f32, z: f32) -> bevy::transform::components::GlobalTransform;

"#,
    r#"

    #[lua()]
    fn from_translation(
        #[proxy]
        translation: bevy::math::Vec3,
    ) -> bevy::transform::components::GlobalTransform;

"#,
    r#"

    #[lua()]
    fn from_rotation(
        #[proxy]
        rotation: bevy::math::Quat,
    ) -> bevy::transform::components::GlobalTransform;

"#,
    r#"

    #[lua()]
    fn from_scale(
        #[proxy]
        scale: bevy::math::Vec3,
    ) -> bevy::transform::components::GlobalTransform;

"#,
    r#"
/// Returns the 3d affine transformation matrix as a [`Mat4`].

    #[lua()]
    fn compute_matrix(&self) -> bevy::math::Mat4;

"#,
    r#"
/// Returns the 3d affine transformation matrix as an [`Affine3A`].

    #[lua()]
    fn affine(&self) -> bevy::math::Affine3A;

"#,
    r#"
/// Returns the transformation as a [`Transform`].
/// The transform is expected to be non-degenerate and without shearing, or the output
/// will be invalid.

    #[lua()]
    fn compute_transform(&self) -> bevy::transform::components::Transform;

"#,
    r#"
/// Returns the [`Transform`] `self` would have if it was a child of an entity
/// with the `parent` [`GlobalTransform`].
/// This is useful if you want to "reparent" an [`Entity`](bevy_ecs::entity::Entity).
/// Say you have an entity `e1` that you want to turn into a child of `e2`,
/// but you want `e1` to keep the same global transform, even after re-parenting. You would use:
/// ```
/// # use bevy_transform::prelude::{GlobalTransform, Transform};
/// # use bevy_ecs::prelude::{Entity, Query, Component, Commands};
/// # use bevy_hierarchy::{prelude::Parent, BuildChildren};
/// #[derive(Component)]
/// struct ToReparent {
///     new_parent: Entity,
/// }
/// fn reparent_system(
///     mut commands: Commands,
///     mut targets: Query<(&mut Transform, Entity, &GlobalTransform, &ToReparent)>,
///     transforms: Query<&GlobalTransform>,
/// ) {
///     for (mut transform, entity, initial, to_reparent) in targets.iter_mut() {
///         if let Ok(parent_transform) = transforms.get(to_reparent.new_parent) {
///             *transform = initial.reparented_to(parent_transform);
///             commands.entity(entity)
///                 .remove::<ToReparent>()
///                 .set_parent(to_reparent.new_parent);
///         }
///     }
/// }
/// ```
/// The transform is expected to be non-degenerate and without shearing, or the output
/// will be invalid.

    #[lua()]
    fn reparented_to(
        &self,
        #[proxy]
        parent: &components::global_transform::GlobalTransform,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
///Return the local right vector (X).

    #[lua()]
    fn right(&self) -> bevy::math::Vec3;

"#,
    r#"
///Return the local left vector (-X).

    #[lua()]
    fn left(&self) -> bevy::math::Vec3;

"#,
    r#"
///Return the local up vector (Y).

    #[lua()]
    fn up(&self) -> bevy::math::Vec3;

"#,
    r#"
///Return the local down vector (-Y).

    #[lua()]
    fn down(&self) -> bevy::math::Vec3;

"#,
    r#"
///Return the local back vector (Z).

    #[lua()]
    fn back(&self) -> bevy::math::Vec3;

"#,
    r#"
///Return the local forward vector (-Z).

    #[lua()]
    fn forward(&self) -> bevy::math::Vec3;

"#,
    r#"
/// Get the translation as a [`Vec3`].

    #[lua()]
    fn translation(&self) -> bevy::math::Vec3;

"#,
    r#"
/// Get the translation as a [`Vec3A`].

    #[lua()]
    fn translation_vec3a(&self) -> bevy::math::Vec3A;

"#,
    r#"
/// Get an upper bound of the radius from the given `extents`.

    #[lua()]
    fn radius_vec3a(&self, #[proxy] extents: bevy::math::Vec3A) -> f32;

"#,
    r#"
/// Transforms the given `point`, applying shear, scale, rotation and translation.
/// This moves `point` into the local space of this [`GlobalTransform`].

    #[lua()]
    fn transform_point(&self, #[proxy] point: bevy::math::Vec3) -> bevy::math::Vec3;

"#,
    r#"
/// Multiplies `self` with `transform` component by component, returning the
/// resulting [`GlobalTransform`]

    #[lua()]
    fn mul_transform(
        &self,
        #[proxy]
        transform: bevy::transform::components::Transform,
    ) -> bevy::transform::components::GlobalTransform;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct LuaGlobalTransform();
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    remote = "bevy::transform::components::Transform",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq", composite = "eq")]
    fn eq(&self, #[proxy] other: &components::transform::Transform) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul", composite = "mul")]
    fn mul(
        self,
        #[proxy]
        transform: bevy::transform::components::Transform,
    ) -> bevy::transform::components::Transform;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul", composite = "mul")]
    fn mul(self, #[proxy] value: bevy::math::Vec3) -> bevy::math::Vec3;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(&self) -> bevy::transform::components::Transform;

"#,
    r#"
/// Creates a new [`Transform`] at the position `(x, y, z)`. In 2d, the `z` component
/// is used for z-ordering elements: higher `z`-value will be in front of lower
/// `z`-value.

    #[lua()]
    fn from_xyz(x: f32, y: f32, z: f32) -> bevy::transform::components::Transform;

"#,
    r#"
/// Extracts the translation, rotation, and scale from `matrix`. It must be a 3d affine
/// transformation matrix.

    #[lua()]
    fn from_matrix(
        #[proxy]
        matrix: bevy::math::Mat4,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Creates a new [`Transform`], with `translation`. Rotation will be 0 and scale 1 on
/// all axes.

    #[lua()]
    fn from_translation(
        #[proxy]
        translation: bevy::math::Vec3,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Creates a new [`Transform`], with `rotation`. Translation will be 0 and scale 1 on
/// all axes.

    #[lua()]
    fn from_rotation(
        #[proxy]
        rotation: bevy::math::Quat,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Creates a new [`Transform`], with `scale`. Translation will be 0 and rotation 0 on
/// all axes.

    #[lua()]
    fn from_scale(
        #[proxy]
        scale: bevy::math::Vec3,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Returns this [`Transform`] with a new rotation so that [`Transform::forward`]
/// points towards the `target` position and [`Transform::up`] points towards `up`.
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
/// * if `target` is the same as the transform translation, `Vec3::Z` is used instead
/// * if `up` is zero, `Vec3::Y` is used instead
/// * if the resulting forward direction is parallel with `up`, an orthogonal vector is used as the "right" direction

    #[lua()]
    fn looking_at(
        self,
        #[proxy]
        target: bevy::math::Vec3,
        #[proxy]
        up: bevy::math::Vec3,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Returns this [`Transform`] with a new rotation so that [`Transform::forward`]
/// points in the given `direction` and [`Transform::up`] points towards `up`.
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
/// * if `direction` is zero, `Vec3::Z` is used instead
/// * if `up` is zero, `Vec3::Y` is used instead
/// * if `direction` is parallel with `up`, an orthogonal vector is used as the "right" direction

    #[lua()]
    fn looking_to(
        self,
        #[proxy]
        direction: bevy::math::Vec3,
        #[proxy]
        up: bevy::math::Vec3,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Returns this [`Transform`] with a new translation.

    #[lua()]
    fn with_translation(
        self,
        #[proxy]
        translation: bevy::math::Vec3,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Returns this [`Transform`] with a new rotation.

    #[lua()]
    fn with_rotation(
        self,
        #[proxy]
        rotation: bevy::math::Quat,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Returns this [`Transform`] with a new scale.

    #[lua()]
    fn with_scale(
        self,
        #[proxy]
        scale: bevy::math::Vec3,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Returns the 3d affine transformation matrix from this transforms translation,
/// rotation, and scale.

    #[lua()]
    fn compute_matrix(&self) -> bevy::math::Mat4;

"#,
    r#"
/// Returns the 3d affine transformation matrix from this transforms translation,
/// rotation, and scale.

    #[lua()]
    fn compute_affine(&self) -> bevy::math::Affine3A;

"#,
    r#"
/// Rotates this [`Transform`] by the given rotation.
/// If this [`Transform`] has a parent, the `rotation` is relative to the rotation of the parent.
/// # Examples
/// - [`3d_rotation`]
/// [`3d_rotation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/3d_rotation.rs

    #[lua()]
    fn rotate(&mut self, #[proxy] rotation: bevy::math::Quat) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around the given `axis` by `angle` (in radians).
/// If this [`Transform`] has a parent, the `axis` is relative to the rotation of the parent.

    #[lua()]
    fn rotate_axis(&mut self, #[proxy] axis: bevy::math::Vec3, angle: f32) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around the `X` axis by `angle` (in radians).
/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.

    #[lua()]
    fn rotate_x(&mut self, angle: f32) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around the `Y` axis by `angle` (in radians).
/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.

    #[lua()]
    fn rotate_y(&mut self, angle: f32) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around the `Z` axis by `angle` (in radians).
/// If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.

    #[lua()]
    fn rotate_z(&mut self, angle: f32) -> ();

"#,
    r#"
/// Rotates this [`Transform`] by the given `rotation`.
/// The `rotation` is relative to this [`Transform`]'s current rotation.

    #[lua()]
    fn rotate_local(&mut self, #[proxy] rotation: bevy::math::Quat) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around its local `axis` by `angle` (in radians).

    #[lua()]
    fn rotate_local_axis(&mut self, #[proxy] axis: bevy::math::Vec3, angle: f32) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around its local `X` axis by `angle` (in radians).

    #[lua()]
    fn rotate_local_x(&mut self, angle: f32) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around its local `Y` axis by `angle` (in radians).

    #[lua()]
    fn rotate_local_y(&mut self, angle: f32) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around its local `Z` axis by `angle` (in radians).

    #[lua()]
    fn rotate_local_z(&mut self, angle: f32) -> ();

"#,
    r#"
/// Translates this [`Transform`] around a `point` in space.
/// If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.

    #[lua()]
    fn translate_around(
        &mut self,
        #[proxy]
        point: bevy::math::Vec3,
        #[proxy]
        rotation: bevy::math::Quat,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] around a `point` in space.
/// If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.

    #[lua()]
    fn rotate_around(
        &mut self,
        #[proxy]
        point: bevy::math::Vec3,
        #[proxy]
        rotation: bevy::math::Quat,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] so that [`Transform::forward`] points towards the `target` position,
/// and [`Transform::up`] points towards `up`.
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
/// * if `target` is the same as the transform translation, `Vec3::Z` is used instead
/// * if `up` is zero, `Vec3::Y` is used instead
/// * if the resulting forward direction is parallel with `up`, an orthogonal vector is used as the "right" direction

    #[lua()]
    fn look_at(
        &mut self,
        #[proxy]
        target: bevy::math::Vec3,
        #[proxy]
        up: bevy::math::Vec3,
    ) -> ();

"#,
    r#"
/// Rotates this [`Transform`] so that [`Transform::forward`] points in the given `direction`
/// and [`Transform::up`] points towards `up`.
/// In some cases it's not possible to construct a rotation. Another axis will be picked in those cases:
/// * if `direction` is zero, `Vec3::NEG_Z` is used instead
/// * if `up` is zero, `Vec3::Y` is used instead
/// * if `direction` is parallel with `up`, an orthogonal vector is used as the "right" direction

    #[lua()]
    fn look_to(
        &mut self,
        #[proxy]
        direction: bevy::math::Vec3,
        #[proxy]
        up: bevy::math::Vec3,
    ) -> ();

"#,
    r#"
/// Multiplies `self` with `transform` component by component, returning the
/// resulting [`Transform`]

    #[lua()]
    fn mul_transform(
        &self,
        #[proxy]
        transform: bevy::transform::components::Transform,
    ) -> bevy::transform::components::Transform;

"#,
    r#"
/// Transforms the given `point`, applying scale, rotation and translation.
/// If this [`Transform`] has a parent, this will transform a `point` that is
/// relative to the parent's [`Transform`] into one relative to this [`Transform`].
/// If this [`Transform`] does not have a parent, this will transform a `point`
/// that is in global space into one relative to this [`Transform`].
/// If you want to transform a `point` in global space to the local space of this [`Transform`],
/// consider using [`GlobalTransform::transform_point()`] instead.

    #[lua()]
    fn transform_point(&self, #[proxy] point: bevy::math::Vec3) -> bevy::math::Vec3;

"#,
    r#"
/// Returns `true` if, and only if, translation, rotation and scale all are
/// finite. If any of them contains a `NaN`, positive or negative infinity,
/// this will return `false`.

    #[lua()]
    fn is_finite(&self) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul", composite = "mul")]
    fn mul(
        self,
        #[proxy]
        global_transform: bevy::transform::components::GlobalTransform,
    ) -> bevy::transform::components::GlobalTransform;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct LuaTransform {
    #[lua(output(proxy))]
    translation: bevy::math::Vec3,
    #[lua(output(proxy))]
    rotation: bevy::math::Quat,
    #[lua(output(proxy))]
    scale: bevy::math::Vec3,
}
#[derive(Default)]
pub(crate) struct Globals;
impl crate::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: crate::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> crate::tealr::mlu::mlua::Result<()> {
        instances
            .add_instance(
                "GlobalTransform",
                crate::tealr::mlu::UserDataProxy::<LuaGlobalTransform>::new,
            )?;
        instances
            .add_instance(
                "Transform",
                crate::tealr::mlu::UserDataProxy::<LuaTransform>::new,
            )?;
        Ok(())
    }
}
fn bevy_transform_context_initializer(
    _: &bevy_mod_scripting_core::script::ScriptId,
    ctx: &mut crate::prelude::Lua,
) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
    crate::tealr::mlu::set_global_env(Globals, ctx)?;
    Ok(())
}
pub struct BevyTransformScriptingPlugin;
impl bevy::app::Plugin for BevyTransformScriptingPlugin {
    fn build(&self, app: &mut bevy::prelude::App) {
        app.register_foreign_lua_type::<bevy::transform::components::GlobalTransform>();
        app.register_foreign_lua_type::<bevy::transform::components::Transform>();
        app.add_context_initializer::<()>(bevy_transform_context_initializer);
        app.add_documentation_fragment(
            crate::docs::LuaDocumentationFragment::new(
                "BevyTransformAPI",
                |tw| {
                    tw.document_global_instance::<Globals>()
                        .expect("Something went wrong documenting globals")
                        .process_type::<LuaGlobalTransform>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaGlobalTransform>,
                        >()
                        .process_type::<LuaTransform>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaTransform>>()
                },
            ),
        );
    }
}
