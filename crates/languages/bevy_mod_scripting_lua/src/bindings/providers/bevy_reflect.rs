// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::{
    AddContextInitializer, StoreDocumentation, bindings::ReflectReference,
};
use crate::{
    bindings::proxy::{
        LuaReflectRefProxy, LuaReflectRefMutProxy, LuaReflectValProxy, LuaValProxy,
        LuaIdentityProxy,
    },
    type_data::RegisterLua, tealr::mlu::mlua::IntoLua,
};
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicBool",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new `AtomicBool`.
/// # Examples
/// ```
/// use std::sync::atomic::AtomicBool;
/// let atomic_true = AtomicBool::new(true);
/// let atomic_false = AtomicBool::new(false);
/// ```

    #[lua()]
    fn new(v: bool) -> LuaReflectValProxy<std::sync::atomic::AtomicBool>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
/// use std::sync::atomic::AtomicBool;
/// let some_bool = AtomicBool::new(true);
/// assert_eq!(some_bool.into_inner(), true);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicBool>) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicBool {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicI16",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI16;
///let atomic_forty_two = AtomicI16::new(42);
/// ```

    #[lua()]
    fn new(v: i16) -> LuaReflectValProxy<std::sync::atomic::AtomicI16>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI16;
///let some_var = AtomicI16::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicI16>) -> i16;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicI16 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicI32",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI32;
///let atomic_forty_two = AtomicI32::new(42);
/// ```

    #[lua()]
    fn new(v: i32) -> LuaReflectValProxy<std::sync::atomic::AtomicI32>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI32;
///let some_var = AtomicI32::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicI32>) -> i32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicI32 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicI64",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI64;
///let atomic_forty_two = AtomicI64::new(42);
/// ```

    #[lua()]
    fn new(v: i64) -> LuaReflectValProxy<std::sync::atomic::AtomicI64>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI64;
///let some_var = AtomicI64::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicI64>) -> i64;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicI64 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicI8",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI8;
///let atomic_forty_two = AtomicI8::new(42);
/// ```

    #[lua()]
    fn new(v: i8) -> LuaReflectValProxy<std::sync::atomic::AtomicI8>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicI8;
///let some_var = AtomicI8::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicI8>) -> i8;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicI8 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicIsize",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicIsize;
///let atomic_forty_two = AtomicIsize::new(42);
/// ```

    #[lua()]
    fn new(v: isize) -> LuaReflectValProxy<std::sync::atomic::AtomicIsize>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicIsize;
///let some_var = AtomicIsize::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicIsize>) -> isize;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicIsize {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicU16",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU16;
///let atomic_forty_two = AtomicU16::new(42);
/// ```

    #[lua()]
    fn new(v: u16) -> LuaReflectValProxy<std::sync::atomic::AtomicU16>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU16;
///let some_var = AtomicU16::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicU16>) -> u16;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicU16 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicU32",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU32;
///let atomic_forty_two = AtomicU32::new(42);
/// ```

    #[lua()]
    fn new(v: u32) -> LuaReflectValProxy<std::sync::atomic::AtomicU32>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU32;
///let some_var = AtomicU32::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicU32>) -> u32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicU32 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicU64",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU64;
///let atomic_forty_two = AtomicU64::new(42);
/// ```

    #[lua()]
    fn new(v: u64) -> LuaReflectValProxy<std::sync::atomic::AtomicU64>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU64;
///let some_var = AtomicU64::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicU64>) -> u64;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicU64 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicU8",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU8;
///let atomic_forty_two = AtomicU8::new(42);
/// ```

    #[lua()]
    fn new(v: u8) -> LuaReflectValProxy<std::sync::atomic::AtomicU8>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicU8;
///let some_var = AtomicU8::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicU8>) -> u8;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicU8 {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::sync::atomic::AtomicUsize",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new atomic integer.
/// # Examples
/// ```
///use std::sync::atomic::AtomicUsize;
///let atomic_forty_two = AtomicUsize::new(42);
/// ```

    #[lua()]
    fn new(v: usize) -> LuaReflectValProxy<std::sync::atomic::AtomicUsize>;

"#,
    r#"
/// Consumes the atomic and returns the contained value.
/// This is safe because passing `self` by value guarantees that no other threads are
/// concurrently accessing the atomic data.
/// # Examples
/// ```
///use std::sync::atomic::AtomicUsize;
///let some_var = AtomicUsize::new(5);
/// assert_eq!(some_var.into_inner(), 5);
/// ```

    #[lua()]
    fn into_inner(_self: LuaReflectValProxy<std::sync::atomic::AtomicUsize>) -> usize;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AtomicUsize {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::utils::Duration",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<u32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: LuaReflectRefProxy<bevy::utils::Duration>,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::utils::Duration>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::utils::Duration>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::utils::Duration>,
        other: LuaReflectRefProxy<bevy::utils::Duration>,
    ) -> bool;

"#,
    r#"
/// Creates a new `Duration` from the specified number of whole seconds and
/// additional nanoseconds.
/// If the number of nanoseconds is greater than 1 billion (the number of
/// nanoseconds in a second), then it will carry over into the seconds provided.
/// # Panics
/// This constructor will panic if the carry from the nanoseconds overflows
/// the seconds counter.
/// # Examples
/// ```
/// use std::time::Duration;
/// let five_seconds = Duration::new(5, 0);
/// ```

    #[lua()]
    fn new(secs: u64, nanos: u32) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Creates a new `Duration` from the specified number of whole seconds.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_secs(5);
/// assert_eq!(5, duration.as_secs());
/// assert_eq!(0, duration.subsec_nanos());
/// ```

    #[lua()]
    fn from_secs(secs: u64) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Creates a new `Duration` from the specified number of milliseconds.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_millis(2_569);
/// assert_eq!(2, duration.as_secs());
/// assert_eq!(569_000_000, duration.subsec_nanos());
/// ```

    #[lua()]
    fn from_millis(millis: u64) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Creates a new `Duration` from the specified number of microseconds.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_micros(1_000_002);
/// assert_eq!(1, duration.as_secs());
/// assert_eq!(2_000, duration.subsec_nanos());
/// ```

    #[lua()]
    fn from_micros(micros: u64) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Creates a new `Duration` from the specified number of nanoseconds.
/// Note: Using this on the return value of `as_nanos()` might cause unexpected behavior:
/// `as_nanos()` returns a u128, and can return values that do not fit in u64, e.g. 585 years.
/// Instead, consider using the pattern `Duration::new(d.as_secs(), d.subsec_nanos())`
/// if you cannot copy/clone the Duration directly.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_nanos(1_000_000_123);
/// assert_eq!(1, duration.as_secs());
/// assert_eq!(123, duration.subsec_nanos());
/// ```

    #[lua()]
    fn from_nanos(nanos: u64) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Returns true if this `Duration` spans no time.
/// # Examples
/// ```
/// use std::time::Duration;
/// assert!(Duration::ZERO.is_zero());
/// assert!(Duration::new(0, 0).is_zero());
/// assert!(Duration::from_nanos(0).is_zero());
/// assert!(Duration::from_secs(0).is_zero());
/// assert!(!Duration::new(1, 1).is_zero());
/// assert!(!Duration::from_nanos(1).is_zero());
/// assert!(!Duration::from_secs(1).is_zero());
/// ```

    #[lua()]
    fn is_zero(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> bool;

"#,
    r#"
/// Returns the number of _whole_ seconds contained by this `Duration`.
/// The returned value does not include the fractional (nanosecond) part of the
/// duration, which can be obtained using [`subsec_nanos`].
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730_023_852);
/// assert_eq!(duration.as_secs(), 5);
/// ```
/// To determine the total number of seconds represented by the `Duration`
/// including the fractional part, use [`as_secs_f64`] or [`as_secs_f32`]
/// [`as_secs_f64`]: Duration::as_secs_f64
/// [`as_secs_f32`]: Duration::as_secs_f32
/// [`subsec_nanos`]: Duration::subsec_nanos

    #[lua()]
    fn as_secs(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> u64;

"#,
    r#"
/// Returns the fractional part of this `Duration`, in whole milliseconds.
/// This method does **not** return the length of the duration when
/// represented by milliseconds. The returned number always represents a
/// fractional portion of a second (i.e., it is less than one thousand).
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_millis(5_432);
/// assert_eq!(duration.as_secs(), 5);
/// assert_eq!(duration.subsec_millis(), 432);
/// ```

    #[lua()]
    fn subsec_millis(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> u32;

"#,
    r#"
/// Returns the fractional part of this `Duration`, in whole microseconds.
/// This method does **not** return the length of the duration when
/// represented by microseconds. The returned number always represents a
/// fractional portion of a second (i.e., it is less than one million).
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_micros(1_234_567);
/// assert_eq!(duration.as_secs(), 1);
/// assert_eq!(duration.subsec_micros(), 234_567);
/// ```

    #[lua()]
    fn subsec_micros(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> u32;

"#,
    r#"
/// Returns the fractional part of this `Duration`, in nanoseconds.
/// This method does **not** return the length of the duration when
/// represented by nanoseconds. The returned number always represents a
/// fractional portion of a second (i.e., it is less than one billion).
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_millis(5_010);
/// assert_eq!(duration.as_secs(), 5);
/// assert_eq!(duration.subsec_nanos(), 10_000_000);
/// ```

    #[lua()]
    fn subsec_nanos(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> u32;

"#,
    r#"
/// Returns the total number of whole milliseconds contained by this `Duration`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730_023_852);
/// assert_eq!(duration.as_millis(), 5_730);
/// ```

    #[lua()]
    fn as_millis(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> u128;

"#,
    r#"
/// Returns the total number of whole microseconds contained by this `Duration`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730_023_852);
/// assert_eq!(duration.as_micros(), 5_730_023);
/// ```

    #[lua()]
    fn as_micros(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> u128;

"#,
    r#"
/// Returns the total number of nanoseconds contained by this `Duration`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730_023_852);
/// assert_eq!(duration.as_nanos(), 5_730_023_852);
/// ```

    #[lua()]
    fn as_nanos(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> u128;

"#,
    r#"
/// Computes the absolute difference between `self` and `other`.
/// # Examples
/// ```
/// use std::time::Duration;
/// assert_eq!(Duration::new(100, 0).abs_diff(Duration::new(80, 0)), Duration::new(20, 0));
/// assert_eq!(Duration::new(100, 400_000_000).abs_diff(Duration::new(110, 0)), Duration::new(9, 600_000_000));
/// ```

    #[lua()]
    fn abs_diff(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        other: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Saturating `Duration` addition. Computes `self + other`, returning [`Duration::MAX`]
/// if overflow occurred.
/// # Examples
/// ```
/// #![feature(duration_constants)]
/// use std::time::Duration;
/// assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));
/// assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);
/// ```

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::ZERO`]
/// if the result would be negative or if overflow occurred.
/// # Examples
/// ```
/// use std::time::Duration;
/// assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));
/// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::ZERO);
/// ```

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Saturating `Duration` multiplication. Computes `self * other`, returning
/// [`Duration::MAX`] if overflow occurred.
/// # Examples
/// ```
/// #![feature(duration_constants)]
/// use std::time::Duration;
/// assert_eq!(Duration::new(0, 500_000_001).saturating_mul(2), Duration::new(1, 2));
/// assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);
/// ```

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Returns the number of seconds contained by this `Duration` as `f64`.
/// The returned value includes the fractional (nanosecond) part of the duration.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.as_secs_f64(), 2.7);
/// ```

    #[lua()]
    fn as_secs_f64(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> f64;

"#,
    r#"
/// Returns the number of seconds contained by this `Duration` as `f32`.
/// The returned value includes the fractional (nanosecond) part of the duration.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.as_secs_f32(), 2.7);
/// ```

    #[lua()]
    fn as_secs_f32(_self: LuaReflectRefProxy<bevy::utils::Duration>) -> f32;

"#,
    r#"
/// Creates a new `Duration` from the specified number of seconds represented
/// as `f64`.
/// # Panics
/// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let res = Duration::from_secs_f64(0.0);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f64(1e-20);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f64(4.2e-7);
/// assert_eq!(res, Duration::new(0, 420));
/// let res = Duration::from_secs_f64(2.7);
/// assert_eq!(res, Duration::new(2, 700_000_000));
/// let res = Duration::from_secs_f64(3e10);
/// assert_eq!(res, Duration::new(30_000_000_000, 0));
/// // subnormal float
/// let res = Duration::from_secs_f64(f64::from_bits(1));
/// assert_eq!(res, Duration::new(0, 0));
/// // conversion uses rounding
/// let res = Duration::from_secs_f64(0.999e-9);
/// assert_eq!(res, Duration::new(0, 1));
/// ```

    #[lua()]
    fn from_secs_f64(secs: f64) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Creates a new `Duration` from the specified number of seconds represented
/// as `f32`.
/// # Panics
/// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let res = Duration::from_secs_f32(0.0);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f32(1e-20);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f32(4.2e-7);
/// assert_eq!(res, Duration::new(0, 420));
/// let res = Duration::from_secs_f32(2.7);
/// assert_eq!(res, Duration::new(2, 700_000_048));
/// let res = Duration::from_secs_f32(3e10);
/// assert_eq!(res, Duration::new(30_000_001_024, 0));
/// // subnormal float
/// let res = Duration::from_secs_f32(f32::from_bits(1));
/// assert_eq!(res, Duration::new(0, 0));
/// // conversion uses rounding
/// let res = Duration::from_secs_f32(0.999e-9);
/// assert_eq!(res, Duration::new(0, 1));
/// ```

    #[lua()]
    fn from_secs_f32(secs: f32) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Multiplies `Duration` by `f64`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.mul_f64(3.14), Duration::new(8, 478_000_000));
/// assert_eq!(dur.mul_f64(3.14e5), Duration::new(847_800, 0));
/// ```

    #[lua()]
    fn mul_f64(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Multiplies `Duration` by `f32`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_641));
/// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847_800, 0));
/// ```

    #[lua()]
    fn mul_f32(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Divides `Duration` by `f64`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));
/// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_599));
/// ```

    #[lua()]
    fn div_f64(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Divides `Duration` by `f32`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// // note that due to rounding errors result is slightly
/// // different from 0.859_872_611
/// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_580));
/// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_599));
/// ```

    #[lua()]
    fn div_f32(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Divides `Duration` by `Duration` and returns `f64`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur1 = Duration::new(2, 700_000_000);
/// let dur2 = Duration::new(5, 400_000_000);
/// assert_eq!(dur1.div_duration_f64(dur2), 0.5);
/// ```

    #[lua()]
    fn div_duration_f64(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> f64;

"#,
    r#"
/// Divides `Duration` by `Duration` and returns `f32`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur1 = Duration::new(2, 700_000_000);
/// let dur2 = Duration::new(5, 400_000_000);
/// assert_eq!(dur1.div_duration_f32(dur2), 0.5);
/// ```

    #[lua()]
    fn div_duration_f32(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> f32;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::utils::Duration>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<u32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::utils::Duration>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Duration {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::utils::Instant",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: LuaReflectRefProxy<bevy::utils::Instant>,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::utils::Instant>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::utils::Instant>,
        other: LuaReflectRefProxy<bevy::utils::Instant>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::utils::Instant>,
    ) -> LuaReflectValProxy<bevy::utils::Instant>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::utils::Duration>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::utils::Instant>,
        other: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Instant>;

"#,
    r#"
/// Returns the amount of time elapsed from another instant to this one,
/// or zero duration if that instant is later than this one.
/// # Panics
/// Previous Rust versions panicked when `other` was later than `self`. Currently this
/// method saturates. Future versions may reintroduce the panic in some circumstances.
/// See [Monotonicity].
/// [Monotonicity]: Instant#monotonicity

    #[lua(as_trait = "std::ops::Sub::<bevy::utils::Instant>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::utils::Instant>,
        other: LuaReflectValProxy<bevy::utils::Instant>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Returns an instant corresponding to "now".
/// # Examples
/// ```
/// use std::time::Instant;
/// let now = Instant::now();
/// ```

    #[lua()]
    fn now() -> LuaReflectValProxy<bevy::utils::Instant>;

"#,
    r#"
/// Returns the amount of time elapsed from another instant to this one,
/// or zero duration if that instant is later than this one.
/// # Panics
/// Previous Rust versions panicked when `earlier` was later than `self`. Currently this
/// method saturates. Future versions may reintroduce the panic in some circumstances.
/// See [Monotonicity].
/// [Monotonicity]: Instant#monotonicity
/// # Examples
/// ```no_run
/// use std::time::{Duration, Instant};
/// use std::thread::sleep;
/// let now = Instant::now();
/// sleep(Duration::new(1, 0));
/// let new_now = Instant::now();
/// println!("{:?}", new_now.duration_since(now));
/// println!("{:?}", now.duration_since(new_now)); // 0ns
/// ```

    #[lua()]
    fn duration_since(
        _self: LuaReflectRefProxy<bevy::utils::Instant>,
        earlier: LuaReflectValProxy<bevy::utils::Instant>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Returns the amount of time elapsed from another instant to this one,
/// or zero duration if that instant is later than this one.
/// # Examples
/// ```no_run
/// use std::time::{Duration, Instant};
/// use std::thread::sleep;
/// let now = Instant::now();
/// sleep(Duration::new(1, 0));
/// let new_now = Instant::now();
/// println!("{:?}", new_now.saturating_duration_since(now));
/// println!("{:?}", now.saturating_duration_since(new_now)); // 0ns
/// ```

    #[lua()]
    fn saturating_duration_since(
        _self: LuaReflectRefProxy<bevy::utils::Instant>,
        earlier: LuaReflectValProxy<bevy::utils::Instant>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// Returns the amount of time elapsed since this instant.
/// # Panics
/// Previous Rust versions panicked when the current time was earlier than self. Currently this
/// method returns a Duration of zero in that case. Future versions may reintroduce the panic.
/// See [Monotonicity].
/// [Monotonicity]: Instant#monotonicity
/// # Examples
/// ```no_run
/// use std::thread::sleep;
/// use std::time::{Duration, Instant};
/// let instant = Instant::now();
/// let three_secs = Duration::from_secs(3);
/// sleep(three_secs);
/// assert!(instant.elapsed() >= three_secs);
/// ```

    #[lua()]
    fn elapsed(
        _self: LuaReflectRefProxy<bevy::utils::Instant>,
    ) -> LuaReflectValProxy<bevy::utils::Duration>;

"#,
    r#"
/// # Panics
/// This function may panic if the resulting point in time cannot be represented by the
/// underlying data structure. See [`Instant::checked_add`] for a version without panic.

    #[lua(as_trait = "std::ops::Add::<bevy::utils::Duration>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::utils::Instant>,
        other: LuaReflectValProxy<bevy::utils::Duration>,
    ) -> LuaReflectValProxy<bevy::utils::Instant>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Instant();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::path::PathBuf",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<std::path::PathBuf>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<std::path::PathBuf>,
        other: LuaReflectRefProxy<std::path::PathBuf>,
    ) -> bool;

"#,
    r#"
/// Allocates an empty `PathBuf`.
/// # Examples
/// ```
/// use std::path::PathBuf;
/// let path = PathBuf::new();
/// ```

    #[lua()]
    fn new() -> LuaReflectValProxy<std::path::PathBuf>;

"#,
    r#"
/// Creates a new `PathBuf` with a given capacity used to create the
/// internal [`OsString`]. See [`with_capacity`] defined on [`OsString`].
/// # Examples
/// ```
/// use std::path::PathBuf;
/// let mut path = PathBuf::with_capacity(10);
/// let capacity = path.capacity();
/// // This push is done without reallocating
/// path.push(r"C:\");
/// assert_eq!(capacity, path.capacity());
/// ```
/// [`with_capacity`]: OsString::with_capacity

    #[lua()]
    fn with_capacity(capacity: usize) -> LuaReflectValProxy<std::path::PathBuf>;

"#,
    r#"
/// Truncates `self` to [`self.parent`].
/// Returns `false` and does nothing if [`self.parent`] is [`None`].
/// Otherwise, returns `true`.
/// [`self.parent`]: Path::parent
/// # Examples
/// ```
/// use std::path::{Path, PathBuf};
/// let mut p = PathBuf::from("/spirited/away.rs");
/// p.pop();
/// assert_eq!(Path::new("/spirited"), p);
/// p.pop();
/// assert_eq!(Path::new("/"), p);
/// ```

    #[lua()]
    fn pop(_self: LuaReflectRefMutProxy<std::path::PathBuf>) -> bool;

"#,
    r#"
/// Invokes [`capacity`] on the underlying instance of [`OsString`].
/// [`capacity`]: OsString::capacity

    #[lua()]
    fn capacity(_self: LuaReflectRefProxy<std::path::PathBuf>) -> usize;

"#,
    r#"
/// Invokes [`clear`] on the underlying instance of [`OsString`].
/// [`clear`]: OsString::clear

    #[lua()]
    fn clear(_self: LuaReflectRefMutProxy<std::path::PathBuf>) -> ();

"#,
    r#"
/// Invokes [`reserve`] on the underlying instance of [`OsString`].
/// [`reserve`]: OsString::reserve

    #[lua()]
    fn reserve(
        _self: LuaReflectRefMutProxy<std::path::PathBuf>,
        additional: usize,
    ) -> ();

"#,
    r#"
/// Invokes [`reserve_exact`] on the underlying instance of [`OsString`].
/// [`reserve_exact`]: OsString::reserve_exact

    #[lua()]
    fn reserve_exact(
        _self: LuaReflectRefMutProxy<std::path::PathBuf>,
        additional: usize,
    ) -> ();

"#,
    r#"
/// Invokes [`shrink_to_fit`] on the underlying instance of [`OsString`].
/// [`shrink_to_fit`]: OsString::shrink_to_fit

    #[lua()]
    fn shrink_to_fit(_self: LuaReflectRefMutProxy<std::path::PathBuf>) -> ();

"#,
    r#"
/// Invokes [`shrink_to`] on the underlying instance of [`OsString`].
/// [`shrink_to`]: OsString::shrink_to

    #[lua()]
    fn shrink_to(
        _self: LuaReflectRefMutProxy<std::path::PathBuf>,
        min_capacity: usize,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<std::path::PathBuf>,
    ) -> LuaReflectValProxy<std::path::PathBuf>;

"#,
    r#"
/// Clones the contents of `source` into `self`.
/// This method is preferred over simply assigning `source.clone()` to `self`,
/// as it avoids reallocation if possible.

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone_from(
        _self: LuaReflectRefMutProxy<std::path::PathBuf>,
        source: LuaReflectRefProxy<std::path::PathBuf>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct PathBuf {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "std::ops::RangeFull",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<std::ops::RangeFull>,
    ) -> LuaReflectValProxy<std::ops::RangeFull>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<std::ops::RangeFull>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<std::ops::RangeFull>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<std::ops::RangeFull>,
        other: LuaReflectRefProxy<std::ops::RangeFull>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RangeFull {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Quat",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Adds two quaternions.
/// The sum is not guaranteed to be normalized.
/// Note that addition is not the same as combining the rotations represented by the
/// two quaternions! That corresponds to multiplication.

    #[lua(as_trait = "std::ops::Add::<bevy::math::Quat>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Multiplies two quaternions. If they each represent a rotation, the result will
/// represent the combined rotation.
/// Note that due to floating point rounding the result may not be perfectly
/// normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Quat>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Multiplies a quaternion and a 3D vector, returning the rotated vector.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Multiplies a quaternion by a scalar value.
/// The product is not guaranteed to be normalized.

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a new rotation quaternion.
/// This should generally not be called manually unless you know what you are doing.
/// Use one of the other constructors instead such as `identity` or `from_axis_angle`.
/// `from_xyzw` is mostly used by unit tests and `serde` deserialization.
/// # Preconditions
/// This function does not check if the input is normalized, it is up to the user to
/// provide normalized input or to normalized the resulting quaternion.

    #[lua()]
    fn from_xyzw(x: f32, y: f32, z: f32, w: f32) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a rotation quaternion from an array.
/// # Preconditions
/// This function does not check if the input is normalized, it is up to the user to
/// provide normalized input or to normalized the resulting quaternion.

    #[lua()]
    fn from_array(a: [f32; 4]) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a new rotation quaternion from a 4D vector.
/// # Preconditions
/// This function does not check if the input is normalized, it is up to the user to
/// provide normalized input or to normalized the resulting quaternion.

    #[lua()]
    fn from_vec4(
        v: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
/// The axis must be a unit vector.
/// # Panics
/// Will panic if `axis` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::Vec3>,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
/// `from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.

    #[lua()]
    fn from_scaled_axis(
        v: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from the `angle` (in radians) around the x axis.

    #[lua()]
    fn from_rotation_x(angle: f32) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from the `angle` (in radians) around the y axis.

    #[lua()]
    fn from_rotation_y(angle: f32) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from the `angle` (in radians) around the z axis.

    #[lua()]
    fn from_rotation_z(angle: f32) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from the given Euler rotation sequence and the angles (in radians).

    #[lua()]
    fn from_euler(
        euler: LuaReflectValProxy<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from a 3x3 rotation matrix.
/// Note if the input matrix contain scales, shears, or other non-rotation transformations then
/// the resulting quaternion will be ill-defined.
/// # Panics
/// Will panic if any input matrix column is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_mat3(
        mat: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from a 3x3 SIMD aligned rotation matrix.
/// Note if the input matrix contain scales, shears, or other non-rotation transformations then
/// the resulting quaternion will be ill-defined.
/// # Panics
/// Will panic if any input matrix column is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_mat3a(
        mat: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from the upper 3x3 rotation matrix inside a homogeneous 4x4 matrix.
/// Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
/// then the resulting quaternion will be ill-defined.
/// # Panics
/// Will panic if any column of the upper 3x3 rotation matrix is not normalized when
/// `glam_assert` is enabled.

    #[lua()]
    fn from_mat4(
        mat: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
/// plane spanned by the two vectors.  Will rotate at most 180 degrees.
/// The inputs must be unit vectors.
/// `from_rotation_arc(from, to) * from ≈ to`.
/// For near-singular cases (from≈to and from≈-to) the current implementation
/// is only accurate to about 0.001 (for `f32`).
/// # Panics
/// Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_arc(
        from: LuaReflectValProxy<bevy::math::Vec3>,
        to: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
/// that the resulting quaternion will rotate `from` so that it is colinear with `to`.
/// The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
/// degrees.
/// The inputs must be unit vectors.
/// `to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
/// # Panics
/// Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_arc_colinear(
        from: LuaReflectValProxy<bevy::math::Vec3>,
        to: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
/// around the z axis. Will rotate at most 180 degrees.
/// The inputs must be unit vectors.
/// `from_rotation_arc_2d(from, to) * from ≈ to`.
/// For near-singular cases (from≈to and from≈-to) the current implementation
/// is only accurate to about 0.001 (for `f32`).
/// # Panics
/// Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_arc_2d(
        from: LuaReflectValProxy<bevy::math::Vec2>,
        to: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Returns the rotation axis scaled by the rotation in radians.

    #[lua()]
    fn to_scaled_axis(
        _self: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the rotation angles for the given euler rotation sequence.

    #[lua()]
    fn to_euler(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        order: LuaReflectValProxy<bevy::math::EulerRot>,
    ) -> (f32, f32, f32);

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::Quat>) -> [f32; 4];

"#,
    r#"
/// Returns the vector part of the quaternion.

    #[lua()]
    fn xyz(
        _self: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the quaternion conjugate of `self`. For a unit quaternion the
/// conjugate is also the inverse.

    #[lua()]
    fn conjugate(
        _self: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Returns the inverse of a normalized quaternion.
/// Typically quaternion inverse returns the conjugate of a normalized quaternion.
/// Because `self` is assumed to already be unit length this method *does not* normalize
/// before returning the conjugate.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`. The dot product is
/// equal to the cosine of the angle between two quaternion rotations.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
    ) -> f32;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::Quat>) -> f32;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is generally faster than `length()` as it avoids a square
/// root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::Quat>) -> f32;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::Quat>) -> f32;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must _not_ be of length zero.
/// Panics
/// Will panic if `self` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::Quat>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NAN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::Quat>) -> bool;

"#,
    r#"
/// Returns whether `self` of length `1.0` or not.
/// Uses a precision threshold of `1e-6`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::Quat>) -> bool;

"#,
    r#"

    #[lua()]
    fn is_near_identity(_self: LuaReflectValProxy<bevy::math::Quat>) -> bool;

"#,
    r#"
/// Returns the angle (in radians) for the minimal rotation
/// for transforming this quaternion into another.
/// Both quaternions must be normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
    ) -> f32;

"#,
    r#"
/// Rotates towards `rhs` up to `max_angle` (in radians).
/// When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
/// `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
/// rotates towards the exact opposite of `rhs`. Will not go past the target.
/// Both quaternions must be normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn rotate_towards(
        _self: LuaReflectRefProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
        max_angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two quaternions contain similar elements. It works
/// best when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on
/// the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s`
/// is `1.0`, the result will be equal to `rhs`.
/// # Panics
/// Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        end: LuaReflectValProxy<bevy::math::Quat>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Performs a spherical linear interpolation between `self` and `end`
/// based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s`
/// is `1.0`, the result will be equal to `end`.
/// # Panics
/// Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn slerp(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        end: LuaReflectValProxy<bevy::math::Quat>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Multiplies a quaternion and a 3D vector, returning the rotated vector.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn mul_vec3(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Multiplies two quaternions. If they each represent a rotation, the result will
/// represent the combined rotation.
/// Note that due to floating point rounding the result may not be perfectly normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn mul_quat(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
/// Note if the input affine matrix contain scales, shears, or other non-rotation
/// transformations then the resulting quaternion will be ill-defined.
/// # Panics
/// Will panic if any input affine matrix column is not normalized when `glam_assert` is
/// enabled.

    #[lua()]
    fn from_affine3(
        a: LuaReflectRefProxy<bevy::math::Affine3A>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Multiplies a quaternion and a 3D vector, returning the rotated vector.

    #[lua()]
    fn mul_vec3a(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua()]
    fn as_dquat(
        _self: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Divides a quaternion by a scalar value.
/// The quotient is not guaranteed to be normalized.

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"
/// Subtracts the `rhs` quaternion from `self`.
/// The difference is not guaranteed to be normalized.

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Quat>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Quat>,
        rhs: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Quat>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Quat>,
        rhs: LuaReflectRefProxy<bevy::math::Quat>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Quat();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Vec3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::Vec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::Vec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Vec3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
        other: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::Vec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<f32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<f32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::Vec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::Vec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: f32, y: f32, z: f32) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: f32) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec3>,
        if_true: LuaReflectValProxy<bevy::math::Vec3>,
        if_false: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [f32; 3]) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// `[x, y, z]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::Vec3>) -> [f32; 3];

"#,
    r#"
/// Creates a 4D vector from `self` and the given `w` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        w: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
/// Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        x: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        y: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        z: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> f32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Computes the cross product of `self` and `rhs`.

    #[lua()]
    fn cross(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`f32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        min: LuaReflectValProxy<bevy::math::Vec3>,
        max: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::Vec3>) -> f32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::Vec3>) -> f32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::Vec3>) -> f32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::Vec3>) -> f32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
/// - `NAN` if the number is `NAN`

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector with signs of `rhs` and the magnitudes of `self`.

    #[lua()]
    fn copysign(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::Vec3>) -> u32;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.  If any element is either
/// `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::Vec3>) -> bool;

"#,
    r#"
/// Performs `is_finite` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.

    #[lua()]
    fn is_finite_mask(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::Vec3>) -> bool;

"#,
    r#"
/// Performs `is_nan` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.

    #[lua()]
    fn is_nan_mask(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::Vec3>) -> f32;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is faster than `length()` as it avoids a square root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::Vec3>) -> f32;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::Vec3>) -> f32;

"#,
    r#"
/// Computes the Euclidean distance between two points in space.

    #[lua()]
    fn distance(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> f32;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> f32;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// [Euclidean division]: f32::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
/// See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
/// Panics
/// Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns a
/// fallback value.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be the fallback value.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        fallback: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns zero.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be zero.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or_zero(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns whether `self` is length `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::Vec3>) -> bool;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn project_onto(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` has a length of zero when `glam_assert` is enabled.

    #[lua()]
    fn reject_from(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn project_onto_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reject_from_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the nearest integer to a number for each element of `self`.
/// Round half-way cases away from 0.0.

    #[lua()]
    fn round(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the largest integer less than or equal to a number for each
/// element of `self`.

    #[lua()]
    fn floor(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the smallest integer greater than or equal to a number for
/// each element of `self`.

    #[lua()]
    fn ceil(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the integer part each element of `self`. This means numbers are
/// always truncated towards zero.

    #[lua()]
    fn trunc(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
/// Note that this differs from the GLSL implementation of `fract` which returns
/// `self - self.floor()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.floor()`.
/// Note that this differs from the Rust implementation of `fract` which returns
/// `self - self.trunc()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract_gl(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing `e^self` (the exponential function) for each element of
/// `self`.

    #[lua()]
    fn exp(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing each element of `self` raised to the power of `n`.

    #[lua()]
    fn powf(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        n: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector containing the reciprocal `1.0/n` of each element of `self`.

    #[lua()]
    fn recip(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
/// will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
/// extrapolated.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Moves towards `rhs` based on the value `d`.
/// When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
/// `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.

    #[lua()]
    fn move_towards(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
        d: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Calculates the midpoint between `self` and `rhs`.
/// The midpoint is the average of, or halfway point between, two vectors.
/// `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
/// while being slightly cheaper to compute.

    #[lua()]
    fn midpoint(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs` is
/// less than or equal to `max_abs_diff`.
/// This can be used to compare if two vectors contain similar elements. It works best when
/// comparing with a known value. The `max_abs_diff` that should be used used depends on
/// the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Returns a vector with a length no less than `min` and no more than `max`.
/// # Panics
/// Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        min: f32,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector with a length no more than `max`.
/// # Panics
/// Will panic if `max` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_max(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns a vector with a length no less than `min`.
/// # Panics
/// Will panic if `min` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_min(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        min: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
/// error, yielding a more accurate result than an unfused multiply-add.
/// Using `mul_add` *may* be more performant than an unfused multiply-add if the target
/// architecture has a dedicated fma CPU instruction. However, this is not always true,
/// and will be heavily dependant on designing algorithms with specific target hardware in
/// mind.

    #[lua()]
    fn mul_add(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        a: LuaReflectValProxy<bevy::math::Vec3>,
        b: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the reflection vector for a given incident vector `self` and surface normal
/// `normal`.
/// `normal` must be normalized.
/// # Panics
/// Will panic if `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reflect(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        normal: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the refraction direction for a given incident vector `self`, surface normal
/// `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
/// a zero vector will be returned.
/// `self` and `normal` must be normalized.
/// # Panics
/// Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn refract(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        normal: LuaReflectValProxy<bevy::math::Vec3>,
        eta: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the angle (in radians) between two vectors in the range `[0, +π]`.
/// The inputs do not need to be unit vectors however they must be non-zero.

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> f32;

"#,
    r#"
/// Returns some vector that is orthogonal to the given one.
/// The input vector must be finite and non-zero.
/// The output vector is not necessarily unit length. For that use
/// [`Self::any_orthonormal_vector()`] instead.

    #[lua()]
    fn any_orthogonal_vector(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns any unit vector that is orthogonal to the given one.
/// The input vector must be unit length.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn any_orthonormal_vector(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Vec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Vec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::Vec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<f32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<f32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: f32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct Vec3 {
    x: f32,
    y: f32,
    z: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::IVec2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::IVec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<i32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::IVec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: i32, y: i32) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: i32) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec2>,
        if_true: LuaReflectValProxy<bevy::math::IVec2>,
        if_false: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [i32; 2]) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// `[x, y]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::IVec2>) -> [i32; 2];

"#,
    r#"
/// Creates a 3D vector from `self` and the given `z` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        z: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        x: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        y: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> i32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`i32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        min: LuaReflectValProxy<bevy::math::IVec2>,
        max: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::IVec2>) -> i32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::IVec2>) -> i32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::IVec2>) -> i32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::IVec2>) -> i32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
///  - `0` if the number is zero
///  - `1` if the number is positive
///  - `-1` if the number is negative

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::IVec2>) -> u32;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::IVec2>) -> i32;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> i32;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.
/// [Euclidean division]: i32::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector that is equal to `self` rotated by 90 degrees.

    #[lua()]
    fn perp(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// The perpendicular dot product of `self` and `rhs`.
/// Also known as the wedge product, 2D cross product, and determinant.

    #[lua()]
    fn perp_dot(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> i32;

"#,
    r#"
/// Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
/// then this just rotation. This is what you usually want. Otherwise,
/// it will be like a rotation with a multiplication by `self`'s length.

    #[lua()]
    fn rotate(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec2(
        _self: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec2(
        _self: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec2(
        _self: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec2(
        _self: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec2(
        _self: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<i32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::IVec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::IVec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<i32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::IVec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::IVec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::IVec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::IVec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<i32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::IVec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::IVec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::IVec2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::IVec2>,
        other: LuaReflectRefProxy<bevy::math::IVec2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<i32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec2>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::IVec2>) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<i32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: i32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct IVec2 {
    x: i32,
    y: i32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::IVec3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::IVec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::IVec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: i32, y: i32, z: i32) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: i32) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec3>,
        if_true: LuaReflectValProxy<bevy::math::IVec3>,
        if_false: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [i32; 3]) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// `[x, y, z]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::IVec3>) -> [i32; 3];

"#,
    r#"
/// Creates a 4D vector from `self` and the given `w` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        w: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
/// Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        x: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        y: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        z: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> i32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Computes the cross product of `self` and `rhs`.

    #[lua()]
    fn cross(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`i32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        min: LuaReflectValProxy<bevy::math::IVec3>,
        max: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::IVec3>) -> i32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::IVec3>) -> i32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::IVec3>) -> i32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::IVec3>) -> i32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
///  - `0` if the number is zero
///  - `1` if the number is positive
///  - `-1` if the number is negative

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::IVec3>) -> u32;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::IVec3>) -> i32;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> i32;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.
/// [Euclidean division]: i32::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3a(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec3(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec3(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec3(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec3(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::IVec3>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::IVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::IVec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::IVec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::IVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<i32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::IVec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<i32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::IVec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<i32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::IVec3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::IVec3>,
        other: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::IVec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::IVec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: LuaReflectRefProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<i32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<i32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec3>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<i32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: i32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct IVec3 {
    x: i32,
    y: i32,
    z: i32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::IVec4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::IVec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::IVec4>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<i32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::IVec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::IVec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: i32, y: i32, z: i32, w: i32) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: i32) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec4>,
        if_true: LuaReflectValProxy<bevy::math::IVec4>,
        if_false: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [i32; 4]) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::IVec4>) -> [i32; 4];

"#,
    r#"
/// Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
/// Truncation to [`IVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        x: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        y: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        z: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `w`.

    #[lua()]
    fn with_w(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        w: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> i32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`i32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        min: LuaReflectValProxy<bevy::math::IVec4>,
        max: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::IVec4>) -> i32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::IVec4>) -> i32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::IVec4>) -> i32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::IVec4>) -> i32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
///  - `0` if the number is zero
///  - `1` if the number is positive
///  - `-1` if the number is negative

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::IVec4>) -> u32;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::IVec4>) -> i32;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> i32;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.
/// [Euclidean division]: i32::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec4(
        _self: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec4(
        _self: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec4(
        _self: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec4(
        _self: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec4(
        _self: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<i32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<i32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::IVec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<i32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::IVec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::IVec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::IVec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<i32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: i32,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::IVec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::IVec4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::IVec4>,
        other: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::IVec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::IVec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::IVec4>,
        rhs: LuaReflectRefProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<i32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: i32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct IVec4 {
    x: i32,
    y: i32,
    z: i32,
    w: i32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::I64Vec2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::I64Vec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::I64Vec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<i64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::I64Vec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<i64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::I64Vec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<i64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::I64Vec2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::I64Vec2>,
        other: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> bool;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: i64, y: i64) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: i64) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec2>,
        if_true: LuaReflectValProxy<bevy::math::I64Vec2>,
        if_false: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [i64; 2]) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// `[x, y]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::I64Vec2>) -> [i64; 2];

"#,
    r#"
/// Creates a 3D vector from `self` and the given `z` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        z: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        x: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        y: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> i64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`i64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        min: LuaReflectValProxy<bevy::math::I64Vec2>,
        max: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::I64Vec2>) -> i64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::I64Vec2>) -> i64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::I64Vec2>) -> i64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::I64Vec2>) -> i64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
///  - `0` if the number is zero
///  - `1` if the number is positive
///  - `-1` if the number is negative

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::I64Vec2>) -> u32;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::I64Vec2>) -> i64;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> i64;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.
/// [Euclidean division]: i64::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector that is equal to `self` rotated by 90 degrees.

    #[lua()]
    fn perp(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// The perpendicular dot product of `self` and `rhs`.
/// Also known as the wedge product, 2D cross product, and determinant.

    #[lua()]
    fn perp_dot(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> i64;

"#,
    r#"
/// Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
/// then this just rotation. This is what you usually want. Otherwise,
/// it will be like a rotation with a multiplication by `self`'s length.

    #[lua()]
    fn rotate(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec2(
        _self: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec2(
        _self: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec2(
        _self: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec2(
        _self: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec2(
        _self: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<i64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::I64Vec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::I64Vec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::I64Vec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<i64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::I64Vec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::I64Vec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::I64Vec2>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::I64Vec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct I64Vec2 {
    x: i64,
    y: i64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::I64Vec3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<i64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::I64Vec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::I64Vec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<i64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::I64Vec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::I64Vec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::I64Vec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<i64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<i64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::I64Vec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::I64Vec3>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<i64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::I64Vec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::I64Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::I64Vec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::I64Vec3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
        other: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::I64Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: i64, y: i64, z: i64) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: i64) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec3>,
        if_true: LuaReflectValProxy<bevy::math::I64Vec3>,
        if_false: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [i64; 3]) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// `[x, y, z]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::I64Vec3>) -> [i64; 3];

"#,
    r#"
/// Creates a 4D vector from `self` and the given `w` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        w: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
/// Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        x: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        y: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        z: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> i64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Computes the cross product of `self` and `rhs`.

    #[lua()]
    fn cross(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`i64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        min: LuaReflectValProxy<bevy::math::I64Vec3>,
        max: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::I64Vec3>) -> i64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::I64Vec3>) -> i64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::I64Vec3>) -> i64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::I64Vec3>) -> i64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
///  - `0` if the number is zero
///  - `1` if the number is positive
///  - `-1` if the number is negative

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::I64Vec3>) -> u32;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::I64Vec3>) -> i64;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> i64;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.
/// [Euclidean division]: i64::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3a(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec3(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec3(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec3(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec3(
        _self: LuaReflectRefProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct I64Vec3 {
    x: i64,
    y: i64,
    z: i64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::I64Vec4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::I64Vec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<i64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::I64Vec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: i64, y: i64, z: i64, w: i64) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: i64) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec4>,
        if_true: LuaReflectValProxy<bevy::math::I64Vec4>,
        if_false: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [i64; 4]) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::I64Vec4>) -> [i64; 4];

"#,
    r#"
/// Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
/// Truncation to [`I64Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        x: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        y: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        z: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `w`.

    #[lua()]
    fn with_w(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        w: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> i64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`i64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        min: LuaReflectValProxy<bevy::math::I64Vec4>,
        max: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::I64Vec4>) -> i64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::I64Vec4>) -> i64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::I64Vec4>) -> i64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::I64Vec4>) -> i64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
///  - `0` if the number is zero
///  - `1` if the number is positive
///  - `-1` if the number is negative

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::I64Vec4>) -> u32;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::I64Vec4>) -> i64;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> i64;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// # Panics
/// This function will panic if any `rhs` element is 0 or the division results in overflow.
/// [Euclidean division]: i64::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec4(
        _self: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec4(
        _self: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec4(
        _self: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec4(
        _self: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec4(
        _self: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
/// In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub_unsigned(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::I64Vec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::I64Vec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::I64Vec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<i64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::I64Vec4>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::I64Vec4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::I64Vec4>,
        other: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::I64Vec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<i64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::I64Vec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::I64Vec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::I64Vec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<i64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<i64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: i64,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::I64Vec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::I64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct I64Vec4 {
    x: i64,
    y: i64,
    z: i64,
    w: i64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::UVec2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::UVec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::UVec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::UVec2>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::UVec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::UVec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::UVec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<u32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: u32, y: u32) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: u32) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec2>,
        if_true: LuaReflectValProxy<bevy::math::UVec2>,
        if_false: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [u32; 2]) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// `[x, y]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::UVec2>) -> [u32; 2];

"#,
    r#"
/// Creates a 3D vector from `self` and the given `z` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        z: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        x: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        y: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> u32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`u32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        min: LuaReflectValProxy<bevy::math::UVec2>,
        max: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::UVec2>) -> u32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::UVec2>) -> u32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::UVec2>) -> u32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::UVec2>) -> u32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::UVec2>) -> u32;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec2(
        _self: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec2(
        _self: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec2(
        _self: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec2(
        _self: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec2(
        _self: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_signed(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_signed(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::IVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::UVec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::UVec2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::UVec2>,
        other: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<u32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::UVec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::UVec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<u32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::UVec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectValProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<u32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::UVec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::UVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<u32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec2>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<u32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: u32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct UVec2 {
    x: u32,
    y: u32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::UVec3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::UVec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::UVec3>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::UVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<u32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<u32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::UVec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::UVec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::UVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: u32, y: u32, z: u32) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: u32) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec3>,
        if_true: LuaReflectValProxy<bevy::math::UVec3>,
        if_false: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [u32; 3]) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// `[x, y, z]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::UVec3>) -> [u32; 3];

"#,
    r#"
/// Creates a 4D vector from `self` and the given `w` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        w: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
/// Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        x: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        y: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        z: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> u32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Computes the cross product of `self` and `rhs`.

    #[lua()]
    fn cross(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`u32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        min: LuaReflectValProxy<bevy::math::UVec3>,
        max: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::UVec3>) -> u32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::UVec3>) -> u32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::UVec3>) -> u32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::UVec3>) -> u32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::UVec3>) -> u32;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3a(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec3(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec3(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec3(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec3(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_signed(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_signed(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::IVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<u32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::UVec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<u32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::UVec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::UVec3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::UVec3>,
        other: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<u32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::UVec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::UVec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectValProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::UVec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec3>,
        rhs: LuaReflectRefProxy<bevy::math::UVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<u32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: u32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct UVec3 {
    x: u32,
    y: u32,
    z: u32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::UVec4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::UVec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::UVec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<u32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::UVec4>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<u32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<u32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::UVec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::UVec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::UVec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::UVec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::UVec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::UVec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<u32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::UVec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<u32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::UVec4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::UVec4>,
        other: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> bool;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: u32, y: u32, z: u32, w: u32) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: u32) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec4>,
        if_true: LuaReflectValProxy<bevy::math::UVec4>,
        if_false: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [u32; 4]) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::UVec4>) -> [u32; 4];

"#,
    r#"
/// Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
/// Truncation to [`UVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        x: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        y: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        z: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `w`.

    #[lua()]
    fn with_w(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        w: u32,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> u32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`u32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        min: LuaReflectValProxy<bevy::math::UVec4>,
        max: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::UVec4>) -> u32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::UVec4>) -> u32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::UVec4>) -> u32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::UVec4>) -> u32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::UVec4>) -> u32;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec4(
        _self: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec4(
        _self: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec4(
        _self: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec4(
        _self: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec4(
        _self: LuaReflectRefProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_signed(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_signed(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::IVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::UVec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::UVec4>,
        rhs: LuaReflectValProxy<bevy::math::UVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<u32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: u32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct UVec4 {
    x: u32,
    y: u32,
    z: u32,
    w: u32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::U64Vec2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::U64Vec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::U64Vec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::U64Vec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<u64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::U64Vec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::U64Vec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::U64Vec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<u64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::U64Vec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::U64Vec2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::U64Vec2>,
        other: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::U64Vec2>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<u64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<u64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<u64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::U64Vec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::U64Vec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: u64, y: u64) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: u64) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec2>,
        if_true: LuaReflectValProxy<bevy::math::U64Vec2>,
        if_false: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [u64; 2]) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// `[x, y]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::U64Vec2>) -> [u64; 2];

"#,
    r#"
/// Creates a 3D vector from `self` and the given `z` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        z: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        x: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        y: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> u64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`u64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        min: LuaReflectValProxy<bevy::math::U64Vec2>,
        max: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::U64Vec2>) -> u64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::U64Vec2>) -> u64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::U64Vec2>) -> u64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::U64Vec2>) -> u64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::U64Vec2>) -> u64;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec2(
        _self: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec2(
        _self: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec2(
        _self: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec2(
        _self: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec2(
        _self: LuaReflectRefProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_signed(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_signed(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::U64Vec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec2>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct U64Vec2 {
    x: u64,
    y: u64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::U64Vec3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::U64Vec3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
        other: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<u64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::U64Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<u64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: u64, y: u64, z: u64) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: u64) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec3>,
        if_true: LuaReflectValProxy<bevy::math::U64Vec3>,
        if_false: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [u64; 3]) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// `[x, y, z]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::U64Vec3>) -> [u64; 3];

"#,
    r#"
/// Creates a 4D vector from `self` and the given `w` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        w: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
/// Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        x: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        y: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        z: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> u64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Computes the cross product of `self` and `rhs`.

    #[lua()]
    fn cross(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`u64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        min: LuaReflectValProxy<bevy::math::U64Vec3>,
        max: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::U64Vec3>) -> u64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::U64Vec3>) -> u64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::U64Vec3>) -> u64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::U64Vec3>) -> u64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::U64Vec3>) -> u64;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3a(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec3(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec3(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec3(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec3(
        _self: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_signed(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_signed(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::U64Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::U64Vec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<u64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::U64Vec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::U64Vec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::U64Vec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<u64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::U64Vec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::U64Vec3>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::U64Vec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::U64Vec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::U64Vec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<u64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec3>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct U64Vec3 {
    x: u64,
    y: u64,
    z: u64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::U64Vec4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::U64Vec4>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::U64Vec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: u64, y: u64, z: u64, w: u64) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: u64) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec4>,
        if_true: LuaReflectValProxy<bevy::math::U64Vec4>,
        if_false: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [u64; 4]) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::U64Vec4>) -> [u64; 4];

"#,
    r#"
/// Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
/// Truncation to [`U64Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        x: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        y: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        z: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `w`.

    #[lua()]
    fn with_w(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        w: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> u64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`u64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        min: LuaReflectValProxy<bevy::math::U64Vec4>,
        max: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::U64Vec4>) -> u64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::U64Vec4>) -> u64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::U64Vec4>) -> u64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::U64Vec4>) -> u64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Computes the squared length of `self`.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::U64Vec4>) -> u64;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec4(
        _self: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec4(
        _self: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec4(
        _self: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec4(
        _self: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec4(
        _self: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.

    #[lua()]
    fn wrapping_sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.

    #[lua()]
    fn wrapping_mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping division of `self` and `rhs`.
/// In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.

    #[lua()]
    fn wrapping_div(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.

    #[lua()]
    fn saturating_add(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating subtraction of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.

    #[lua()]
    fn saturating_sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating multiplication of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.

    #[lua()]
    fn saturating_mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating division of `self` and `rhs`.
/// In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.

    #[lua()]
    fn saturating_div(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.

    #[lua()]
    fn wrapping_add_signed(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
/// Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
/// In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.

    #[lua()]
    fn saturating_add_signed(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::I64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::U64Vec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<u64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::U64Vec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::U64Vec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<u64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::U64Vec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::U64Vec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<u64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::U64Vec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::U64Vec4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::U64Vec4>,
        other: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<u64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::U64Vec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::U64Vec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<u64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: u64,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::U64Vec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::U64Vec4>,
        rhs: LuaReflectValProxy<bevy::math::U64Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct U64Vec4 {
    x: u64,
    y: u64,
    z: u64,
    w: u64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Vec2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::Vec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::Vec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Vec2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
        other: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::Vec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Vec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<f32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Vec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::Vec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::Vec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::Vec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: f32, y: f32) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: f32) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec2>,
        if_true: LuaReflectValProxy<bevy::math::Vec2>,
        if_false: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [f32; 2]) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// `[x, y]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::Vec2>) -> [f32; 2];

"#,
    r#"
/// Creates a 3D vector from `self` and the given `z` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        z: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        x: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        y: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> f32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`f32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        min: LuaReflectValProxy<bevy::math::Vec2>,
        max: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
/// - `NAN` if the number is `NAN`

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector with signs of `rhs` and the magnitudes of `self`.

    #[lua()]
    fn copysign(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::Vec2>) -> u32;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.  If any element is either
/// `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::Vec2>) -> bool;

"#,
    r#"
/// Performs `is_finite` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.

    #[lua()]
    fn is_finite_mask(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::Vec2>) -> bool;

"#,
    r#"
/// Performs `is_nan` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.

    #[lua()]
    fn is_nan_mask(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is faster than `length()` as it avoids a square root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"
/// Computes the Euclidean distance between two points in space.

    #[lua()]
    fn distance(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> f32;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> f32;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// [Euclidean division]: f32::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
/// See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
/// Panics
/// Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns a
/// fallback value.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be the fallback value.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        fallback: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns zero.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be zero.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or_zero(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns whether `self` is length `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::Vec2>) -> bool;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn project_onto(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` has a length of zero when `glam_assert` is enabled.

    #[lua()]
    fn reject_from(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn project_onto_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reject_from_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the nearest integer to a number for each element of `self`.
/// Round half-way cases away from 0.0.

    #[lua()]
    fn round(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the largest integer less than or equal to a number for each
/// element of `self`.

    #[lua()]
    fn floor(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the smallest integer greater than or equal to a number for
/// each element of `self`.

    #[lua()]
    fn ceil(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the integer part each element of `self`. This means numbers are
/// always truncated towards zero.

    #[lua()]
    fn trunc(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
/// Note that this differs from the GLSL implementation of `fract` which returns
/// `self - self.floor()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.floor()`.
/// Note that this differs from the Rust implementation of `fract` which returns
/// `self - self.trunc()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract_gl(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing `e^self` (the exponential function) for each element of
/// `self`.

    #[lua()]
    fn exp(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing each element of `self` raised to the power of `n`.

    #[lua()]
    fn powf(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        n: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector containing the reciprocal `1.0/n` of each element of `self`.

    #[lua()]
    fn recip(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
/// will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
/// extrapolated.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Moves towards `rhs` based on the value `d`.
/// When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
/// `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.

    #[lua()]
    fn move_towards(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
        d: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Calculates the midpoint between `self` and `rhs`.
/// The midpoint is the average of, or halfway point between, two vectors.
/// `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
/// while being slightly cheaper to compute.

    #[lua()]
    fn midpoint(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs` is
/// less than or equal to `max_abs_diff`.
/// This can be used to compare if two vectors contain similar elements. It works best when
/// comparing with a known value. The `max_abs_diff` that should be used used depends on
/// the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Returns a vector with a length no less than `min` and no more than `max`.
/// # Panics
/// Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        min: f32,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector with a length no more than `max`.
/// # Panics
/// Will panic if `max` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_max(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns a vector with a length no less than `min`.
/// # Panics
/// Will panic if `min` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_min(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        min: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
/// error, yielding a more accurate result than an unfused multiply-add.
/// Using `mul_add` *may* be more performant than an unfused multiply-add if the target
/// architecture has a dedicated fma CPU instruction. However, this is not always true,
/// and will be heavily dependant on designing algorithms with specific target hardware in
/// mind.

    #[lua()]
    fn mul_add(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        a: LuaReflectValProxy<bevy::math::Vec2>,
        b: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the reflection vector for a given incident vector `self` and surface normal
/// `normal`.
/// `normal` must be normalized.
/// # Panics
/// Will panic if `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reflect(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        normal: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the refraction direction for a given incident vector `self`, surface normal
/// `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
/// a zero vector will be returned.
/// `self` and `normal` must be normalized.
/// # Panics
/// Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn refract(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        normal: LuaReflectValProxy<bevy::math::Vec2>,
        eta: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
/// conjunction with the [`rotate()`][Self::rotate()] method, e.g.
/// `Vec2::from_angle(PI).rotate(Vec2::Y)` will create the vector `[-1, 0]`
/// and rotate [`Vec2::Y`] around it returning `-Vec2::Y`.

    #[lua()]
    fn from_angle(angle: f32) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the angle (in radians) of this vector in the range `[-π, +π]`.
/// The input does not need to be a unit vector however it must be non-zero.

    #[lua()]
    fn to_angle(_self: LuaReflectValProxy<bevy::math::Vec2>) -> f32;

"#,
    r#"

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> f32;

"#,
    r#"
/// Returns the angle of rotation (in radians) from `self` to `rhs` in the range `[-π, +π]`.
/// The inputs do not need to be unit vectors however they must be non-zero.

    #[lua()]
    fn angle_to(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> f32;

"#,
    r#"
/// Returns a vector that is equal to `self` rotated by 90 degrees.

    #[lua()]
    fn perp(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// The perpendicular dot product of `self` and `rhs`.
/// Also known as the wedge product, 2D cross product, and determinant.

    #[lua()]
    fn perp_dot(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> f32;

"#,
    r#"
/// Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
/// then this just rotation. This is what you usually want. Otherwise,
/// it will be like a rotation with a multiplication by `self`'s length.

    #[lua()]
    fn rotate(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Rotates towards `rhs` up to `max_angle` (in radians).
/// When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
/// `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
/// rotates towards the exact opposite of `rhs`. Will not go past the target.

    #[lua()]
    fn rotate_towards(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
        max_angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec2(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec2(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec2(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec2(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec2(
        _self: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<f32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<f32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::Vec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec2>,
        rhs: LuaReflectRefProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<f32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: f32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct Vec2 {
    x: f32,
    y: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Vec3A",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::Vec3A>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<f32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::Vec3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::Vec3A>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Vec3A>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::Vec3A>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::Vec3A>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Vec3A>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Vec3A>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::Vec3A>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::Vec3A>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: f32, y: f32, z: f32) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: f32) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec3A>,
        if_true: LuaReflectValProxy<bevy::math::Vec3A>,
        if_false: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [f32; 3]) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// `[x, y, z]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::Vec3A>) -> [f32; 3];

"#,
    r#"
/// Creates a [`Vec3A`] from the `x`, `y` and `z` elements of `self` discarding `w`.
/// On architectures where SIMD is supported such as SSE2 on `x86_64` this conversion is a noop.

    #[lua()]
    fn from_vec4(
        v: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Creates a 4D vector from `self` and the given `w` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        w: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
/// Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        x: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        y: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        z: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> f32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Computes the cross product of `self` and `rhs`.

    #[lua()]
    fn cross(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`f32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        min: LuaReflectValProxy<bevy::math::Vec3A>,
        max: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> f32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> f32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> f32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> f32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
/// - `NAN` if the number is `NAN`

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector with signs of `rhs` and the magnitudes of `self`.

    #[lua()]
    fn copysign(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> u32;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.  If any element is either
/// `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> bool;

"#,
    r#"
/// Performs `is_finite` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.

    #[lua()]
    fn is_finite_mask(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> bool;

"#,
    r#"
/// Performs `is_nan` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.

    #[lua()]
    fn is_nan_mask(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> f32;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is faster than `length()` as it avoids a square root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> f32;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> f32;

"#,
    r#"
/// Computes the Euclidean distance between two points in space.

    #[lua()]
    fn distance(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> f32;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> f32;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// [Euclidean division]: f32::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
/// See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
/// Panics
/// Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns a
/// fallback value.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be the fallback value.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        fallback: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns zero.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be zero.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or_zero(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns whether `self` is length `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::Vec3A>) -> bool;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn project_onto(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` has a length of zero when `glam_assert` is enabled.

    #[lua()]
    fn reject_from(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn project_onto_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reject_from_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the nearest integer to a number for each element of `self`.
/// Round half-way cases away from 0.0.

    #[lua()]
    fn round(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the largest integer less than or equal to a number for each
/// element of `self`.

    #[lua()]
    fn floor(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the smallest integer greater than or equal to a number for
/// each element of `self`.

    #[lua()]
    fn ceil(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the integer part each element of `self`. This means numbers are
/// always truncated towards zero.

    #[lua()]
    fn trunc(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
/// Note that this differs from the GLSL implementation of `fract` which returns
/// `self - self.floor()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.floor()`.
/// Note that this differs from the Rust implementation of `fract` which returns
/// `self - self.trunc()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract_gl(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing `e^self` (the exponential function) for each element of
/// `self`.

    #[lua()]
    fn exp(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing each element of `self` raised to the power of `n`.

    #[lua()]
    fn powf(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        n: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector containing the reciprocal `1.0/n` of each element of `self`.

    #[lua()]
    fn recip(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
/// will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
/// extrapolated.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Moves towards `rhs` based on the value `d`.
/// When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
/// `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.

    #[lua()]
    fn move_towards(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
        d: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Calculates the midpoint between `self` and `rhs`.
/// The midpoint is the average of, or halfway point between, two vectors.
/// `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
/// while being slightly cheaper to compute.

    #[lua()]
    fn midpoint(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs` is
/// less than or equal to `max_abs_diff`.
/// This can be used to compare if two vectors contain similar elements. It works best when
/// comparing with a known value. The `max_abs_diff` that should be used used depends on
/// the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Returns a vector with a length no less than `min` and no more than `max`.
/// # Panics
/// Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        min: f32,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector with a length no more than `max`.
/// # Panics
/// Will panic if `max` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_max(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns a vector with a length no less than `min`.
/// # Panics
/// Will panic if `min` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_min(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        min: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
/// error, yielding a more accurate result than an unfused multiply-add.
/// Using `mul_add` *may* be more performant than an unfused multiply-add if the target
/// architecture has a dedicated fma CPU instruction. However, this is not always true,
/// and will be heavily dependant on designing algorithms with specific target hardware in
/// mind.

    #[lua()]
    fn mul_add(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        a: LuaReflectValProxy<bevy::math::Vec3A>,
        b: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the reflection vector for a given incident vector `self` and surface normal
/// `normal`.
/// `normal` must be normalized.
/// # Panics
/// Will panic if `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reflect(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        normal: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the refraction direction for a given incident vector `self`, surface normal
/// `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
/// a zero vector will be returned.
/// `self` and `normal` must be normalized.
/// # Panics
/// Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn refract(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        normal: LuaReflectValProxy<bevy::math::Vec3A>,
        eta: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the angle (in radians) between two vectors in the range `[0, +π]`.
/// The inputs do not need to be unit vectors however they must be non-zero.

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> f32;

"#,
    r#"
/// Returns some vector that is orthogonal to the given one.
/// The input vector must be finite and non-zero.
/// The output vector is not necessarily unit length. For that use
/// [`Self::any_orthonormal_vector()`] instead.

    #[lua()]
    fn any_orthogonal_vector(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns any unit vector that is orthogonal to the given one.
/// The input vector must be unit length.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn any_orthonormal_vector(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec3(
        _self: LuaReflectRefProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<f32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<f32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<f32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: f32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct Vec3A();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Vec4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::Vec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::Vec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::Vec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<f32>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Vec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Vec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::Vec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<f32>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::Vec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::Vec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<f32>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: f32, y: f32, z: f32, w: f32) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: f32) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec4A>,
        if_true: LuaReflectValProxy<bevy::math::Vec4>,
        if_false: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [f32; 4]) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::Vec4>) -> [f32; 4];

"#,
    r#"
/// Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
/// Truncation to [`Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].
/// To truncate to [`Vec3A`] use [`Vec3A::from()`].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        x: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        y: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        z: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `w`.

    #[lua()]
    fn with_w(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        w: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> f32;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`f32::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        min: LuaReflectValProxy<bevy::math::Vec4>,
        max: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::Vec4>) -> f32;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::Vec4>) -> f32;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::Vec4>) -> f32;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::Vec4>) -> f32;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
/// - `NAN` if the number is `NAN`

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector with signs of `rhs` and the magnitudes of `self`.

    #[lua()]
    fn copysign(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::Vec4>) -> u32;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.  If any element is either
/// `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::Vec4>) -> bool;

"#,
    r#"
/// Performs `is_finite` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.

    #[lua()]
    fn is_finite_mask(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::Vec4>) -> bool;

"#,
    r#"
/// Performs `is_nan` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.

    #[lua()]
    fn is_nan_mask(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::Vec4>) -> f32;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is faster than `length()` as it avoids a square root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::Vec4>) -> f32;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::Vec4>) -> f32;

"#,
    r#"
/// Computes the Euclidean distance between two points in space.

    #[lua()]
    fn distance(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> f32;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> f32;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// [Euclidean division]: f32::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
/// See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
/// Panics
/// Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns a
/// fallback value.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be the fallback value.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        fallback: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns zero.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be zero.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or_zero(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns whether `self` is length `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::Vec4>) -> bool;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn project_onto(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` has a length of zero when `glam_assert` is enabled.

    #[lua()]
    fn reject_from(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn project_onto_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reject_from_normalized(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the nearest integer to a number for each element of `self`.
/// Round half-way cases away from 0.0.

    #[lua()]
    fn round(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the largest integer less than or equal to a number for each
/// element of `self`.

    #[lua()]
    fn floor(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the smallest integer greater than or equal to a number for
/// each element of `self`.

    #[lua()]
    fn ceil(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the integer part each element of `self`. This means numbers are
/// always truncated towards zero.

    #[lua()]
    fn trunc(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
/// Note that this differs from the GLSL implementation of `fract` which returns
/// `self - self.floor()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.floor()`.
/// Note that this differs from the Rust implementation of `fract` which returns
/// `self - self.trunc()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract_gl(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing `e^self` (the exponential function) for each element of
/// `self`.

    #[lua()]
    fn exp(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing each element of `self` raised to the power of `n`.

    #[lua()]
    fn powf(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        n: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector containing the reciprocal `1.0/n` of each element of `self`.

    #[lua()]
    fn recip(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
/// will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
/// extrapolated.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Moves towards `rhs` based on the value `d`.
/// When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
/// `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.

    #[lua()]
    fn move_towards(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
        d: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Calculates the midpoint between `self` and `rhs`.
/// The midpoint is the average of, or halfway point between, two vectors.
/// `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
/// while being slightly cheaper to compute.

    #[lua()]
    fn midpoint(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs` is
/// less than or equal to `max_abs_diff`.
/// This can be used to compare if two vectors contain similar elements. It works best when
/// comparing with a known value. The `max_abs_diff` that should be used used depends on
/// the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Returns a vector with a length no less than `min` and no more than `max`.
/// # Panics
/// Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        min: f32,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector with a length no more than `max`.
/// # Panics
/// Will panic if `max` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_max(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns a vector with a length no less than `min`.
/// # Panics
/// Will panic if `min` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_min(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        min: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
/// error, yielding a more accurate result than an unfused multiply-add.
/// Using `mul_add` *may* be more performant than an unfused multiply-add if the target
/// architecture has a dedicated fma CPU instruction. However, this is not always true,
/// and will be heavily dependant on designing algorithms with specific target hardware in
/// mind.

    #[lua()]
    fn mul_add(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        a: LuaReflectValProxy<bevy::math::Vec4>,
        b: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the reflection vector for a given incident vector `self` and surface normal
/// `normal`.
/// `normal` must be normalized.
/// # Panics
/// Will panic if `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reflect(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        normal: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the refraction direction for a given incident vector `self`, surface normal
/// `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
/// a zero vector will be returned.
/// `self` and `normal` must be normalized.
/// # Panics
/// Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn refract(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        normal: LuaReflectValProxy<bevy::math::Vec4>,
        eta: f32,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `f64`.

    #[lua()]
    fn as_dvec4(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec4(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec4(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec4(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec4(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Vec4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::Vec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Vec4>,
        rhs: LuaReflectRefProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<f32> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: f32) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct Vec4();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::BVec2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::BVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::BVec2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::BVec2>,
        other: LuaReflectRefProxy<bevy::math::BVec2>,
    ) -> bool;

"#,
    r#"
/// Creates a new vector mask.

    #[lua()]
    fn new(x: bool, y: bool) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Creates a vector mask with all elements set to `v`.

    #[lua()]
    fn splat(v: bool) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Creates a new vector mask from a bool array.

    #[lua()]
    fn from_array(a: [bool; 2]) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a bitmask with the lowest 2 bits set from the elements of `self`.
/// A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn bitmask(_self: LuaReflectValProxy<bevy::math::BVec2>) -> u32;

"#,
    r#"
/// Returns true if any of the elements are true, false otherwise.

    #[lua()]
    fn any(_self: LuaReflectValProxy<bevy::math::BVec2>) -> bool;

"#,
    r#"
/// Returns true if all the elements are true, false otherwise.

    #[lua()]
    fn all(_self: LuaReflectValProxy<bevy::math::BVec2>) -> bool;

"#,
    r#"
/// Tests the value at `index`.
/// Panics if `index` is greater than 1.

    #[lua()]
    fn test(_self: LuaReflectRefProxy<bevy::math::BVec2>, index: usize) -> bool;

"#,
    r#"
/// Sets the element at `index`.
/// Panics if `index` is greater than 1.

    #[lua()]
    fn set(
        _self: LuaReflectRefMutProxy<bevy::math::BVec2>,
        index: usize,
        value: bool,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::BVec2>) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BVec2 {
    x: bool,
    y: bool,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::BVec3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::BVec3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::BVec3>,
        other: LuaReflectRefProxy<bevy::math::BVec3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::BVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Creates a new vector mask.

    #[lua()]
    fn new(x: bool, y: bool, z: bool) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Creates a vector mask with all elements set to `v`.

    #[lua()]
    fn splat(v: bool) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Creates a new vector mask from a bool array.

    #[lua()]
    fn from_array(a: [bool; 3]) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a bitmask with the lowest 3 bits set from the elements of `self`.
/// A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn bitmask(_self: LuaReflectValProxy<bevy::math::BVec3>) -> u32;

"#,
    r#"
/// Returns true if any of the elements are true, false otherwise.

    #[lua()]
    fn any(_self: LuaReflectValProxy<bevy::math::BVec3>) -> bool;

"#,
    r#"
/// Returns true if all the elements are true, false otherwise.

    #[lua()]
    fn all(_self: LuaReflectValProxy<bevy::math::BVec3>) -> bool;

"#,
    r#"
/// Tests the value at `index`.
/// Panics if `index` is greater than 2.

    #[lua()]
    fn test(_self: LuaReflectRefProxy<bevy::math::BVec3>, index: usize) -> bool;

"#,
    r#"
/// Sets the element at `index`.
/// Panics if `index` is greater than 2.

    #[lua()]
    fn set(
        _self: LuaReflectRefMutProxy<bevy::math::BVec3>,
        index: usize,
        value: bool,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::BVec3>) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BVec3 {
    x: bool,
    y: bool,
    z: bool,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::BVec4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::BVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<bevy::math::BVec4>) -> ();

"#,
    r#"
/// Creates a new vector mask.

    #[lua()]
    fn new(x: bool, y: bool, z: bool, w: bool) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Creates a vector mask with all elements set to `v`.

    #[lua()]
    fn splat(v: bool) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Creates a new vector mask from a bool array.

    #[lua()]
    fn from_array(a: [bool; 4]) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a bitmask with the lowest 4 bits set from the elements of `self`.
/// A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn bitmask(_self: LuaReflectValProxy<bevy::math::BVec4>) -> u32;

"#,
    r#"
/// Returns true if any of the elements are true, false otherwise.

    #[lua()]
    fn any(_self: LuaReflectValProxy<bevy::math::BVec4>) -> bool;

"#,
    r#"
/// Returns true if all the elements are true, false otherwise.

    #[lua()]
    fn all(_self: LuaReflectValProxy<bevy::math::BVec4>) -> bool;

"#,
    r#"
/// Tests the value at `index`.
/// Panics if `index` is greater than 3.

    #[lua()]
    fn test(_self: LuaReflectRefProxy<bevy::math::BVec4>, index: usize) -> bool;

"#,
    r#"
/// Sets the element at `index`.
/// Panics if `index` is greater than 3.

    #[lua()]
    fn set(
        _self: LuaReflectRefMutProxy<bevy::math::BVec4>,
        index: usize,
        value: bool,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::BVec4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::BVec4>,
        other: LuaReflectRefProxy<bevy::math::BVec4>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BVec4 {
    x: bool,
    y: bool,
    z: bool,
    w: bool,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DVec2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::DVec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<f64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::DVec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DVec2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
        other: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::DVec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::DVec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::DVec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<f64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: f64, y: f64) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: f64) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec2>,
        if_true: LuaReflectValProxy<bevy::math::DVec2>,
        if_false: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [f64; 2]) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// `[x, y]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::DVec2>) -> [f64; 2];

"#,
    r#"
/// Creates a 3D vector from `self` and the given `z` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        z: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        x: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a 2D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        y: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> f64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`f64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        min: LuaReflectValProxy<bevy::math::DVec2>,
        max: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
/// - `NAN` if the number is `NAN`

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector with signs of `rhs` and the magnitudes of `self`.

    #[lua()]
    fn copysign(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::DVec2>) -> u32;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.  If any element is either
/// `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::DVec2>) -> bool;

"#,
    r#"
/// Performs `is_finite` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.

    #[lua()]
    fn is_finite_mask(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::DVec2>) -> bool;

"#,
    r#"
/// Performs `is_nan` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.

    #[lua()]
    fn is_nan_mask(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::BVec2>;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is faster than `length()` as it avoids a square root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"
/// Computes the Euclidean distance between two points in space.

    #[lua()]
    fn distance(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> f64;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> f64;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// [Euclidean division]: f64::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
/// See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
/// Panics
/// Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns a
/// fallback value.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be the fallback value.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        fallback: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns zero.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be zero.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or_zero(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns whether `self` is length `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::DVec2>) -> bool;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn project_onto(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` has a length of zero when `glam_assert` is enabled.

    #[lua()]
    fn reject_from(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn project_onto_normalized(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reject_from_normalized(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the nearest integer to a number for each element of `self`.
/// Round half-way cases away from 0.0.

    #[lua()]
    fn round(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the largest integer less than or equal to a number for each
/// element of `self`.

    #[lua()]
    fn floor(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the smallest integer greater than or equal to a number for
/// each element of `self`.

    #[lua()]
    fn ceil(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the integer part each element of `self`. This means numbers are
/// always truncated towards zero.

    #[lua()]
    fn trunc(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
/// Note that this differs from the GLSL implementation of `fract` which returns
/// `self - self.floor()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.floor()`.
/// Note that this differs from the Rust implementation of `fract` which returns
/// `self - self.trunc()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract_gl(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing `e^self` (the exponential function) for each element of
/// `self`.

    #[lua()]
    fn exp(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing each element of `self` raised to the power of `n`.

    #[lua()]
    fn powf(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        n: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector containing the reciprocal `1.0/n` of each element of `self`.

    #[lua()]
    fn recip(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
/// will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
/// extrapolated.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
        s: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Moves towards `rhs` based on the value `d`.
/// When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
/// `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.

    #[lua()]
    fn move_towards(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
        d: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Calculates the midpoint between `self` and `rhs`.
/// The midpoint is the average of, or halfway point between, two vectors.
/// `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
/// while being slightly cheaper to compute.

    #[lua()]
    fn midpoint(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs` is
/// less than or equal to `max_abs_diff`.
/// This can be used to compare if two vectors contain similar elements. It works best when
/// comparing with a known value. The `max_abs_diff` that should be used used depends on
/// the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Returns a vector with a length no less than `min` and no more than `max`.
/// # Panics
/// Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        min: f64,
        max: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector with a length no more than `max`.
/// # Panics
/// Will panic if `max` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_max(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        max: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns a vector with a length no less than `min`.
/// # Panics
/// Will panic if `min` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_min(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        min: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
/// error, yielding a more accurate result than an unfused multiply-add.
/// Using `mul_add` *may* be more performant than an unfused multiply-add if the target
/// architecture has a dedicated fma CPU instruction. However, this is not always true,
/// and will be heavily dependant on designing algorithms with specific target hardware in
/// mind.

    #[lua()]
    fn mul_add(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        a: LuaReflectValProxy<bevy::math::DVec2>,
        b: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the reflection vector for a given incident vector `self` and surface normal
/// `normal`.
/// `normal` must be normalized.
/// # Panics
/// Will panic if `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reflect(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        normal: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the refraction direction for a given incident vector `self`, surface normal
/// `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
/// a zero vector will be returned.
/// `self` and `normal` must be normalized.
/// # Panics
/// Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn refract(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        normal: LuaReflectValProxy<bevy::math::DVec2>,
        eta: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
/// conjunction with the [`rotate()`][Self::rotate()] method, e.g.
/// `DVec2::from_angle(PI).rotate(DVec2::Y)` will create the vector `[-1, 0]`
/// and rotate [`DVec2::Y`] around it returning `-DVec2::Y`.

    #[lua()]
    fn from_angle(angle: f64) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the angle (in radians) of this vector in the range `[-π, +π]`.
/// The input does not need to be a unit vector however it must be non-zero.

    #[lua()]
    fn to_angle(_self: LuaReflectValProxy<bevy::math::DVec2>) -> f64;

"#,
    r#"

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> f64;

"#,
    r#"
/// Returns the angle of rotation (in radians) from `self` to `rhs` in the range `[-π, +π]`.
/// The inputs do not need to be unit vectors however they must be non-zero.

    #[lua()]
    fn angle_to(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> f64;

"#,
    r#"
/// Returns a vector that is equal to `self` rotated by 90 degrees.

    #[lua()]
    fn perp(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// The perpendicular dot product of `self` and `rhs`.
/// Also known as the wedge product, 2D cross product, and determinant.

    #[lua()]
    fn perp_dot(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> f64;

"#,
    r#"
/// Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
/// then this just rotation. This is what you usually want. Otherwise,
/// it will be like a rotation with a multiplication by `self`'s length.

    #[lua()]
    fn rotate(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Rotates towards `rhs` up to `max_angle` (in radians).
/// When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
/// `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
/// rotates towards the exact opposite of `rhs`. Will not go past the target.

    #[lua()]
    fn rotate_towards(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
        max_angle: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec2(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec2(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::IVec2>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec2(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::UVec2>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec2(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec2>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec2(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::DVec2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::DVec2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::DVec2>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<f64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DVec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::DVec2>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec2>,
        rhs: LuaReflectRefProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<f64> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: f64) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct DVec2 {
    x: f64,
    y: f64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DVec3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<f64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::DVec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::DVec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: f64, y: f64, z: f64) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: f64) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec3>,
        if_true: LuaReflectValProxy<bevy::math::DVec3>,
        if_false: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [f64; 3]) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// `[x, y, z]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::DVec3>) -> [f64; 3];

"#,
    r#"
/// Creates a 4D vector from `self` and the given `w` value.

    #[lua()]
    fn extend(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        w: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
/// Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        x: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        y: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a 3D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        z: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> f64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Computes the cross product of `self` and `rhs`.

    #[lua()]
    fn cross(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`f64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        min: LuaReflectValProxy<bevy::math::DVec3>,
        max: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::DVec3>) -> f64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::DVec3>) -> f64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::DVec3>) -> f64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::DVec3>) -> f64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
/// - `NAN` if the number is `NAN`

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector with signs of `rhs` and the magnitudes of `self`.

    #[lua()]
    fn copysign(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::DVec3>) -> u32;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.  If any element is either
/// `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::DVec3>) -> bool;

"#,
    r#"
/// Performs `is_finite` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.

    #[lua()]
    fn is_finite_mask(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::DVec3>) -> bool;

"#,
    r#"
/// Performs `is_nan` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.

    #[lua()]
    fn is_nan_mask(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::BVec3>;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::DVec3>) -> f64;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is faster than `length()` as it avoids a square root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::DVec3>) -> f64;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::DVec3>) -> f64;

"#,
    r#"
/// Computes the Euclidean distance between two points in space.

    #[lua()]
    fn distance(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> f64;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> f64;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// [Euclidean division]: f64::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
/// See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
/// Panics
/// Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns a
/// fallback value.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be the fallback value.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        fallback: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns zero.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be zero.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or_zero(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns whether `self` is length `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::DVec3>) -> bool;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn project_onto(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` has a length of zero when `glam_assert` is enabled.

    #[lua()]
    fn reject_from(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn project_onto_normalized(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reject_from_normalized(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the nearest integer to a number for each element of `self`.
/// Round half-way cases away from 0.0.

    #[lua()]
    fn round(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the largest integer less than or equal to a number for each
/// element of `self`.

    #[lua()]
    fn floor(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the smallest integer greater than or equal to a number for
/// each element of `self`.

    #[lua()]
    fn ceil(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the integer part each element of `self`. This means numbers are
/// always truncated towards zero.

    #[lua()]
    fn trunc(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
/// Note that this differs from the GLSL implementation of `fract` which returns
/// `self - self.floor()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.floor()`.
/// Note that this differs from the Rust implementation of `fract` which returns
/// `self - self.trunc()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract_gl(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing `e^self` (the exponential function) for each element of
/// `self`.

    #[lua()]
    fn exp(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing each element of `self` raised to the power of `n`.

    #[lua()]
    fn powf(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        n: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector containing the reciprocal `1.0/n` of each element of `self`.

    #[lua()]
    fn recip(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
/// will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
/// extrapolated.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
        s: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Moves towards `rhs` based on the value `d`.
/// When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
/// `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.

    #[lua()]
    fn move_towards(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
        d: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Calculates the midpoint between `self` and `rhs`.
/// The midpoint is the average of, or halfway point between, two vectors.
/// `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
/// while being slightly cheaper to compute.

    #[lua()]
    fn midpoint(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs` is
/// less than or equal to `max_abs_diff`.
/// This can be used to compare if two vectors contain similar elements. It works best when
/// comparing with a known value. The `max_abs_diff` that should be used used depends on
/// the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Returns a vector with a length no less than `min` and no more than `max`.
/// # Panics
/// Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        min: f64,
        max: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector with a length no more than `max`.
/// # Panics
/// Will panic if `max` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_max(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        max: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns a vector with a length no less than `min`.
/// # Panics
/// Will panic if `min` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_min(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        min: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
/// error, yielding a more accurate result than an unfused multiply-add.
/// Using `mul_add` *may* be more performant than an unfused multiply-add if the target
/// architecture has a dedicated fma CPU instruction. However, this is not always true,
/// and will be heavily dependant on designing algorithms with specific target hardware in
/// mind.

    #[lua()]
    fn mul_add(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        a: LuaReflectValProxy<bevy::math::DVec3>,
        b: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the reflection vector for a given incident vector `self` and surface normal
/// `normal`.
/// `normal` must be normalized.
/// # Panics
/// Will panic if `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reflect(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        normal: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the refraction direction for a given incident vector `self`, surface normal
/// `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
/// a zero vector will be returned.
/// `self` and `normal` must be normalized.
/// # Panics
/// Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn refract(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        normal: LuaReflectValProxy<bevy::math::DVec3>,
        eta: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the angle (in radians) between two vectors in the range `[0, +π]`.
/// The inputs do not need to be unit vectors however they must be non-zero.

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> f64;

"#,
    r#"
/// Returns some vector that is orthogonal to the given one.
/// The input vector must be finite and non-zero.
/// The output vector is not necessarily unit length. For that use
/// [`Self::any_orthonormal_vector()`] instead.

    #[lua()]
    fn any_orthogonal_vector(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns any unit vector that is orthogonal to the given one.
/// The input vector must be unit length.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn any_orthonormal_vector(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec3a(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec3(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::IVec3>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec3(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::UVec3>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec3(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec3>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec3(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<f64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::DVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<f64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<f64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::DVec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::DVec3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::DVec3>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DVec3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DVec3>,
        other: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::DVec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::DVec3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectRefProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::DVec3>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<f64> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: f64) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct DVec3 {
    x: f64,
    y: f64,
    z: f64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DVec4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<&bevy::math::DVec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<&bevy::math::DVec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<bevy::math::DVec4>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<&bevy::math::DVec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<bevy::math::DVec4>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<&bevy::math::DVec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<f64>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::DVec4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DVec4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
        other: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::DVec4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<&bevy::math::DVec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DVec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a new vector.

    #[lua()]
    fn new(x: f64, y: f64, z: f64, w: f64) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a vector with all elements set to `v`.

    #[lua()]
    fn splat(v: f64) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
/// for each element of `self`.
/// A true element in the mask uses the corresponding element from `if_true`, and false
/// uses the element from `if_false`.

    #[lua()]
    fn select(
        mask: LuaReflectValProxy<bevy::math::BVec4>,
        if_true: LuaReflectValProxy<bevy::math::DVec4>,
        if_false: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a new vector from an array.

    #[lua()]
    fn from_array(a: [f64; 4]) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::DVec4>) -> [f64; 4];

"#,
    r#"
/// Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
/// Truncation to [`DVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].

    #[lua()]
    fn truncate(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `x`.

    #[lua()]
    fn with_x(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        x: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `y`.

    #[lua()]
    fn with_y(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        y: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `z`.

    #[lua()]
    fn with_z(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        z: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Creates a 4D vector from `self` with the given value of `w`.

    #[lua()]
    fn with_w(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        w: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> f64;

"#,
    r#"
/// Returns a vector where every component is the dot product of `self` and `rhs`.

    #[lua()]
    fn dot_into_vec(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the minimum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.

    #[lua()]
    fn min(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the maximum values for each element of `self` and `rhs`.
/// In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.

    #[lua()]
    fn max(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Component-wise clamping of values, similar to [`f64::clamp`].
/// Each element in `min` must be less-or-equal to the corresponding element in `max`.
/// # Panics
/// Will panic if `min` is greater than `max` when `glam_assert` is enabled.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        min: LuaReflectValProxy<bevy::math::DVec4>,
        max: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the horizontal minimum of `self`.
/// In other words this computes `min(x, y, ..)`.

    #[lua()]
    fn min_element(_self: LuaReflectValProxy<bevy::math::DVec4>) -> f64;

"#,
    r#"
/// Returns the horizontal maximum of `self`.
/// In other words this computes `max(x, y, ..)`.

    #[lua()]
    fn max_element(_self: LuaReflectValProxy<bevy::math::DVec4>) -> f64;

"#,
    r#"
/// Returns the sum of all elements of `self`.
/// In other words, this computes `self.x + self.y + ..`.

    #[lua()]
    fn element_sum(_self: LuaReflectValProxy<bevy::math::DVec4>) -> f64;

"#,
    r#"
/// Returns the product of all elements of `self`.
/// In other words, this computes `self.x * self.y * ..`.

    #[lua()]
    fn element_product(_self: LuaReflectValProxy<bevy::math::DVec4>) -> f64;

"#,
    r#"
/// Returns a vector mask containing the result of a `==` comparison for each element of
/// `self` and `rhs`.
/// In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpeq(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `!=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpne(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpge(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `>` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmpgt(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<=` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmple(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector mask containing the result of a `<` comparison for each element of
/// `self` and `rhs`.
/// In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
/// elements.

    #[lua()]
    fn cmplt(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns a vector containing the absolute value of each element of `self`.

    #[lua()]
    fn abs(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector with elements representing the sign of `self`.
/// - `1.0` if the number is positive, `+0.0` or `INFINITY`
/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
/// - `NAN` if the number is `NAN`

    #[lua()]
    fn signum(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector with signs of `rhs` and the magnitudes of `self`.

    #[lua()]
    fn copysign(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
/// A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn is_negative_bitmask(_self: LuaReflectValProxy<bevy::math::DVec4>) -> u32;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.  If any element is either
/// `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::DVec4>) -> bool;

"#,
    r#"
/// Performs `is_finite` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.

    #[lua()]
    fn is_finite_mask(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::DVec4>) -> bool;

"#,
    r#"
/// Performs `is_nan` on each element of self, returning a vector mask of the results.
/// In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.

    #[lua()]
    fn is_nan_mask(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::BVec4>;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::DVec4>) -> f64;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is faster than `length()` as it avoids a square root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::DVec4>) -> f64;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::DVec4>) -> f64;

"#,
    r#"
/// Computes the Euclidean distance between two points in space.

    #[lua()]
    fn distance(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> f64;

"#,
    r#"
/// Compute the squared euclidean distance between two points in space.

    #[lua()]
    fn distance_squared(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> f64;

"#,
    r#"
/// Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.

    #[lua()]
    fn div_euclid(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
/// [Euclidean division]: f64::rem_euclid

    #[lua()]
    fn rem_euclid(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
/// See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
/// Panics
/// Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns a
/// fallback value.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be the fallback value.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        fallback: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns `self` normalized to length 1.0 if possible, else returns zero.
/// In particular, if the input is zero (or very close to zero), or non-finite,
/// the result of this operation will be zero.
/// See also [`Self::try_normalize()`].

    #[lua()]
    fn normalize_or_zero(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns whether `self` is length `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::DVec4>) -> bool;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn project_onto(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be of non-zero length.
/// # Panics
/// Will panic if `rhs` has a length of zero when `glam_assert` is enabled.

    #[lua()]
    fn reject_from(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the vector projection of `self` onto `rhs`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn project_onto_normalized(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the vector rejection of `self` from `rhs`.
/// The vector rejection is the vector perpendicular to the projection of `self` onto
/// `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
/// `rhs` must be normalized.
/// # Panics
/// Will panic if `rhs` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reject_from_normalized(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the nearest integer to a number for each element of `self`.
/// Round half-way cases away from 0.0.

    #[lua()]
    fn round(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the largest integer less than or equal to a number for each
/// element of `self`.

    #[lua()]
    fn floor(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the smallest integer greater than or equal to a number for
/// each element of `self`.

    #[lua()]
    fn ceil(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the integer part each element of `self`. This means numbers are
/// always truncated towards zero.

    #[lua()]
    fn trunc(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
/// Note that this differs from the GLSL implementation of `fract` which returns
/// `self - self.floor()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the fractional part of the vector as `self - self.floor()`.
/// Note that this differs from the Rust implementation of `fract` which returns
/// `self - self.trunc()`.
/// Note that this is fast but not precise for large numbers.

    #[lua()]
    fn fract_gl(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing `e^self` (the exponential function) for each element of
/// `self`.

    #[lua()]
    fn exp(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing each element of `self` raised to the power of `n`.

    #[lua()]
    fn powf(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        n: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector containing the reciprocal `1.0/n` of each element of `self`.

    #[lua()]
    fn recip(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
/// will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
/// extrapolated.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
        s: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Moves towards `rhs` based on the value `d`.
/// When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
/// `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.

    #[lua()]
    fn move_towards(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
        d: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Calculates the midpoint between `self` and `rhs`.
/// The midpoint is the average of, or halfway point between, two vectors.
/// `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
/// while being slightly cheaper to compute.

    #[lua()]
    fn midpoint(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs` is
/// less than or equal to `max_abs_diff`.
/// This can be used to compare if two vectors contain similar elements. It works best when
/// comparing with a known value. The `max_abs_diff` that should be used used depends on
/// the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Returns a vector with a length no less than `min` and no more than `max`.
/// # Panics
/// Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        min: f64,
        max: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector with a length no more than `max`.
/// # Panics
/// Will panic if `max` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_max(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        max: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns a vector with a length no less than `min`.
/// # Panics
/// Will panic if `min` is negative when `glam_assert` is enabled.

    #[lua()]
    fn clamp_length_min(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        min: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
/// error, yielding a more accurate result than an unfused multiply-add.
/// Using `mul_add` *may* be more performant than an unfused multiply-add if the target
/// architecture has a dedicated fma CPU instruction. However, this is not always true,
/// and will be heavily dependant on designing algorithms with specific target hardware in
/// mind.

    #[lua()]
    fn mul_add(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        a: LuaReflectValProxy<bevy::math::DVec4>,
        b: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the reflection vector for a given incident vector `self` and surface normal
/// `normal`.
/// `normal` must be normalized.
/// # Panics
/// Will panic if `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn reflect(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        normal: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the refraction direction for a given incident vector `self`, surface normal
/// `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
/// a zero vector will be returned.
/// `self` and `normal` must be normalized.
/// # Panics
/// Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn refract(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        normal: LuaReflectValProxy<bevy::math::DVec4>,
        eta: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Casts all elements of `self` to `f32`.

    #[lua()]
    fn as_vec4(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `i32`.

    #[lua()]
    fn as_ivec4(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::IVec4>;

"#,
    r#"
/// Casts all elements of `self` to `u32`.

    #[lua()]
    fn as_uvec4(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::UVec4>;

"#,
    r#"
/// Casts all elements of `self` to `i64`.

    #[lua()]
    fn as_i64vec4(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::I64Vec4>;

"#,
    r#"
/// Casts all elements of `self` to `u64`.

    #[lua()]
    fn as_u64vec4(
        _self: LuaReflectRefProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::U64Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<f64>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Rem::<f64>", composite = "rem")]
    fn rem(
        _self: LuaReflectValProxy<bevy::math::DVec4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(self, idx: usize) -> LuaIdentityProxy<f64> {
    _self[idx - 1]
}
"#,
    r#"
#[lua(metamethod="NewIndex")]
fn index(&mut self, idx: usize, val: f64) -> () {
    _self[idx - 1] = val
}
"#]
)]
pub struct DVec4 {
    x: f64,
    y: f64,
    z: f64,
    w: f64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Mat2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a 2x2 matrix from two column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::Vec2>,
        y_axis: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Creates a `[f32; 4]` array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::Mat2>) -> [f32; 4];

"#,
    r#"
/// Creates a `[[f32; 2]; 2]` 2D array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::Mat2>) -> [[f32; 2]; 2];

"#,
    r#"
/// Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.

    #[lua()]
    fn from_diagonal(
        diagonal: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
/// `angle` (in radians).

    #[lua()]
    fn from_scale_angle(
        scale: LuaReflectValProxy<bevy::math::Vec2>,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Creates a 2x2 matrix containing a rotation of `angle` (in radians).

    #[lua()]
    fn from_angle(angle: f32) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.

    #[lua()]
    fn from_mat3(
        m: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column
/// and `j`th row.
/// # Panics
/// Panics if `i` or `j` is greater than 2.

    #[lua()]
    fn from_mat3_minor(
        m: LuaReflectValProxy<bevy::math::Mat3>,
        i: usize,
        j: usize,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.

    #[lua()]
    fn from_mat3a(
        m: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column
/// and `j`th row.
/// # Panics
/// Panics if `i` or `j` is greater than 2.

    #[lua()]
    fn from_mat3a_minor(
        m: LuaReflectValProxy<bevy::math::Mat3A>,
        i: usize,
        j: usize,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Returns the matrix column for the given `index`.
/// # Panics
/// Panics if `index` is greater than 1.

    #[lua()]
    fn col(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns the matrix row for the given `index`.
/// # Panics
/// Panics if `index` is greater than 1.

    #[lua()]
    fn row(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::Mat2>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::Mat2>) -> bool;

"#,
    r#"
/// Returns the transpose of `self`.

    #[lua()]
    fn transpose(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Returns the determinant of `self`.

    #[lua()]
    fn determinant(_self: LuaReflectRefProxy<bevy::math::Mat2>) -> f32;

"#,
    r#"
/// Returns the inverse of `self`.
/// If the matrix is not invertible the returned matrix will be invalid.
/// # Panics
/// Will panic if the determinant of `self` is zero when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Transforms a 2D vector.

    #[lua()]
    fn mul_vec2(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Multiplies two 2x2 matrices.

    #[lua()]
    fn mul_mat2(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Adds two 2x2 matrices.

    #[lua()]
    fn add_mat2(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Subtracts two 2x2 matrices.

    #[lua()]
    fn sub_mat2(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Multiplies a 2x2 matrix by a scalar.

    #[lua()]
    fn mul_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Divides a 2x2 matrix by a scalar.

    #[lua()]
    fn div_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two matrices contain similar elements. It works best
/// when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: LuaReflectValProxy<bevy::math::Mat2>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Takes the absolute value of each element in `self`

    #[lua()]
    fn abs(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua()]
    fn as_dmat2(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Mat2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Mat2>,
        rhs: LuaReflectValProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Mat2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Mat2>,
        rhs: LuaReflectValProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Mat2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Mat2>,
        rhs: LuaReflectRefProxy<bevy::math::Mat2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Mat2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat2>,
        rhs: LuaReflectValProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Mat2>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<LuaVec2> {
    let mut curr_ref = _self.0.clone();
    let def_ref = bevy_mod_scripting_core::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::Mat2>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push(bevy_mod_scripting_core::bindings::ReflectionPathElem::new_deferred(def_ref));
    LuaVec2(curr_ref)
}
"#]
)]
pub struct Mat2();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Mat3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Mat3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Affine2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Affine2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Mat3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Mat3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Creates a 3x3 matrix from three column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::Vec3>,
        y_axis: LuaReflectValProxy<bevy::math::Vec3>,
        z_axis: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a `[f32; 9]` array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::Mat3>) -> [f32; 9];

"#,
    r#"
/// Creates a `[[f32; 3]; 3]` 3D array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::Mat3>) -> [[f32; 3]; 3];

"#,
    r#"
/// Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.

    #[lua()]
    fn from_diagonal(
        diagonal: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.

    #[lua()]
    fn from_mat4(
        m: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column
/// and `j`th row.
/// # Panics
/// Panics if `i` or `j` is greater than 3.

    #[lua()]
    fn from_mat4_minor(
        m: LuaReflectValProxy<bevy::math::Mat4>,
        i: usize,
        j: usize,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from the given quaternion.
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_quat(
        rotation: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
/// radians).
/// # Panics
/// Will panic if `axis` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::Vec3>,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
/// radians).

    #[lua()]
    fn from_euler(
        order: LuaReflectValProxy<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Extract Euler angles with the given Euler rotation order.
/// Note if the input matrix contains scales, shears, or other non-rotation transformations then
/// the resulting Euler angles will be ill-defined.
/// # Panics
/// Will panic if any input matrix column is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn to_euler(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        order: LuaReflectValProxy<bevy::math::EulerRot>,
    ) -> (f32, f32, f32);

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the x axis.

    #[lua()]
    fn from_rotation_x(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the y axis.

    #[lua()]
    fn from_rotation_y(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the z axis.

    #[lua()]
    fn from_rotation_z(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D `translation`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D rotation `angle` (in
/// radians).
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_angle(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
/// radians) and `translation`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_scale_angle_translation(
        scale: LuaReflectValProxy<bevy::math::Vec2>,
        angle: f32,
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given non-uniform 2D `scale`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].
/// # Panics
/// Will panic if all elements of `scale` are zero when `glam_assert` is enabled.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2x2 matrix.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_mat2(
        m: LuaReflectValProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Returns the matrix column for the given `index`.
/// # Panics
/// Panics if `index` is greater than 2.

    #[lua()]
    fn col(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns the matrix row for the given `index`.
/// # Panics
/// Panics if `index` is greater than 2.

    #[lua()]
    fn row(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::Mat3>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::Mat3>) -> bool;

"#,
    r#"
/// Returns the transpose of `self`.

    #[lua()]
    fn transpose(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Returns the determinant of `self`.

    #[lua()]
    fn determinant(_self: LuaReflectRefProxy<bevy::math::Mat3>) -> f32;

"#,
    r#"
/// Returns the inverse of `self`.
/// If the matrix is not invertible the returned matrix will be invalid.
/// # Panics
/// Will panic if the determinant of `self` is zero when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Transforms the given 2D vector as a point.
/// This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_point2(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Rotates the given 2D vector.
/// This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_vector2(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Transforms a 3D vector.

    #[lua()]
    fn mul_vec3(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Transforms a [`Vec3A`].

    #[lua()]
    fn mul_vec3a(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Multiplies two 3x3 matrices.

    #[lua()]
    fn mul_mat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Adds two 3x3 matrices.

    #[lua()]
    fn add_mat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Subtracts two 3x3 matrices.

    #[lua()]
    fn sub_mat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Multiplies a 3x3 matrix by a scalar.

    #[lua()]
    fn mul_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Divides a 3x3 matrix by a scalar.

    #[lua()]
    fn div_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two matrices contain similar elements. It works best
/// when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Mat3>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Takes the absolute value of each element in `self`

    #[lua()]
    fn abs(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua()]
    fn as_dmat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Mat3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
        rhs: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<LuaVec3> {
    let mut curr_ref = _self.0.clone();
    let def_ref = bevy_mod_scripting_core::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::Mat3>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push(bevy_mod_scripting_core::bindings::ReflectionPathElem::new_deferred(def_ref));
    LuaVec3(curr_ref)
}
"#]
)]
pub struct Mat3 {
    x_axis: bevy::math::Vec3,
    y_axis: bevy::math::Vec3,
    z_axis: bevy::math::Vec3,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Mat3A",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Mat3A>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Mat3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Affine2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Affine2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Mat3A>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> bool;

"#,
    r#"
/// Creates a 3x3 matrix from three column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::Vec3A>,
        y_axis: LuaReflectValProxy<bevy::math::Vec3A>,
        z_axis: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a `[f32; 9]` array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::Mat3A>) -> [f32; 9];

"#,
    r#"
/// Creates a `[[f32; 3]; 3]` 3D array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::Mat3A>) -> [[f32; 3]; 3];

"#,
    r#"
/// Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.

    #[lua()]
    fn from_diagonal(
        diagonal: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.

    #[lua()]
    fn from_mat4(
        m: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column
/// and `j`th row.
/// # Panics
/// Panics if `i` or `j` is greater than 3.

    #[lua()]
    fn from_mat4_minor(
        m: LuaReflectValProxy<bevy::math::Mat4>,
        i: usize,
        j: usize,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a 3D rotation matrix from the given quaternion.
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_quat(
        rotation: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
/// radians).
/// # Panics
/// Will panic if `axis` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::Vec3>,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
/// radians).

    #[lua()]
    fn from_euler(
        order: LuaReflectValProxy<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Extract Euler angles with the given Euler rotation order.
/// Note if the input matrix contains scales, shears, or other non-rotation transformations then
/// the resulting Euler angles will be ill-defined.
/// # Panics
/// Will panic if any input matrix column is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn to_euler(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        order: LuaReflectValProxy<bevy::math::EulerRot>,
    ) -> (f32, f32, f32);

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the x axis.

    #[lua()]
    fn from_rotation_x(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the y axis.

    #[lua()]
    fn from_rotation_y(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the z axis.

    #[lua()]
    fn from_rotation_z(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D `translation`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D rotation `angle` (in
/// radians).
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_angle(angle: f32) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
/// radians) and `translation`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_scale_angle_translation(
        scale: LuaReflectValProxy<bevy::math::Vec2>,
        angle: f32,
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates an affine transformation matrix from the given non-uniform 2D `scale`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].
/// # Panics
/// Will panic if all elements of `scale` are zero when `glam_assert` is enabled.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2x2 matrix.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_mat2(
        m: LuaReflectValProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Returns the matrix column for the given `index`.
/// # Panics
/// Panics if `index` is greater than 2.

    #[lua()]
    fn col(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns the matrix row for the given `index`.
/// # Panics
/// Panics if `index` is greater than 2.

    #[lua()]
    fn row(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::Mat3A>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::Mat3A>) -> bool;

"#,
    r#"
/// Returns the transpose of `self`.

    #[lua()]
    fn transpose(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Returns the determinant of `self`.

    #[lua()]
    fn determinant(_self: LuaReflectRefProxy<bevy::math::Mat3A>) -> f32;

"#,
    r#"
/// Returns the inverse of `self`.
/// If the matrix is not invertible the returned matrix will be invalid.
/// # Panics
/// Will panic if the determinant of `self` is zero when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Transforms the given 2D vector as a point.
/// This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_point2(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Rotates the given 2D vector.
/// This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_vector2(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Transforms a 3D vector.

    #[lua()]
    fn mul_vec3(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Transforms a [`Vec3A`].

    #[lua()]
    fn mul_vec3a(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Multiplies two 3x3 matrices.

    #[lua()]
    fn mul_mat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Adds two 3x3 matrices.

    #[lua()]
    fn add_mat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Subtracts two 3x3 matrices.

    #[lua()]
    fn sub_mat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Multiplies a 3x3 matrix by a scalar.

    #[lua()]
    fn mul_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Divides a 3x3 matrix by a scalar.

    #[lua()]
    fn div_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two matrices contain similar elements. It works best
/// when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Mat3A>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Takes the absolute value of each element in `self`

    #[lua()]
    fn abs(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua()]
    fn as_dmat3(
        _self: LuaReflectRefProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Mat3A>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat3A>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<LuaVec3A> {
    let mut curr_ref = _self.0.clone();
    let def_ref = bevy_mod_scripting_core::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::Mat3A>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push(bevy_mod_scripting_core::bindings::ReflectionPathElem::new_deferred(def_ref));
    LuaVec3A(curr_ref)
}
"#]
)]
pub struct Mat3A {
    x_axis: bevy::math::Vec3A,
    y_axis: bevy::math::Vec3A,
    z_axis: bevy::math::Vec3A,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Mat4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Mul::<f32>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a 4x4 matrix from four column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::Vec4>,
        y_axis: LuaReflectValProxy<bevy::math::Vec4>,
        z_axis: LuaReflectValProxy<bevy::math::Vec4>,
        w_axis: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a `[f32; 16]` array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::Mat4>) -> [f32; 16];

"#,
    r#"
/// Creates a `[[f32; 4]; 4]` 4D array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::Mat4>) -> [[f32; 4]; 4];

"#,
    r#"
/// Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.

    #[lua()]
    fn from_diagonal(
        diagonal: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
/// `translation`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_scale_rotation_translation(
        scale: LuaReflectValProxy<bevy::math::Vec3>,
        rotation: LuaReflectValProxy<bevy::math::Quat>,
        translation: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3D `translation`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_translation(
        rotation: LuaReflectValProxy<bevy::math::Quat>,
        translation: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given `rotation` quaternion.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_quat(
        rotation: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3x3 linear transformation
/// matrix.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_mat3(
        m: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3x3 linear transformation
/// matrix.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_mat3a(
        m: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3D `translation`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around a normalized
/// rotation `axis` of `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `axis` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::Vec3>,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a affine transformation matrix containing a rotation from the given euler
/// rotation sequence and angles (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_euler(
        order: LuaReflectValProxy<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Extract Euler angles with the given Euler rotation order.
/// Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
/// then the resulting Euler angles will be ill-defined.
/// # Panics
/// Will panic if any column of the upper 3x3 rotation matrix is not normalized when
/// `glam_assert` is enabled.

    #[lua()]
    fn to_euler(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        order: LuaReflectValProxy<bevy::math::EulerRot>,
    ) -> (f32, f32, f32);

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around the x axis of
/// `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_rotation_x(angle: f32) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around the y axis of
/// `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_rotation_y(angle: f32) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around the z axis of
/// `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_rotation_z(angle: f32) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if all elements of `scale` are zero when `glam_assert` is enabled.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Returns the matrix column for the given `index`.
/// # Panics
/// Panics if `index` is greater than 3.

    #[lua()]
    fn col(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns the matrix row for the given `index`.
/// # Panics
/// Panics if `index` is greater than 3.

    #[lua()]
    fn row(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::Mat4>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::Mat4>) -> bool;

"#,
    r#"
/// Returns the transpose of `self`.

    #[lua()]
    fn transpose(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Returns the determinant of `self`.

    #[lua()]
    fn determinant(_self: LuaReflectRefProxy<bevy::math::Mat4>) -> f32;

"#,
    r#"
/// Returns the inverse of `self`.
/// If the matrix is not invertible the returned matrix will be invalid.
/// # Panics
/// Will panic if the determinant of `self` is zero when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a left-handed view matrix using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.

    #[lua()]
    fn look_to_lh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        dir: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a right-handed view matrix using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.

    #[lua()]
    fn look_to_rh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        dir: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a left-handed view matrix using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_lh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        center: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a right-handed view matrix using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_rh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        center: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a right-handed perspective projection matrix with `[-1,1]` depth range.
/// Useful to map the standard right-handed coordinate system into what OpenGL expects.
/// This is the same as the OpenGL `gluPerspective` function.
/// See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>

    #[lua()]
    fn perspective_rh_gl(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
        z_far: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a left-handed perspective projection matrix with `[0,1]` depth range.
/// Useful to map the standard left-handed coordinate system into what WebGPU/Metal/Direct3D expect.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_lh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
        z_far: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a right-handed perspective projection matrix with `[0,1]` depth range.
/// Useful to map the standard right-handed coordinate system into what WebGPU/Metal/Direct3D expect.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_rh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
        z_far: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
/// Like `perspective_lh`, but with an infinite value for `z_far`.
/// The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_infinite_lh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an infinite reverse left-handed perspective projection matrix with `[0,1]` depth range.
/// Similar to `perspective_infinite_lh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
/// # Panics
/// Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.

    #[lua()]
    fn perspective_infinite_reverse_lh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an infinite right-handed perspective projection matrix with `[0,1]` depth range.
/// Like `perspective_rh`, but with an infinite value for `z_far`.
/// The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_infinite_rh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates an infinite reverse right-handed perspective projection matrix with `[0,1]` depth range.
/// Similar to `perspective_infinite_rh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
/// # Panics
/// Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.

    #[lua()]
    fn perspective_infinite_reverse_rh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a right-handed orthographic projection matrix with `[-1,1]` depth
/// range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
/// See
/// <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
/// Useful to map a right-handed coordinate system to the normalized device coordinates that OpenGL expects.

    #[lua()]
    fn orthographic_rh_gl(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
/// Useful to map a left-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.

    #[lua()]
    fn orthographic_lh(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
/// Useful to map a right-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.

    #[lua()]
    fn orthographic_rh(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Transforms the given 3D vector as a point, applying perspective correction.
/// This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
/// The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
/// This method assumes that `self` contains a projective transform.

    #[lua()]
    fn project_point3(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Transforms the given 3D vector as a point.
/// This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
/// `1.0`.
/// This method assumes that `self` contains a valid affine transform. It does not perform
/// a perspective divide, if `self` contains a perspective transform, or if you are unsure,
/// the [`Self::project_point3()`] method should be used instead.
/// # Panics
/// Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_point3(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Transforms the give 3D vector as a direction.
/// This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
/// `0.0`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_vector3(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Transforms the given [`Vec3A`] as a 3D point, applying perspective correction.
/// This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `1.0`.
/// The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
/// This method assumes that `self` contains a projective transform.

    #[lua()]
    fn project_point3a(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Transforms the given [`Vec3A`] as 3D point.
/// This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `1.0`.

    #[lua()]
    fn transform_point3a(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Transforms the give [`Vec3A`] as 3D vector.
/// This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `0.0`.

    #[lua()]
    fn transform_vector3a(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Transforms a 4D vector.

    #[lua()]
    fn mul_vec4(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"
/// Multiplies two 4x4 matrices.

    #[lua()]
    fn mul_mat4(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Adds two 4x4 matrices.

    #[lua()]
    fn add_mat4(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Subtracts two 4x4 matrices.

    #[lua()]
    fn sub_mat4(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Multiplies a 4x4 matrix by a scalar.

    #[lua()]
    fn mul_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Divides a 4x4 matrix by a scalar.

    #[lua()]
    fn div_scalar(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two matrices contain similar elements. It works best
/// when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Mat4>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Takes the absolute value of each element in `self`

    #[lua()]
    fn abs(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua()]
    fn as_dmat4(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::Mat4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Mat4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Vec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Vec4>,
    ) -> LuaReflectValProxy<bevy::math::Vec4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Mat4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
        rhs: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Affine3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Affine3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f32>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
        rhs: f32,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::Mat4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::Mat4>,
        rhs: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<LuaVec4> {
    let mut curr_ref = _self.0.clone();
    let def_ref = bevy_mod_scripting_core::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::Mat4>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push(bevy_mod_scripting_core::bindings::ReflectionPathElem::new_deferred(def_ref));
    LuaVec4(curr_ref)
}
"#]
)]
pub struct Mat4 {
    x_axis: bevy::math::Vec4,
    y_axis: bevy::math::Vec4,
    z_axis: bevy::math::Vec4,
    w_axis: bevy::math::Vec4,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DMat2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<f64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DMat2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DMat2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat2>,
        rhs: LuaReflectValProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::DMat2>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DMat2>,
        rhs: LuaReflectValProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DVec2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Creates a 2x2 matrix from two column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::DVec2>,
        y_axis: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Creates a `[f64; 4]` array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::DMat2>) -> [f64; 4];

"#,
    r#"
/// Creates a `[[f64; 2]; 2]` 2D array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::DMat2>) -> [[f64; 2]; 2];

"#,
    r#"
/// Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.

    #[lua()]
    fn from_diagonal(
        diagonal: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
/// `angle` (in radians).

    #[lua()]
    fn from_scale_angle(
        scale: LuaReflectValProxy<bevy::math::DVec2>,
        angle: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Creates a 2x2 matrix containing a rotation of `angle` (in radians).

    #[lua()]
    fn from_angle(angle: f64) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.

    #[lua()]
    fn from_mat3(
        m: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column
/// and `j`th row.
/// # Panics
/// Panics if `i` or `j` is greater than 2.

    #[lua()]
    fn from_mat3_minor(
        m: LuaReflectValProxy<bevy::math::DMat3>,
        i: usize,
        j: usize,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Returns the matrix column for the given `index`.
/// # Panics
/// Panics if `index` is greater than 1.

    #[lua()]
    fn col(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns the matrix row for the given `index`.
/// # Panics
/// Panics if `index` is greater than 1.

    #[lua()]
    fn row(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::DMat2>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::DMat2>) -> bool;

"#,
    r#"
/// Returns the transpose of `self`.

    #[lua()]
    fn transpose(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Returns the determinant of `self`.

    #[lua()]
    fn determinant(_self: LuaReflectRefProxy<bevy::math::DMat2>) -> f64;

"#,
    r#"
/// Returns the inverse of `self`.
/// If the matrix is not invertible the returned matrix will be invalid.
/// # Panics
/// Will panic if the determinant of `self` is zero when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Transforms a 2D vector.

    #[lua()]
    fn mul_vec2(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Multiplies two 2x2 matrices.

    #[lua()]
    fn mul_mat2(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Adds two 2x2 matrices.

    #[lua()]
    fn add_mat2(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Subtracts two 2x2 matrices.

    #[lua()]
    fn sub_mat2(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Multiplies a 2x2 matrix by a scalar.

    #[lua()]
    fn mul_scalar(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Divides a 2x2 matrix by a scalar.

    #[lua()]
    fn div_scalar(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two matrices contain similar elements. It works best
/// when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: LuaReflectValProxy<bevy::math::DMat2>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Takes the absolute value of each element in `self`

    #[lua()]
    fn abs(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua()]
    fn as_mat2(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::Mat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DMat2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
        rhs: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat2>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::DMat2>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DMat2>,
        rhs: LuaReflectValProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<LuaDVec2> {
    let mut curr_ref = _self.0.clone();
    let def_ref = bevy_mod_scripting_core::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::DMat2>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push(bevy_mod_scripting_core::bindings::ReflectionPathElem::new_deferred(def_ref));
    LuaDVec2(curr_ref)
}
"#]
)]
pub struct DMat2 {
    x_axis: bevy::math::DVec2,
    y_axis: bevy::math::DVec2,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DMat3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Div::<f64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DAffine2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DAffine2>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::DMat3>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DMat3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3x3 matrix from three column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::DVec3>,
        y_axis: LuaReflectValProxy<bevy::math::DVec3>,
        z_axis: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a `[f64; 9]` array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::DMat3>) -> [f64; 9];

"#,
    r#"
/// Creates a `[[f64; 3]; 3]` 3D array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::DMat3>) -> [[f64; 3]; 3];

"#,
    r#"
/// Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.

    #[lua()]
    fn from_diagonal(
        diagonal: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.

    #[lua()]
    fn from_mat4(
        m: LuaReflectValProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column
/// and `j`th row.
/// # Panics
/// Panics if `i` or `j` is greater than 3.

    #[lua()]
    fn from_mat4_minor(
        m: LuaReflectValProxy<bevy::math::DMat4>,
        i: usize,
        j: usize,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from the given quaternion.
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_quat(
        rotation: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
/// radians).
/// # Panics
/// Will panic if `axis` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::DVec3>,
        angle: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
/// radians).

    #[lua()]
    fn from_euler(
        order: LuaReflectValProxy<bevy::math::EulerRot>,
        a: f64,
        b: f64,
        c: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Extract Euler angles with the given Euler rotation order.
/// Note if the input matrix contains scales, shears, or other non-rotation transformations then
/// the resulting Euler angles will be ill-defined.
/// # Panics
/// Will panic if any input matrix column is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn to_euler(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        order: LuaReflectValProxy<bevy::math::EulerRot>,
    ) -> (f64, f64, f64);

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the x axis.

    #[lua()]
    fn from_rotation_x(angle: f64) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the y axis.

    #[lua()]
    fn from_rotation_y(angle: f64) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates a 3D rotation matrix from `angle` (in radians) around the z axis.

    #[lua()]
    fn from_rotation_z(angle: f64) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D `translation`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D rotation `angle` (in
/// radians).
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_angle(angle: f64) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
/// radians) and `translation`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_scale_angle_translation(
        scale: LuaReflectValProxy<bevy::math::DVec2>,
        angle: f64,
        translation: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given non-uniform 2D `scale`.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].
/// # Panics
/// Will panic if all elements of `scale` are zero when `glam_assert` is enabled.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 2x2 matrix.
/// The resulting matrix can be used to transform 2D points and vectors. See
/// [`Self::transform_point2()`] and [`Self::transform_vector2()`].

    #[lua()]
    fn from_mat2(
        m: LuaReflectValProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Returns the matrix column for the given `index`.
/// # Panics
/// Panics if `index` is greater than 2.

    #[lua()]
    fn col(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the matrix row for the given `index`.
/// # Panics
/// Panics if `index` is greater than 2.

    #[lua()]
    fn row(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::DMat3>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::DMat3>) -> bool;

"#,
    r#"
/// Returns the transpose of `self`.

    #[lua()]
    fn transpose(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Returns the determinant of `self`.

    #[lua()]
    fn determinant(_self: LuaReflectRefProxy<bevy::math::DMat3>) -> f64;

"#,
    r#"
/// Returns the inverse of `self`.
/// If the matrix is not invertible the returned matrix will be invalid.
/// # Panics
/// Will panic if the determinant of `self` is zero when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Transforms the given 2D vector as a point.
/// This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_point2(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Rotates the given 2D vector.
/// This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_vector2(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Transforms a 3D vector.

    #[lua()]
    fn mul_vec3(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Multiplies two 3x3 matrices.

    #[lua()]
    fn mul_mat3(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Adds two 3x3 matrices.

    #[lua()]
    fn add_mat3(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Subtracts two 3x3 matrices.

    #[lua()]
    fn sub_mat3(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Multiplies a 3x3 matrix by a scalar.

    #[lua()]
    fn mul_scalar(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Divides a 3x3 matrix by a scalar.

    #[lua()]
    fn div_scalar(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two matrices contain similar elements. It works best
/// when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DMat3>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Takes the absolute value of each element in `self`

    #[lua()]
    fn abs(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua()]
    fn as_mat3(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::DMat3>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
        rhs: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat3>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DMat3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DMat3>,
        rhs: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<LuaDVec3> {
    let mut curr_ref = _self.0.clone();
    let def_ref = bevy_mod_scripting_core::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::DMat3>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push(bevy_mod_scripting_core::bindings::ReflectionPathElem::new_deferred(def_ref));
    LuaDVec3(curr_ref)
}
"#]
)]
pub struct DMat3 {
    x_axis: bevy::math::DVec3,
    y_axis: bevy::math::DVec3,
    z_axis: bevy::math::DVec3,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DMat4",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DVec4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a 4x4 matrix from four column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::DVec4>,
        y_axis: LuaReflectValProxy<bevy::math::DVec4>,
        z_axis: LuaReflectValProxy<bevy::math::DVec4>,
        w_axis: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a `[f64; 16]` array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::DMat4>) -> [f64; 16];

"#,
    r#"
/// Creates a `[[f64; 4]; 4]` 4D array storing data in column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::DMat4>) -> [[f64; 4]; 4];

"#,
    r#"
/// Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.

    #[lua()]
    fn from_diagonal(
        diagonal: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
/// `translation`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_scale_rotation_translation(
        scale: LuaReflectValProxy<bevy::math::DVec3>,
        rotation: LuaReflectValProxy<bevy::math::DQuat>,
        translation: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3D `translation`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_translation(
        rotation: LuaReflectValProxy<bevy::math::DQuat>,
        translation: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given `rotation` quaternion.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `rotation` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_quat(
        rotation: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3x3 linear transformation
/// matrix.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_mat3(
        m: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix from the given 3D `translation`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around a normalized
/// rotation `axis` of `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if `axis` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::DVec3>,
        angle: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a affine transformation matrix containing a rotation from the given euler
/// rotation sequence and angles (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_euler(
        order: LuaReflectValProxy<bevy::math::EulerRot>,
        a: f64,
        b: f64,
        c: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Extract Euler angles with the given Euler rotation order.
/// Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
/// then the resulting Euler angles will be ill-defined.
/// # Panics
/// Will panic if any column of the upper 3x3 rotation matrix is not normalized when
/// `glam_assert` is enabled.

    #[lua()]
    fn to_euler(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        order: LuaReflectValProxy<bevy::math::EulerRot>,
    ) -> (f64, f64, f64);

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around the x axis of
/// `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_rotation_x(angle: f64) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around the y axis of
/// `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_rotation_y(angle: f64) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing a 3D rotation around the z axis of
/// `angle` (in radians).
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].

    #[lua()]
    fn from_rotation_z(angle: f64) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
/// The resulting matrix can be used to transform 3D points and vectors. See
/// [`Self::transform_point3()`] and [`Self::transform_vector3()`].
/// # Panics
/// Will panic if all elements of `scale` are zero when `glam_assert` is enabled.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Returns the matrix column for the given `index`.
/// # Panics
/// Panics if `index` is greater than 3.

    #[lua()]
    fn col(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns the matrix row for the given `index`.
/// # Panics
/// Panics if `index` is greater than 3.

    #[lua()]
    fn row(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        index: usize,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::DMat4>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::DMat4>) -> bool;

"#,
    r#"
/// Returns the transpose of `self`.

    #[lua()]
    fn transpose(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Returns the determinant of `self`.

    #[lua()]
    fn determinant(_self: LuaReflectRefProxy<bevy::math::DMat4>) -> f64;

"#,
    r#"
/// Returns the inverse of `self`.
/// If the matrix is not invertible the returned matrix will be invalid.
/// # Panics
/// Will panic if the determinant of `self` is zero when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a left-handed view matrix using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.

    #[lua()]
    fn look_to_lh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        dir: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a right-handed view matrix using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.

    #[lua()]
    fn look_to_rh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        dir: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a left-handed view matrix using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_lh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        center: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a right-handed view matrix using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_rh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        center: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a right-handed perspective projection matrix with `[-1,1]` depth range.
/// Useful to map the standard right-handed coordinate system into what OpenGL expects.
/// This is the same as the OpenGL `gluPerspective` function.
/// See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>

    #[lua()]
    fn perspective_rh_gl(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
        z_far: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a left-handed perspective projection matrix with `[0,1]` depth range.
/// Useful to map the standard left-handed coordinate system into what WebGPU/Metal/Direct3D expect.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_lh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
        z_far: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a right-handed perspective projection matrix with `[0,1]` depth range.
/// Useful to map the standard right-handed coordinate system into what WebGPU/Metal/Direct3D expect.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_rh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
        z_far: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
/// Like `perspective_lh`, but with an infinite value for `z_far`.
/// The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_infinite_lh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an infinite reverse left-handed perspective projection matrix with `[0,1]` depth range.
/// Similar to `perspective_infinite_lh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
/// # Panics
/// Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.

    #[lua()]
    fn perspective_infinite_reverse_lh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an infinite right-handed perspective projection matrix with `[0,1]` depth range.
/// Like `perspective_rh`, but with an infinite value for `z_far`.
/// The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
/// # Panics
/// Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
/// enabled.

    #[lua()]
    fn perspective_infinite_rh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates an infinite reverse right-handed perspective projection matrix with `[0,1]` depth range.
/// Similar to `perspective_infinite_rh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
/// # Panics
/// Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.

    #[lua()]
    fn perspective_infinite_reverse_rh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a right-handed orthographic projection matrix with `[-1,1]` depth
/// range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
/// See
/// <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
/// Useful to map a right-handed coordinate system to the normalized device coordinates that OpenGL expects.

    #[lua()]
    fn orthographic_rh_gl(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
/// Useful to map a left-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.

    #[lua()]
    fn orthographic_lh(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
/// Useful to map a right-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.

    #[lua()]
    fn orthographic_rh(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Transforms the given 3D vector as a point, applying perspective correction.
/// This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
/// The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
/// This method assumes that `self` contains a projective transform.

    #[lua()]
    fn project_point3(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Transforms the given 3D vector as a point.
/// This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
/// `1.0`.
/// This method assumes that `self` contains a valid affine transform. It does not perform
/// a perspective divide, if `self` contains a perspective transform, or if you are unsure,
/// the [`Self::project_point3()`] method should be used instead.
/// # Panics
/// Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_point3(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Transforms the give 3D vector as a direction.
/// This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
/// `0.0`.
/// This method assumes that `self` contains a valid affine transform.
/// # Panics
/// Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.

    #[lua()]
    fn transform_vector3(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Transforms a 4D vector.

    #[lua()]
    fn mul_vec4(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DVec4>;

"#,
    r#"
/// Multiplies two 4x4 matrices.

    #[lua()]
    fn mul_mat4(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Adds two 4x4 matrices.

    #[lua()]
    fn add_mat4(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Subtracts two 4x4 matrices.

    #[lua()]
    fn sub_mat4(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Multiplies a 4x4 matrix by a scalar.

    #[lua()]
    fn mul_scalar(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Divides a 4x4 matrix by a scalar.

    #[lua()]
    fn div_scalar(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two matrices contain similar elements. It works best
/// when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DMat4>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Takes the absolute value of each element in `self`

    #[lua()]
    fn abs(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua()]
    fn as_mat4(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DMat4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Sub::<bevy::math::DMat4>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DAffine3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DAffine3>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DMat4>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
        rhs: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Add::<bevy::math::DMat4>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
        rhs: LuaReflectValProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Div::<f64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<f64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DMat4>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#,
    r#"
#[lua(metamethod="Index")]
fn index(_self: LuaIdentityProxy<Self>, idx: usize) -> LuaIdentityProxy<LuaDVec4> {
    let mut curr_ref = _self.0.clone();
    let def_ref = bevy_mod_scripting_core::bindings::DeferredReflection{
        get: std::sync::Arc::new(|ref_| Err(bevy::reflect::ReflectPathError::InvalidDowncast)),
        get_mut: std::sync::Arc::new(move |ref_| {
            if let Some(ret) = ref_.try_as_reflect_mut().map(|ret| ret.downcast_mut::<bevy::math::DMat4>()).flatten(){
                Ok(ret.col_mut(idx - 1))
            } else {
                Err(bevy::reflect::ReflectPathError::InvalidDowncast)
            }	
        })
    };
    curr_ref.reflect_path.push(bevy_mod_scripting_core::bindings::ReflectionPathElem::new_deferred(def_ref));
    LuaDVec4(curr_ref)
}
"#]
)]
pub struct DMat4 {
    x_axis: bevy::math::DVec4,
    y_axis: bevy::math::DVec4,
    z_axis: bevy::math::DVec4,
    w_axis: bevy::math::DVec4,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Affine2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Affine2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Affine2>,
        rhs: LuaReflectValProxy<bevy::math::Affine2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Mat3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Affine2>,
        rhs: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Mat3A>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Affine2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Affine2>,
        rhs: LuaReflectRefProxy<bevy::math::Affine2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Mat3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Affine2>,
        rhs: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Mat3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Affine2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates an affine transform from three column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::Vec2>,
        y_axis: LuaReflectValProxy<bevy::math::Vec2>,
        z_axis: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates a `[f32; 6]` array storing data in column major order.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::Affine2>) -> [f32; 6];

"#,
    r#"
/// Creates a `[[f32; 2]; 3]` 2D array storing data in
/// column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(_self: LuaReflectRefProxy<bevy::math::Affine2>) -> [[f32; 2]; 3];

"#,
    r#"
/// Creates an affine transform that changes scale.
/// Note that if any scale is zero the transform will be non-invertible.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates an affine transform from the given rotation `angle`.

    #[lua()]
    fn from_angle(angle: f32) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates an affine transformation from the given 2D `translation`.

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)

    #[lua()]
    fn from_mat2(
        matrix2: LuaReflectValProxy<bevy::math::Mat2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
/// translation vector.
/// Equivalent to
/// `Affine2::from_translation(translation) * Affine2::from_mat2(mat2)`

    #[lua()]
    fn from_mat2_translation(
        matrix2: LuaReflectValProxy<bevy::math::Mat2>,
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
/// `translation`.
/// Equivalent to `Affine2::from_translation(translation) *
/// Affine2::from_angle(angle) * Affine2::from_scale(scale)`

    #[lua()]
    fn from_scale_angle_translation(
        scale: LuaReflectValProxy<bevy::math::Vec2>,
        angle: f32,
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Creates an affine transform from the given 2D rotation `angle` (in radians) and
/// `translation`.
/// Equivalent to `Affine2::from_translation(translation) * Affine2::from_angle(angle)`

    #[lua()]
    fn from_angle_translation(
        angle: f32,
        translation: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// The given `Mat3` must be an affine transform,

    #[lua()]
    fn from_mat3(
        m: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// The given [`Mat3A`] must be an affine transform,

    #[lua()]
    fn from_mat3a(
        m: LuaReflectValProxy<bevy::math::Mat3A>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
/// Transforms the given 2D point, applying shear, scale, rotation and translation.

    #[lua()]
    fn transform_point2(
        _self: LuaReflectRefProxy<bevy::math::Affine2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Transforms the given 2D vector, applying shear, scale and rotation (but NOT
/// translation).
/// To also apply translation, use [`Self::transform_point2()`] instead.

    #[lua()]
    fn transform_vector2(
        _self: LuaReflectRefProxy<bevy::math::Affine2>,
        rhs: LuaReflectValProxy<bevy::math::Vec2>,
    ) -> LuaReflectValProxy<bevy::math::Vec2>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return
/// `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::Affine2>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::Affine2>) -> bool;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two 3x4 matrices contain similar elements. It works
/// best when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::Affine2>,
        rhs: LuaReflectValProxy<bevy::math::Affine2>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Return the inverse of this transform.
/// Note that if the transform is not invertible the result will be invalid.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Affine2>,
    ) -> LuaReflectValProxy<bevy::math::Affine2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Affine2 {
    matrix2: bevy::math::Mat2,
    translation: bevy::math::Vec2,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Affine3A",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates an affine transform from three column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::Vec3A>,
        y_axis: LuaReflectValProxy<bevy::math::Vec3A>,
        z_axis: LuaReflectValProxy<bevy::math::Vec3A>,
        w_axis: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates a `[f32; 12]` array storing data in column major order.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::Affine3A>) -> [f32; 12];

"#,
    r#"
/// Creates a `[[f32; 3]; 4]` 3D array storing data in
/// column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
    ) -> [[f32; 3]; 4];

"#,
    r#"
/// Creates an affine transform that changes scale.
/// Note that if any scale is zero the transform will be non-invertible.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform from the given `rotation` quaternion.

    #[lua()]
    fn from_quat(
        rotation: LuaReflectValProxy<bevy::math::Quat>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around a normalized
/// rotation `axis` of `angle` (in radians).

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::Vec3>,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around the x axis of
/// `angle` (in radians).

    #[lua()]
    fn from_rotation_x(angle: f32) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around the y axis of
/// `angle` (in radians).

    #[lua()]
    fn from_rotation_y(angle: f32) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around the z axis of
/// `angle` (in radians).

    #[lua()]
    fn from_rotation_z(angle: f32) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transformation from the given 3D `translation`.

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform from a 3x3 matrix (expressing scale, shear and
/// rotation)

    #[lua()]
    fn from_mat3(
        mat3: LuaReflectValProxy<bevy::math::Mat3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
/// and a translation vector.
/// Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_mat3(mat3)`

    #[lua()]
    fn from_mat3_translation(
        mat3: LuaReflectValProxy<bevy::math::Mat3>,
        translation: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform from the given 3D `scale`, `rotation` and
/// `translation`.
/// Equivalent to `Affine3A::from_translation(translation) *
/// Affine3A::from_quat(rotation) * Affine3A::from_scale(scale)`

    #[lua()]
    fn from_scale_rotation_translation(
        scale: LuaReflectValProxy<bevy::math::Vec3>,
        rotation: LuaReflectValProxy<bevy::math::Quat>,
        translation: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates an affine transform from the given 3D `rotation` and `translation`.
/// Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_quat(rotation)`

    #[lua()]
    fn from_rotation_translation(
        rotation: LuaReflectValProxy<bevy::math::Quat>,
        translation: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// The given `Mat4` must be an affine transform,
/// i.e. contain no perspective transform.

    #[lua()]
    fn from_mat4(
        m: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates a left-handed view transform using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.

    #[lua()]
    fn look_to_lh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        dir: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates a right-handed view transform using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.

    #[lua()]
    fn look_to_rh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        dir: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates a left-handed view transform using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_lh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        center: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Creates a right-handed view transform using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_rh(
        eye: LuaReflectValProxy<bevy::math::Vec3>,
        center: LuaReflectValProxy<bevy::math::Vec3>,
        up: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
/// Transforms the given 3D points, applying shear, scale, rotation and translation.

    #[lua()]
    fn transform_point3(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Transforms the given 3D vector, applying shear, scale and rotation (but NOT
/// translation).
/// To also apply translation, use [`Self::transform_point3()`] instead.

    #[lua()]
    fn transform_vector3(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3>,
    ) -> LuaReflectValProxy<bevy::math::Vec3>;

"#,
    r#"
/// Transforms the given [`Vec3A`], applying shear, scale, rotation and translation.

    #[lua()]
    fn transform_point3a(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Transforms the given [`Vec3A`], applying shear, scale and rotation (but NOT
/// translation).
/// To also apply translation, use [`Self::transform_point3a()`] instead.

    #[lua()]
    fn transform_vector3a(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
        rhs: LuaReflectValProxy<bevy::math::Vec3A>,
    ) -> LuaReflectValProxy<bevy::math::Vec3A>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return
/// `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::Affine3A>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::Affine3A>) -> bool;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two 3x4 matrices contain similar elements. It works
/// best when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
        rhs: LuaReflectValProxy<bevy::math::Affine3A>,
        max_abs_diff: f32,
    ) -> bool;

"#,
    r#"
/// Return the inverse of this transform.
/// Note that if the transform is not invertible the result will be invalid.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Affine3A>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
        rhs: LuaReflectRefProxy<bevy::math::Affine3A>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Affine3A>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Affine3A>,
        rhs: LuaReflectValProxy<bevy::math::Affine3A>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Mat4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Affine3A>,
        rhs: LuaReflectValProxy<bevy::math::Mat4>,
    ) -> LuaReflectValProxy<bevy::math::Mat4>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Affine3A>,
    ) -> LuaReflectValProxy<bevy::math::Affine3A>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Affine3A {
    matrix3: bevy::math::Mat3A,
    translation: bevy::math::Vec3A,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DAffine2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates an affine transform from three column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::DVec2>,
        y_axis: LuaReflectValProxy<bevy::math::DVec2>,
        z_axis: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Creates a `[f64; 6]` array storing data in column major order.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::DAffine2>) -> [f64; 6];

"#,
    r#"
/// Creates a `[[f64; 2]; 3]` 2D array storing data in
/// column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(
        _self: LuaReflectRefProxy<bevy::math::DAffine2>,
    ) -> [[f64; 2]; 3];

"#,
    r#"
/// Creates an affine transform that changes scale.
/// Note that if any scale is zero the transform will be non-invertible.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Creates an affine transform from the given rotation `angle`.

    #[lua()]
    fn from_angle(angle: f64) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Creates an affine transformation from the given 2D `translation`.

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)

    #[lua()]
    fn from_mat2(
        matrix2: LuaReflectValProxy<bevy::math::DMat2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
/// translation vector.
/// Equivalent to
/// `DAffine2::from_translation(translation) * DAffine2::from_mat2(mat2)`

    #[lua()]
    fn from_mat2_translation(
        matrix2: LuaReflectValProxy<bevy::math::DMat2>,
        translation: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
/// `translation`.
/// Equivalent to `DAffine2::from_translation(translation) *
/// DAffine2::from_angle(angle) * DAffine2::from_scale(scale)`

    #[lua()]
    fn from_scale_angle_translation(
        scale: LuaReflectValProxy<bevy::math::DVec2>,
        angle: f64,
        translation: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Creates an affine transform from the given 2D rotation `angle` (in radians) and
/// `translation`.
/// Equivalent to `DAffine2::from_translation(translation) * DAffine2::from_angle(angle)`

    #[lua()]
    fn from_angle_translation(
        angle: f64,
        translation: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// The given `DMat3` must be an affine transform,

    #[lua()]
    fn from_mat3(
        m: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"
/// Transforms the given 2D point, applying shear, scale, rotation and translation.

    #[lua()]
    fn transform_point2(
        _self: LuaReflectRefProxy<bevy::math::DAffine2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Transforms the given 2D vector, applying shear, scale and rotation (but NOT
/// translation).
/// To also apply translation, use [`Self::transform_point2()`] instead.

    #[lua()]
    fn transform_vector2(
        _self: LuaReflectRefProxy<bevy::math::DAffine2>,
        rhs: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DVec2>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return
/// `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::DAffine2>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::DAffine2>) -> bool;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two 3x4 matrices contain similar elements. It works
/// best when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::DAffine2>,
        rhs: LuaReflectValProxy<bevy::math::DAffine2>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Return the inverse of this transform.
/// Note that if the transform is not invertible the result will be invalid.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::DAffine2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DMat3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DAffine2>,
        rhs: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DMat3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DAffine2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DAffine2>,
        rhs: LuaReflectValProxy<bevy::math::DAffine2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DAffine2>,
    ) -> LuaReflectValProxy<bevy::math::DAffine2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DAffine2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DAffine2>,
        rhs: LuaReflectRefProxy<bevy::math::DAffine2>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct DAffine2 {
    matrix2: bevy::math::DMat2,
    translation: bevy::math::DVec2,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DAffine3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DAffine3>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DAffine3>,
        rhs: LuaReflectRefProxy<bevy::math::DAffine3>,
    ) -> bool;

"#,
    r#"
/// Creates an affine transform from three column vectors.

    #[lua()]
    fn from_cols(
        x_axis: LuaReflectValProxy<bevy::math::DVec3>,
        y_axis: LuaReflectValProxy<bevy::math::DVec3>,
        z_axis: LuaReflectValProxy<bevy::math::DVec3>,
        w_axis: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates a `[f64; 12]` array storing data in column major order.

    #[lua()]
    fn to_cols_array(_self: LuaReflectRefProxy<bevy::math::DAffine3>) -> [f64; 12];

"#,
    r#"
/// Creates a `[[f64; 3]; 4]` 3D array storing data in
/// column major order.
/// If you require data in row major order `transpose` the matrix first.

    #[lua()]
    fn to_cols_array_2d(
        _self: LuaReflectRefProxy<bevy::math::DAffine3>,
    ) -> [[f64; 3]; 4];

"#,
    r#"
/// Creates an affine transform that changes scale.
/// Note that if any scale is zero the transform will be non-invertible.

    #[lua()]
    fn from_scale(
        scale: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform from the given `rotation` quaternion.

    #[lua()]
    fn from_quat(
        rotation: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around a normalized
/// rotation `axis` of `angle` (in radians).

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::DVec3>,
        angle: f64,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around the x axis of
/// `angle` (in radians).

    #[lua()]
    fn from_rotation_x(angle: f64) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around the y axis of
/// `angle` (in radians).

    #[lua()]
    fn from_rotation_y(angle: f64) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform containing a 3D rotation around the z axis of
/// `angle` (in radians).

    #[lua()]
    fn from_rotation_z(angle: f64) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transformation from the given 3D `translation`.

    #[lua()]
    fn from_translation(
        translation: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform from a 3x3 matrix (expressing scale, shear and
/// rotation)

    #[lua()]
    fn from_mat3(
        mat3: LuaReflectValProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
/// and a translation vector.
/// Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_mat3(mat3)`

    #[lua()]
    fn from_mat3_translation(
        mat3: LuaReflectValProxy<bevy::math::DMat3>,
        translation: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform from the given 3D `scale`, `rotation` and
/// `translation`.
/// Equivalent to `DAffine3::from_translation(translation) *
/// DAffine3::from_quat(rotation) * DAffine3::from_scale(scale)`

    #[lua()]
    fn from_scale_rotation_translation(
        scale: LuaReflectValProxy<bevy::math::DVec3>,
        rotation: LuaReflectValProxy<bevy::math::DQuat>,
        translation: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates an affine transform from the given 3D `rotation` and `translation`.
/// Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_quat(rotation)`

    #[lua()]
    fn from_rotation_translation(
        rotation: LuaReflectValProxy<bevy::math::DQuat>,
        translation: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// The given `DMat4` must be an affine transform,
/// i.e. contain no perspective transform.

    #[lua()]
    fn from_mat4(
        m: LuaReflectValProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates a left-handed view transform using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.

    #[lua()]
    fn look_to_lh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        dir: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates a right-handed view transform using a camera position, an up direction, and a facing
/// direction.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.

    #[lua()]
    fn look_to_rh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        dir: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates a left-handed view transform using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_lh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        center: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Creates a right-handed view transform using a camera position, an up direction, and a focal
/// point.
/// For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
/// # Panics
/// Will panic if `up` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn look_at_rh(
        eye: LuaReflectValProxy<bevy::math::DVec3>,
        center: LuaReflectValProxy<bevy::math::DVec3>,
        up: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"
/// Transforms the given 3D points, applying shear, scale, rotation and translation.

    #[lua()]
    fn transform_point3(
        _self: LuaReflectRefProxy<bevy::math::DAffine3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Transforms the given 3D vector, applying shear, scale and rotation (but NOT
/// translation).
/// To also apply translation, use [`Self::transform_point3()`] instead.

    #[lua()]
    fn transform_vector3(
        _self: LuaReflectRefProxy<bevy::math::DAffine3>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return
/// `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectRefProxy<bevy::math::DAffine3>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NaN`.

    #[lua()]
    fn is_nan(_self: LuaReflectRefProxy<bevy::math::DAffine3>) -> bool;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two 3x4 matrices contain similar elements. It works
/// best when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectRefProxy<bevy::math::DAffine3>,
        rhs: LuaReflectValProxy<bevy::math::DAffine3>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Return the inverse of this transform.
/// Note that if the transform is not invertible the result will be invalid.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::DAffine3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DAffine3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DAffine3>,
        rhs: LuaReflectValProxy<bevy::math::DAffine3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DAffine3>,
    ) -> LuaReflectValProxy<bevy::math::DAffine3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DMat4>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DAffine3>,
        rhs: LuaReflectValProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DMat4>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct DAffine3 {
    matrix3: bevy::math::DMat3,
    translation: bevy::math::DVec3,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::DQuat",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Multiplies a quaternion and a 3D vector, returning the rotated vector.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DVec3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Multiplies two quaternions. If they each represent a rotation, the result will
/// represent the combined rotation.
/// Note that due to floating point rounding the result may not be perfectly
/// normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua(as_trait = "std::ops::Mul::<bevy::math::DQuat>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Multiplies a quaternion by a scalar value.
/// The product is not guaranteed to be normalized.

    #[lua(as_trait = "std::ops::Mul::<f64>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Divides a quaternion by a scalar value.
/// The quotient is not guaranteed to be normalized.

    #[lua(as_trait = "std::ops::Div::<f64>", composite = "div")]
    fn div(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Subtracts the `rhs` quaternion from `self`.
/// The difference is not guaranteed to be normalized.

    #[lua(as_trait = "std::ops::Sub::<bevy::math::DQuat>", composite = "sub")]
    fn sub(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a new rotation quaternion.
/// This should generally not be called manually unless you know what you are doing.
/// Use one of the other constructors instead such as `identity` or `from_axis_angle`.
/// `from_xyzw` is mostly used by unit tests and `serde` deserialization.
/// # Preconditions
/// This function does not check if the input is normalized, it is up to the user to
/// provide normalized input or to normalized the resulting quaternion.

    #[lua()]
    fn from_xyzw(
        x: f64,
        y: f64,
        z: f64,
        w: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a rotation quaternion from an array.
/// # Preconditions
/// This function does not check if the input is normalized, it is up to the user to
/// provide normalized input or to normalized the resulting quaternion.

    #[lua()]
    fn from_array(a: [f64; 4]) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a new rotation quaternion from a 4D vector.
/// # Preconditions
/// This function does not check if the input is normalized, it is up to the user to
/// provide normalized input or to normalized the resulting quaternion.

    #[lua()]
    fn from_vec4(
        v: LuaReflectValProxy<bevy::math::DVec4>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
/// The axis must be a unit vector.
/// # Panics
/// Will panic if `axis` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_axis_angle(
        axis: LuaReflectValProxy<bevy::math::DVec3>,
        angle: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
/// `from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.

    #[lua()]
    fn from_scaled_axis(
        v: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a quaternion from the `angle` (in radians) around the x axis.

    #[lua()]
    fn from_rotation_x(angle: f64) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a quaternion from the `angle` (in radians) around the y axis.

    #[lua()]
    fn from_rotation_y(angle: f64) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a quaternion from the `angle` (in radians) around the z axis.

    #[lua()]
    fn from_rotation_z(angle: f64) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a quaternion from the given Euler rotation sequence and the angles (in radians).

    #[lua()]
    fn from_euler(
        euler: LuaReflectValProxy<bevy::math::EulerRot>,
        a: f64,
        b: f64,
        c: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a quaternion from a 3x3 rotation matrix.
/// Note if the input matrix contain scales, shears, or other non-rotation transformations then
/// the resulting quaternion will be ill-defined.
/// # Panics
/// Will panic if any input matrix column is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_mat3(
        mat: LuaReflectRefProxy<bevy::math::DMat3>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a quaternion from the upper 3x3 rotation matrix inside a homogeneous 4x4 matrix.
/// Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
/// then the resulting quaternion will be ill-defined.
/// # Panics
/// Will panic if any column of the upper 3x3 rotation matrix is not normalized when
/// `glam_assert` is enabled.

    #[lua()]
    fn from_mat4(
        mat: LuaReflectRefProxy<bevy::math::DMat4>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
/// plane spanned by the two vectors.  Will rotate at most 180 degrees.
/// The inputs must be unit vectors.
/// `from_rotation_arc(from, to) * from ≈ to`.
/// For near-singular cases (from≈to and from≈-to) the current implementation
/// is only accurate to about 0.001 (for `f32`).
/// # Panics
/// Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_arc(
        from: LuaReflectValProxy<bevy::math::DVec3>,
        to: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
/// that the resulting quaternion will rotate `from` so that it is colinear with `to`.
/// The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
/// degrees.
/// The inputs must be unit vectors.
/// `to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
/// # Panics
/// Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_arc_colinear(
        from: LuaReflectValProxy<bevy::math::DVec3>,
        to: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
/// around the z axis. Will rotate at most 180 degrees.
/// The inputs must be unit vectors.
/// `from_rotation_arc_2d(from, to) * from ≈ to`.
/// For near-singular cases (from≈to and from≈-to) the current implementation
/// is only accurate to about 0.001 (for `f32`).
/// # Panics
/// Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn from_rotation_arc_2d(
        from: LuaReflectValProxy<bevy::math::DVec2>,
        to: LuaReflectValProxy<bevy::math::DVec2>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Returns the rotation axis scaled by the rotation in radians.

    #[lua()]
    fn to_scaled_axis(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the rotation angles for the given euler rotation sequence.

    #[lua()]
    fn to_euler(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        order: LuaReflectValProxy<bevy::math::EulerRot>,
    ) -> (f64, f64, f64);

"#,
    r#"
/// `[x, y, z, w]`

    #[lua()]
    fn to_array(_self: LuaReflectRefProxy<bevy::math::DQuat>) -> [f64; 4];

"#,
    r#"
/// Returns the vector part of the quaternion.

    #[lua()]
    fn xyz(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Returns the quaternion conjugate of `self`. For a unit quaternion the
/// conjugate is also the inverse.

    #[lua()]
    fn conjugate(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Returns the inverse of a normalized quaternion.
/// Typically quaternion inverse returns the conjugate of a normalized quaternion.
/// Because `self` is assumed to already be unit length this method *does not* normalize
/// before returning the conjugate.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn inverse(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Computes the dot product of `self` and `rhs`. The dot product is
/// equal to the cosine of the angle between two quaternion rotations.

    #[lua()]
    fn dot(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> f64;

"#,
    r#"
/// Computes the length of `self`.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::DQuat>) -> f64;

"#,
    r#"
/// Computes the squared length of `self`.
/// This is generally faster than `length()` as it avoids a square
/// root operation.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::DQuat>) -> f64;

"#,
    r#"
/// Computes `1.0 / length()`.
/// For valid results, `self` must _not_ be of length zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::DQuat>) -> f64;

"#,
    r#"
/// Returns `self` normalized to length 1.0.
/// For valid results, `self` must _not_ be of length zero.
/// Panics
/// Will panic if `self` is zero length when `glam_assert` is enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Returns `true` if, and only if, all elements are finite.
/// If any element is either `NaN`, positive or negative infinity, this will return `false`.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::DQuat>) -> bool;

"#,
    r#"
/// Returns `true` if any elements are `NAN`.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::DQuat>) -> bool;

"#,
    r#"
/// Returns whether `self` of length `1.0` or not.
/// Uses a precision threshold of `1e-6`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::DQuat>) -> bool;

"#,
    r#"

    #[lua()]
    fn is_near_identity(_self: LuaReflectValProxy<bevy::math::DQuat>) -> bool;

"#,
    r#"
/// Returns the angle (in radians) for the minimal rotation
/// for transforming this quaternion into another.
/// Both quaternions must be normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> f64;

"#,
    r#"
/// Rotates towards `rhs` up to `max_angle` (in radians).
/// When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
/// `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
/// rotates towards the exact opposite of `rhs`. Will not go past the target.
/// Both quaternions must be normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn rotate_towards(
        _self: LuaReflectRefProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
        max_angle: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Returns true if the absolute difference of all elements between `self` and `rhs`
/// is less than or equal to `max_abs_diff`.
/// This can be used to compare if two quaternions contain similar elements. It works
/// best when comparing with a known value. The `max_abs_diff` that should be used used
/// depends on the values being compared against.
/// For more see
/// [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).

    #[lua()]
    fn abs_diff_eq(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
        max_abs_diff: f64,
    ) -> bool;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on
/// the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s`
/// is `1.0`, the result will be equal to `rhs`.
/// # Panics
/// Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn lerp(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        end: LuaReflectValProxy<bevy::math::DQuat>,
        s: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Performs a spherical linear interpolation between `self` and `end`
/// based on the value `s`.
/// When `s` is `0.0`, the result will be equal to `self`.  When `s`
/// is `1.0`, the result will be equal to `end`.
/// # Panics
/// Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn slerp(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        end: LuaReflectValProxy<bevy::math::DQuat>,
        s: f64,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Multiplies a quaternion and a 3D vector, returning the rotated vector.
/// # Panics
/// Will panic if `self` is not normalized when `glam_assert` is enabled.

    #[lua()]
    fn mul_vec3(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DVec3>,
    ) -> LuaReflectValProxy<bevy::math::DVec3>;

"#,
    r#"
/// Multiplies two quaternions. If they each represent a rotation, the result will
/// represent the combined rotation.
/// Note that due to floating point rounding the result may not be perfectly normalized.
/// # Panics
/// Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.

    #[lua()]
    fn mul_quat(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
/// Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
/// Note if the input affine matrix contain scales, shears, or other non-rotation
/// transformations then the resulting quaternion will be ill-defined.
/// # Panics
/// Will panic if any input affine matrix column is not normalized when `glam_assert` is
/// enabled.

    #[lua()]
    fn from_affine3(
        a: LuaReflectRefProxy<bevy::math::DAffine3>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"

    #[lua()]
    fn as_quat(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::Quat>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::DQuat>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::DQuat>,
        rhs: LuaReflectRefProxy<bevy::math::DQuat>,
    ) -> bool;

"#,
    r#"
/// Adds two quaternions.
/// The sum is not guaranteed to be normalized.
/// Note that addition is not the same as combining the rotations represented by the
/// two quaternions! That corresponds to multiplication.

    #[lua(as_trait = "std::ops::Add::<bevy::math::DQuat>", composite = "add")]
    fn add(
        _self: LuaReflectValProxy<bevy::math::DQuat>,
        rhs: LuaReflectValProxy<bevy::math::DQuat>,
    ) -> LuaReflectValProxy<bevy::math::DQuat>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct DQuat {
    x: f64,
    y: f64,
    z: f64,
    w: f64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::EulerRot",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::EulerRot>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::EulerRot>,
        other: LuaReflectRefProxy<bevy::math::EulerRot>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::EulerRot>,
    ) -> LuaReflectValProxy<bevy::math::EulerRot>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: LuaReflectRefProxy<bevy::math::EulerRot>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct EulerRot {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::BVec3A",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new vector mask.

    #[lua()]
    fn new(x: bool, y: bool, z: bool) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Creates a vector mask with all elements set to `v`.

    #[lua()]
    fn splat(v: bool) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Creates a new vector mask from a bool array.

    #[lua()]
    fn from_array(a: [bool; 3]) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
/// Returns a bitmask with the lowest 3 bits set from the elements of `self`.
/// A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn bitmask(_self: LuaReflectValProxy<bevy::math::BVec3A>) -> u32;

"#,
    r#"
/// Returns true if any of the elements are true, false otherwise.

    #[lua()]
    fn any(_self: LuaReflectValProxy<bevy::math::BVec3A>) -> bool;

"#,
    r#"
/// Returns true if all the elements are true, false otherwise.

    #[lua()]
    fn all(_self: LuaReflectValProxy<bevy::math::BVec3A>) -> bool;

"#,
    r#"
/// Tests the value at `index`.
/// Panics if `index` is greater than 2.

    #[lua()]
    fn test(_self: LuaReflectRefProxy<bevy::math::BVec3A>, index: usize) -> bool;

"#,
    r#"
/// Sets the element at `index`.
/// Panics if `index` is greater than 2.

    #[lua()]
    fn set(
        _self: LuaReflectRefMutProxy<bevy::math::BVec3A>,
        index: usize,
        value: bool,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::BVec3A>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::BVec3A>,
        rhs: LuaReflectRefProxy<bevy::math::BVec3A>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::BVec3A>,
    ) -> LuaReflectValProxy<bevy::math::BVec3A>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BVec3A();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::BVec4A",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::BVec4A>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::BVec4A>,
        rhs: LuaReflectRefProxy<bevy::math::BVec4A>,
    ) -> bool;

"#,
    r#"
/// Creates a new vector mask.

    #[lua()]
    fn new(x: bool, y: bool, z: bool, w: bool) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Creates a vector mask with all elements set to `v`.

    #[lua()]
    fn splat(v: bool) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Creates a new vector mask from a bool array.

    #[lua()]
    fn from_array(a: [bool; 4]) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
/// Returns a bitmask with the lowest 4 bits set from the elements of `self`.
/// A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
/// into the first lowest bit, element `y` into the second, etc.

    #[lua()]
    fn bitmask(_self: LuaReflectValProxy<bevy::math::BVec4A>) -> u32;

"#,
    r#"
/// Returns true if any of the elements are true, false otherwise.

    #[lua()]
    fn any(_self: LuaReflectValProxy<bevy::math::BVec4A>) -> bool;

"#,
    r#"
/// Returns true if all the elements are true, false otherwise.

    #[lua()]
    fn all(_self: LuaReflectValProxy<bevy::math::BVec4A>) -> bool;

"#,
    r#"
/// Tests the value at `index`.
/// Panics if `index` is greater than 3.

    #[lua()]
    fn test(_self: LuaReflectRefProxy<bevy::math::BVec4A>, index: usize) -> bool;

"#,
    r#"
/// Sets the element at `index`.
/// Panics if `index` is greater than 3.

    #[lua()]
    fn set(
        _self: LuaReflectRefMutProxy<bevy::math::BVec4A>,
        index: usize,
        value: bool,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::BVec4A>,
    ) -> LuaReflectValProxy<bevy::math::BVec4A>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BVec4A();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "smol_str::SmolStr",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<smol_str::SmolStr>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<smol_str::SmolStr>,
        other: LuaReflectRefProxy<smol_str::SmolStr>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<smol_str::SmolStr>,
    ) -> LuaReflectValProxy<smol_str::SmolStr>;

"#,
    r#"

    #[lua()]
    fn to_string(_self: LuaReflectRefProxy<smol_str::SmolStr>) -> std::string::String;

"#,
    r#"

    #[lua()]
    fn len(_self: LuaReflectRefProxy<smol_str::SmolStr>) -> usize;

"#,
    r#"

    #[lua()]
    fn is_empty(_self: LuaReflectRefProxy<smol_str::SmolStr>) -> bool;

"#,
    r#"

    #[lua()]
    fn is_heap_allocated(_self: LuaReflectRefProxy<smol_str::SmolStr>) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct SmolStr();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "uuid::Uuid",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Returns the version number of the UUID.
/// This represents the algorithm used to generate the value.
/// This method is the future-proof alternative to [`Uuid::get_version`].
/// # Examples
/// Basic usage:
/// ```
/// # use uuid::Uuid;
/// # fn main() -> Result<(), uuid::Error> {
/// let my_uuid = Uuid::parse_str("02f09a3f-1624-3b1d-8409-44eff7708208")?;
/// assert_eq!(3, my_uuid.get_version_num());
/// # Ok(())
/// # }
/// ```
/// # References
/// * [Version Field in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-4.2)

    #[lua()]
    fn get_version_num(_self: LuaReflectRefProxy<uuid::Uuid>) -> usize;

"#,
    r#"
/// Returns a 128bit value containing the value.
/// The bytes in the UUID will be packed directly into a `u128`.
/// # Examples
/// ```
/// # use uuid::Uuid;
/// # fn main() -> Result<(), uuid::Error> {
/// let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
/// assert_eq!(
///     uuid.as_u128(),
///     0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8,
/// );
/// # Ok(())
/// # }
/// ```

    #[lua()]
    fn as_u128(_self: LuaReflectRefProxy<uuid::Uuid>) -> u128;

"#,
    r#"
/// Returns a 128bit little-endian value containing the value.
/// The bytes in the `u128` will be flipped to convert into big-endian
/// order. This is based on the endianness of the UUID, rather than the
/// target environment so bytes will be flipped on both big and little
/// endian machines.
/// Note that this will produce a different result than
/// [`Uuid::to_fields_le`], because the entire UUID is reversed, rather
/// than reversing the individual fields in-place.
/// # Examples
/// ```
/// # use uuid::Uuid;
/// # fn main() -> Result<(), uuid::Error> {
/// let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
/// assert_eq!(
///     uuid.to_u128_le(),
///     0xd8d7d6d5d4d3d2d1c2c1b2b1a4a3a2a1,
/// );
/// # Ok(())
/// # }
/// ```

    #[lua()]
    fn to_u128_le(_self: LuaReflectRefProxy<uuid::Uuid>) -> u128;

"#,
    r#"
/// Returns two 64bit values containing the value.
/// The bytes in the UUID will be split into two `u64`.
/// The first u64 represents the 64 most significant bits,
/// the second one represents the 64 least significant.
/// # Examples
/// ```
/// # use uuid::Uuid;
/// # fn main() -> Result<(), uuid::Error> {
/// let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
/// assert_eq!(
///     uuid.as_u64_pair(),
///     (0xa1a2a3a4b1b2c1c2, 0xd1d2d3d4d5d6d7d8),
/// );
/// # Ok(())
/// # }
/// ```

    #[lua()]
    fn as_u64_pair(_self: LuaReflectRefProxy<uuid::Uuid>) -> (u64, u64);

"#,
    r#"
/// Consumes self and returns the underlying byte value of the UUID.
/// # Examples
/// ```
/// # use uuid::Uuid;
/// let bytes = [
///     0xa1, 0xa2, 0xa3, 0xa4,
///     0xb1, 0xb2,
///     0xc1, 0xc2,
///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
/// ];
/// let uuid = Uuid::from_bytes(bytes);
/// assert_eq!(bytes, uuid.into_bytes());
/// ```

    #[lua()]
    fn into_bytes(_self: LuaReflectValProxy<uuid::Uuid>) -> [u8; 16];

"#,
    r#"
/// Returns the bytes of the UUID in little-endian order.
/// The bytes will be flipped to convert into little-endian order. This is
/// based on the endianness of the UUID, rather than the target environment
/// so bytes will be flipped on both big and little endian machines.
/// # Examples
/// ```
/// use uuid::Uuid;
/// # fn main() -> Result<(), uuid::Error> {
/// let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
/// assert_eq!(
///     uuid.to_bytes_le(),
///     ([
///         0xa4, 0xa3, 0xa2, 0xa1, 0xb2, 0xb1, 0xc2, 0xc1, 0xd1, 0xd2,
///         0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8
///     ])
/// );
/// # Ok(())
/// # }
/// ```

    #[lua()]
    fn to_bytes_le(_self: LuaReflectRefProxy<uuid::Uuid>) -> [u8; 16];

"#,
    r#"
/// Tests if the UUID is nil (all zeros).

    #[lua()]
    fn is_nil(_self: LuaReflectRefProxy<uuid::Uuid>) -> bool;

"#,
    r#"
/// Tests if the UUID is max (all ones).

    #[lua()]
    fn is_max(_self: LuaReflectRefProxy<uuid::Uuid>) -> bool;

"#,
    r#"
/// A buffer that can be used for `encode_...` calls, that is
/// guaranteed to be long enough for any of the format adapters.
/// # Examples
/// ```
/// # use uuid::Uuid;
/// let uuid = Uuid::nil();
/// assert_eq!(
///     uuid.simple().encode_lower(&mut Uuid::encode_buffer()),
///     "00000000000000000000000000000000"
/// );
/// assert_eq!(
///     uuid.hyphenated()
///         .encode_lower(&mut Uuid::encode_buffer()),
///     "00000000-0000-0000-0000-000000000000"
/// );
/// assert_eq!(
///     uuid.urn().encode_lower(&mut Uuid::encode_buffer()),
///     "urn:uuid:00000000-0000-0000-0000-000000000000"
/// );
/// ```

    #[lua()]
    fn encode_buffer() -> [u8; 45];

"#,
    r#"
/// If the UUID is the correct version (v1, or v6) this will return the
/// node value as a 6-byte array. For other versions this will return `None`.

    #[lua()]
    fn get_node_id(
        _self: LuaReflectRefProxy<uuid::Uuid>,
    ) -> bevy::reflect::erased_serde::__private::serde::__private::Option<[u8; 6]>;

"#,
    r#"

    #[lua(as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone")]
    fn clone(_self: LuaReflectRefProxy<uuid::Uuid>) -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"
/// Creates a random UUID.
/// This uses the [`getrandom`] crate to utilise the operating system's RNG
/// as the source of random numbers. If you'd like to use a custom
/// generator, don't use this method: generate random bytes using your
/// custom generator and pass them to the
/// [`uuid::Builder::from_random_bytes`][from_random_bytes] function
/// instead.
/// Note that usage of this method requires the `v4` feature of this crate
/// to be enabled.
/// # Examples
/// Basic usage:
/// ```
/// # use uuid::{Uuid, Version};
/// let uuid = Uuid::new_v4();
/// assert_eq!(Some(Version::Random), uuid.get_version());
/// ```
/// # References
/// * [UUID Version 4 in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.4)
/// [`getrandom`]: https://crates.io/crates/getrandom
/// [from_random_bytes]: struct.Builder.html#method.from_random_bytes

    #[lua()]
    fn new_v4() -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: LuaReflectRefProxy<uuid::Uuid>) -> ();

"#,
    r#"
/// The 'nil UUID' (all zeros).
/// The nil UUID is a special form of UUID that is specified to have all
/// 128 bits set to zero.
/// # References
/// * [Nil UUID in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.9)
/// # Examples
/// Basic usage:
/// ```
/// # use uuid::Uuid;
/// let uuid = Uuid::nil();
/// assert_eq!(
///     "00000000-0000-0000-0000-000000000000",
///     uuid.hyphenated().to_string(),
/// );
/// ```

    #[lua()]
    fn nil() -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"
/// The 'max UUID' (all ones).
/// The max UUID is a special form of UUID that is specified to have all
/// 128 bits set to one.
/// # References
/// * [Max UUID in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.10)
/// # Examples
/// Basic usage:
/// ```
/// # use uuid::Uuid;
/// let uuid = Uuid::max();
/// assert_eq!(
///     "ffffffff-ffff-ffff-ffff-ffffffffffff",
///     uuid.hyphenated().to_string(),
/// );
/// ```

    #[lua()]
    fn max() -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"
/// Creates a UUID from a 128bit value.
/// # Examples
/// Basic usage:
/// ```
/// # use uuid::Uuid;
/// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;
/// let uuid = Uuid::from_u128(v);
/// assert_eq!(
///     "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8",
///     uuid.hyphenated().to_string(),
/// );
/// ```

    #[lua()]
    fn from_u128(v: u128) -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"
/// Creates a UUID from a 128bit value in little-endian order.
/// The entire value will be flipped to convert into big-endian order.
/// This is based on the endianness of the UUID, rather than the target
/// environment so bytes will be flipped on both big and little endian
/// machines.
/// # Examples
/// Basic usage:
/// ```
/// # use uuid::Uuid;
/// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;
/// let uuid = Uuid::from_u128_le(v);
/// assert_eq!(
///     "d8d7d6d5-d4d3-d2d1-c2c1-b2b1a4a3a2a1",
///     uuid.hyphenated().to_string(),
/// );
/// ```

    #[lua()]
    fn from_u128_le(v: u128) -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"
/// Creates a UUID from two 64bit values.
/// # Examples
/// Basic usage:
/// ```
/// # use uuid::Uuid;
/// let hi = 0xa1a2a3a4b1b2c1c2u64;
/// let lo = 0xd1d2d3d4d5d6d7d8u64;
/// let uuid = Uuid::from_u64_pair(hi, lo);
/// assert_eq!(
///     "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8",
///     uuid.hyphenated().to_string(),
/// );
/// ```

    #[lua()]
    fn from_u64_pair(high_bits: u64, low_bits: u64) -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"
/// Creates a UUID using the supplied bytes.
/// # Examples
/// Basic usage:
/// ```
/// # fn main() -> Result<(), uuid::Error> {
/// # use uuid::Uuid;
/// let bytes = [
///     0xa1, 0xa2, 0xa3, 0xa4,
///     0xb1, 0xb2,
///     0xc1, 0xc2,
///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
/// ];
/// let uuid = Uuid::from_bytes(bytes);
/// assert_eq!(
///     uuid.hyphenated().to_string(),
///     "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8"
/// );
/// # Ok(())
/// # }
/// ```

    #[lua()]
    fn from_bytes(bytes: [u8; 16]) -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"
/// Creates a UUID using the supplied bytes in little endian order.
/// The individual fields encoded in the buffer will be flipped.
/// # Examples
/// Basic usage:
/// ```
/// # fn main() -> Result<(), uuid::Error> {
/// # use uuid::Uuid;
/// let bytes = [
///     0xa1, 0xa2, 0xa3, 0xa4,
///     0xb1, 0xb2,
///     0xc1, 0xc2,
///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
/// ];
/// let uuid = Uuid::from_bytes_le(bytes);
/// assert_eq!(
///     "a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8",
///     uuid.hyphenated().to_string(),
/// );
/// # Ok(())
/// # }
/// ```

    #[lua()]
    fn from_bytes_le(b: [u8; 16]) -> LuaReflectValProxy<uuid::Uuid>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<uuid::Uuid>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<uuid::Uuid>,
        other: LuaReflectRefProxy<uuid::Uuid>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Uuid();
#[derive(Default)]
pub(crate) struct Globals;
impl crate::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: crate::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> crate::tealr::mlu::mlua::Result<()> {
        instances
            .add_instance(
                "AtomicBool",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicBool>::new,
            )?;
        instances
            .add_instance(
                "AtomicI16",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicI16>::new,
            )?;
        instances
            .add_instance(
                "AtomicI32",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicI32>::new,
            )?;
        instances
            .add_instance(
                "AtomicI64",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicI64>::new,
            )?;
        instances
            .add_instance(
                "AtomicI8",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicI8>::new,
            )?;
        instances
            .add_instance(
                "AtomicIsize",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicIsize>::new,
            )?;
        instances
            .add_instance(
                "AtomicU16",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicU16>::new,
            )?;
        instances
            .add_instance(
                "AtomicU32",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicU32>::new,
            )?;
        instances
            .add_instance(
                "AtomicU64",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicU64>::new,
            )?;
        instances
            .add_instance(
                "AtomicU8",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicU8>::new,
            )?;
        instances
            .add_instance(
                "AtomicUsize",
                crate::tealr::mlu::UserDataProxy::<LuaAtomicUsize>::new,
            )?;
        instances
            .add_instance(
                "Duration",
                crate::tealr::mlu::UserDataProxy::<LuaDuration>::new,
            )?;
        instances
            .add_instance(
                "Instant",
                crate::tealr::mlu::UserDataProxy::<LuaInstant>::new,
            )?;
        instances
            .add_instance(
                "PathBuf",
                crate::tealr::mlu::UserDataProxy::<LuaPathBuf>::new,
            )?;
        instances
            .add_instance("Quat", crate::tealr::mlu::UserDataProxy::<LuaQuat>::new)?;
        instances
            .add_instance("Vec3", crate::tealr::mlu::UserDataProxy::<LuaVec3>::new)?;
        instances
            .add_instance("IVec2", crate::tealr::mlu::UserDataProxy::<LuaIVec2>::new)?;
        instances
            .add_instance("IVec3", crate::tealr::mlu::UserDataProxy::<LuaIVec3>::new)?;
        instances
            .add_instance("IVec4", crate::tealr::mlu::UserDataProxy::<LuaIVec4>::new)?;
        instances
            .add_instance(
                "I64Vec2",
                crate::tealr::mlu::UserDataProxy::<LuaI64Vec2>::new,
            )?;
        instances
            .add_instance(
                "I64Vec3",
                crate::tealr::mlu::UserDataProxy::<LuaI64Vec3>::new,
            )?;
        instances
            .add_instance(
                "I64Vec4",
                crate::tealr::mlu::UserDataProxy::<LuaI64Vec4>::new,
            )?;
        instances
            .add_instance("UVec2", crate::tealr::mlu::UserDataProxy::<LuaUVec2>::new)?;
        instances
            .add_instance("UVec3", crate::tealr::mlu::UserDataProxy::<LuaUVec3>::new)?;
        instances
            .add_instance("UVec4", crate::tealr::mlu::UserDataProxy::<LuaUVec4>::new)?;
        instances
            .add_instance(
                "U64Vec2",
                crate::tealr::mlu::UserDataProxy::<LuaU64Vec2>::new,
            )?;
        instances
            .add_instance(
                "U64Vec3",
                crate::tealr::mlu::UserDataProxy::<LuaU64Vec3>::new,
            )?;
        instances
            .add_instance(
                "U64Vec4",
                crate::tealr::mlu::UserDataProxy::<LuaU64Vec4>::new,
            )?;
        instances
            .add_instance("Vec2", crate::tealr::mlu::UserDataProxy::<LuaVec2>::new)?;
        instances
            .add_instance("Vec3A", crate::tealr::mlu::UserDataProxy::<LuaVec3A>::new)?;
        instances
            .add_instance("Vec4", crate::tealr::mlu::UserDataProxy::<LuaVec4>::new)?;
        instances
            .add_instance("BVec2", crate::tealr::mlu::UserDataProxy::<LuaBVec2>::new)?;
        instances
            .add_instance("BVec3", crate::tealr::mlu::UserDataProxy::<LuaBVec3>::new)?;
        instances
            .add_instance("BVec4", crate::tealr::mlu::UserDataProxy::<LuaBVec4>::new)?;
        instances
            .add_instance("DVec2", crate::tealr::mlu::UserDataProxy::<LuaDVec2>::new)?;
        instances
            .add_instance("DVec3", crate::tealr::mlu::UserDataProxy::<LuaDVec3>::new)?;
        instances
            .add_instance("DVec4", crate::tealr::mlu::UserDataProxy::<LuaDVec4>::new)?;
        instances
            .add_instance("Mat2", crate::tealr::mlu::UserDataProxy::<LuaMat2>::new)?;
        instances
            .add_instance("Mat3", crate::tealr::mlu::UserDataProxy::<LuaMat3>::new)?;
        instances
            .add_instance("Mat3A", crate::tealr::mlu::UserDataProxy::<LuaMat3A>::new)?;
        instances
            .add_instance("Mat4", crate::tealr::mlu::UserDataProxy::<LuaMat4>::new)?;
        instances
            .add_instance("DMat2", crate::tealr::mlu::UserDataProxy::<LuaDMat2>::new)?;
        instances
            .add_instance("DMat3", crate::tealr::mlu::UserDataProxy::<LuaDMat3>::new)?;
        instances
            .add_instance("DMat4", crate::tealr::mlu::UserDataProxy::<LuaDMat4>::new)?;
        instances
            .add_instance(
                "Affine2",
                crate::tealr::mlu::UserDataProxy::<LuaAffine2>::new,
            )?;
        instances
            .add_instance(
                "Affine3A",
                crate::tealr::mlu::UserDataProxy::<LuaAffine3A>::new,
            )?;
        instances
            .add_instance(
                "DAffine2",
                crate::tealr::mlu::UserDataProxy::<LuaDAffine2>::new,
            )?;
        instances
            .add_instance(
                "DAffine3",
                crate::tealr::mlu::UserDataProxy::<LuaDAffine3>::new,
            )?;
        instances
            .add_instance("DQuat", crate::tealr::mlu::UserDataProxy::<LuaDQuat>::new)?;
        instances
            .add_instance("BVec3A", crate::tealr::mlu::UserDataProxy::<LuaBVec3A>::new)?;
        instances
            .add_instance("BVec4A", crate::tealr::mlu::UserDataProxy::<LuaBVec4A>::new)?;
        instances
            .add_instance("Uuid", crate::tealr::mlu::UserDataProxy::<LuaUuid>::new)?;
        Ok(())
    }
}
fn bevy_reflect_context_initializer(
    _: &bevy_mod_scripting_core::script::ScriptId,
    ctx: &mut crate::prelude::Lua,
) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
    crate::tealr::mlu::set_global_env(Globals, ctx)?;
    Ok(())
}
pub struct BevyReflectScriptingPlugin;
impl bevy::app::Plugin for BevyReflectScriptingPlugin {
    fn build(&self, app: &mut bevy::prelude::App) {
        app.register_lua_proxy::<std::sync::atomic::AtomicBool>();
        app.register_lua_proxy::<std::sync::atomic::AtomicI16>();
        app.register_lua_proxy::<std::sync::atomic::AtomicI32>();
        app.register_lua_proxy::<std::sync::atomic::AtomicI64>();
        app.register_lua_proxy::<std::sync::atomic::AtomicI8>();
        app.register_lua_proxy::<std::sync::atomic::AtomicIsize>();
        app.register_lua_proxy::<std::sync::atomic::AtomicU16>();
        app.register_lua_proxy::<std::sync::atomic::AtomicU32>();
        app.register_lua_proxy::<std::sync::atomic::AtomicU64>();
        app.register_lua_proxy::<std::sync::atomic::AtomicU8>();
        app.register_lua_proxy::<std::sync::atomic::AtomicUsize>();
        app.register_lua_proxy::<bevy::utils::Duration>();
        app.register_lua_proxy::<bevy::utils::Instant>();
        app.register_lua_proxy::<std::path::PathBuf>();
        app.register_lua_proxy::<std::ops::RangeFull>();
        app.register_lua_proxy::<bevy::math::Quat>();
        app.register_lua_proxy::<bevy::math::Vec3>();
        app.register_lua_proxy::<bevy::math::IVec2>();
        app.register_lua_proxy::<bevy::math::IVec3>();
        app.register_lua_proxy::<bevy::math::IVec4>();
        app.register_lua_proxy::<bevy::math::I64Vec2>();
        app.register_lua_proxy::<bevy::math::I64Vec3>();
        app.register_lua_proxy::<bevy::math::I64Vec4>();
        app.register_lua_proxy::<bevy::math::UVec2>();
        app.register_lua_proxy::<bevy::math::UVec3>();
        app.register_lua_proxy::<bevy::math::UVec4>();
        app.register_lua_proxy::<bevy::math::U64Vec2>();
        app.register_lua_proxy::<bevy::math::U64Vec3>();
        app.register_lua_proxy::<bevy::math::U64Vec4>();
        app.register_lua_proxy::<bevy::math::Vec2>();
        app.register_lua_proxy::<bevy::math::Vec3A>();
        app.register_lua_proxy::<bevy::math::Vec4>();
        app.register_lua_proxy::<bevy::math::BVec2>();
        app.register_lua_proxy::<bevy::math::BVec3>();
        app.register_lua_proxy::<bevy::math::BVec4>();
        app.register_lua_proxy::<bevy::math::DVec2>();
        app.register_lua_proxy::<bevy::math::DVec3>();
        app.register_lua_proxy::<bevy::math::DVec4>();
        app.register_lua_proxy::<bevy::math::Mat2>();
        app.register_lua_proxy::<bevy::math::Mat3>();
        app.register_lua_proxy::<bevy::math::Mat3A>();
        app.register_lua_proxy::<bevy::math::Mat4>();
        app.register_lua_proxy::<bevy::math::DMat2>();
        app.register_lua_proxy::<bevy::math::DMat3>();
        app.register_lua_proxy::<bevy::math::DMat4>();
        app.register_lua_proxy::<bevy::math::Affine2>();
        app.register_lua_proxy::<bevy::math::Affine3A>();
        app.register_lua_proxy::<bevy::math::DAffine2>();
        app.register_lua_proxy::<bevy::math::DAffine3>();
        app.register_lua_proxy::<bevy::math::DQuat>();
        app.register_lua_proxy::<bevy::math::EulerRot>();
        app.register_lua_proxy::<bevy::math::BVec3A>();
        app.register_lua_proxy::<bevy::math::BVec4A>();
        app.register_lua_proxy::<smol_str::SmolStr>();
        app.register_lua_proxy::<uuid::Uuid>();
        app.add_context_initializer::<()>(bevy_reflect_context_initializer);
        app.add_documentation_fragment(
            crate::docs::LuaDocumentationFragment::new(
                "BevyReflectAPI",
                |tw| {
                    tw.document_global_instance::<Globals>()
                        .expect("Something went wrong documenting globals")
                        .process_type::<LuaAtomicBool>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaAtomicBool>,
                        >()
                        .process_type::<LuaAtomicI16>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicI16>>()
                        .process_type::<LuaAtomicI32>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicI32>>()
                        .process_type::<LuaAtomicI64>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicI64>>()
                        .process_type::<LuaAtomicI8>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicI8>>()
                        .process_type::<LuaAtomicIsize>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaAtomicIsize>,
                        >()
                        .process_type::<LuaAtomicU16>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicU16>>()
                        .process_type::<LuaAtomicU32>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicU32>>()
                        .process_type::<LuaAtomicU64>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicU64>>()
                        .process_type::<LuaAtomicU8>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAtomicU8>>()
                        .process_type::<LuaAtomicUsize>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaAtomicUsize>,
                        >()
                        .process_type::<LuaDuration>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDuration>>()
                        .process_type::<LuaInstant>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaInstant>>()
                        .process_type::<LuaPathBuf>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaPathBuf>>()
                        .process_type::<LuaRangeFull>()
                        .process_type::<LuaQuat>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaQuat>>()
                        .process_type::<LuaVec3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaVec3>>()
                        .process_type::<LuaIVec2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaIVec2>>()
                        .process_type::<LuaIVec3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaIVec3>>()
                        .process_type::<LuaIVec4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaIVec4>>()
                        .process_type::<LuaI64Vec2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaI64Vec2>>()
                        .process_type::<LuaI64Vec3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaI64Vec3>>()
                        .process_type::<LuaI64Vec4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaI64Vec4>>()
                        .process_type::<LuaUVec2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaUVec2>>()
                        .process_type::<LuaUVec3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaUVec3>>()
                        .process_type::<LuaUVec4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaUVec4>>()
                        .process_type::<LuaU64Vec2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaU64Vec2>>()
                        .process_type::<LuaU64Vec3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaU64Vec3>>()
                        .process_type::<LuaU64Vec4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaU64Vec4>>()
                        .process_type::<LuaVec2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaVec2>>()
                        .process_type::<LuaVec3A>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaVec3A>>()
                        .process_type::<LuaVec4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaVec4>>()
                        .process_type::<LuaBVec2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaBVec2>>()
                        .process_type::<LuaBVec3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaBVec3>>()
                        .process_type::<LuaBVec4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaBVec4>>()
                        .process_type::<LuaDVec2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDVec2>>()
                        .process_type::<LuaDVec3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDVec3>>()
                        .process_type::<LuaDVec4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDVec4>>()
                        .process_type::<LuaMat2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaMat2>>()
                        .process_type::<LuaMat3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaMat3>>()
                        .process_type::<LuaMat3A>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaMat3A>>()
                        .process_type::<LuaMat4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaMat4>>()
                        .process_type::<LuaDMat2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDMat2>>()
                        .process_type::<LuaDMat3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDMat3>>()
                        .process_type::<LuaDMat4>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDMat4>>()
                        .process_type::<LuaAffine2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAffine2>>()
                        .process_type::<LuaAffine3A>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAffine3A>>()
                        .process_type::<LuaDAffine2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDAffine2>>()
                        .process_type::<LuaDAffine3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDAffine3>>()
                        .process_type::<LuaDQuat>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDQuat>>()
                        .process_type::<LuaEulerRot>()
                        .process_type::<LuaBVec3A>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaBVec3A>>()
                        .process_type::<LuaBVec4A>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaBVec4A>>()
                        .process_type::<LuaSmolStr>()
                        .process_type::<LuaUuid>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaUuid>>()
                },
            ),
        );
    }
}
