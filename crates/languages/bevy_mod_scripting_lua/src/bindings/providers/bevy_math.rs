// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::bevy_reflect::*;
use bevy_mod_scripting_core::{
    AddContextInitializer, StoreDocumentation, bindings::ReflectReference,
};
use crate::{
    bindings::proxy::{
        LuaReflectRefProxy, LuaReflectRefMutProxy, LuaReflectValProxy, LuaValProxy,
        LuaIdentityProxy,
    },
    RegisterLua, tealr::mlu::mlua::IntoLua,
};
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::AspectRatio",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::AspectRatio>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::AspectRatio>,
        other: LuaReflectRefProxy<bevy::math::AspectRatio>,
    ) -> bool;

"#,
    r#"
/// Returns the aspect ratio as a f32 value.

    #[lua()]
    fn ratio(_self: LuaReflectRefProxy<bevy::math::AspectRatio>) -> f32;

"#,
    r#"
/// Returns the inverse of this aspect ratio (height/width).

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::AspectRatio>,
    ) -> LuaReflectValProxy<bevy::math::AspectRatio>;

"#,
    r#"
/// Returns true if the aspect ratio represents a landscape orientation.

    #[lua()]
    fn is_landscape(_self: LuaReflectRefProxy<bevy::math::AspectRatio>) -> bool;

"#,
    r#"
/// Returns true if the aspect ratio represents a portrait orientation.

    #[lua()]
    fn is_portrait(_self: LuaReflectRefProxy<bevy::math::AspectRatio>) -> bool;

"#,
    r#"
/// Returns true if the aspect ratio is exactly square.

    #[lua()]
    fn is_square(_self: LuaReflectRefProxy<bevy::math::AspectRatio>) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::AspectRatio>,
    ) -> LuaReflectValProxy<bevy::math::AspectRatio>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AspectRatio();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::CompassOctant",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::CompassOctant>,
    ) -> LuaReflectValProxy<bevy::math::CompassOctant>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::CompassOctant>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::CompassOctant>,
        other: LuaReflectRefProxy<bevy::math::CompassOctant>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: LuaReflectRefProxy<bevy::math::CompassOctant>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct CompassOctant {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::CompassQuadrant",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::CompassQuadrant>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::CompassQuadrant>,
        other: LuaReflectRefProxy<bevy::math::CompassQuadrant>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::CompassQuadrant>,
    ) -> LuaReflectValProxy<bevy::math::CompassQuadrant>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: LuaReflectRefProxy<bevy::math::CompassQuadrant>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct CompassQuadrant {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Isometry2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Isometry2d>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Isometry2d>,
        rhs: LuaReflectValProxy<bevy::math::Isometry2d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry2d>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Isometry2d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry2d>;

"#,
    r#"
/// Create a two-dimensional isometry from a rotation.

    #[lua()]
    fn from_rotation(
        rotation: LuaReflectValProxy<bevy::math::Rot2>,
    ) -> LuaReflectValProxy<bevy::math::Isometry2d>;

"#,
    r#"
/// Create a two-dimensional isometry from a translation with the given `x` and `y` components.

    #[lua()]
    fn from_xy(x: f32, y: f32) -> LuaReflectValProxy<bevy::math::Isometry2d>;

"#,
    r#"
/// The inverse isometry that undoes this one.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Isometry2d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry2d>;

"#,
    r#"
/// Compute `iso1.inverse() * iso2` in a more efficient way for one-shot cases.
/// If the same isometry is used multiple times, it is more efficient to instead compute
/// the inverse once and use that for each transformation.

    #[lua()]
    fn inverse_mul(
        _self: LuaReflectRefProxy<bevy::math::Isometry2d>,
        rhs: LuaReflectValProxy<bevy::math::Isometry2d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry2d>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Isometry2d>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Isometry2d>,
        other: LuaReflectRefProxy<bevy::math::Isometry2d>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::prelude::Dir2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Isometry2d>,
        rhs: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Isometry2d {
    rotation: bevy::math::Rot2,
    translation: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Isometry3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a three-dimensional isometry from a translation with the given `x`, `y`, and `z` components.

    #[lua()]
    fn from_xyz(x: f32, y: f32, z: f32) -> LuaReflectValProxy<bevy::math::Isometry3d>;

"#,
    r#"
/// The inverse isometry that undoes this one.

    #[lua()]
    fn inverse(
        _self: LuaReflectRefProxy<bevy::math::Isometry3d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry3d>;

"#,
    r#"
/// Compute `iso1.inverse() * iso2` in a more efficient way for one-shot cases.
/// If the same isometry is used multiple times, it is more efficient to instead compute
/// the inverse once and use that for each transformation.

    #[lua()]
    fn inverse_mul(
        _self: LuaReflectRefProxy<bevy::math::Isometry3d>,
        rhs: LuaReflectValProxy<bevy::math::Isometry3d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry3d>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Isometry3d>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Isometry3d>,
        other: LuaReflectRefProxy<bevy::math::Isometry3d>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Isometry3d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry3d>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::prelude::Dir3>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Isometry3d>,
        rhs: LuaReflectValProxy<bevy::math::prelude::Dir3>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Isometry3d>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Isometry3d>,
        rhs: LuaReflectValProxy<bevy::math::Isometry3d>,
    ) -> LuaReflectValProxy<bevy::math::Isometry3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Isometry3d {
    rotation: ReflectReference,
    translation: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Ray2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Ray2d>,
    ) -> LuaReflectValProxy<bevy::math::Ray2d>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Ray2d>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Ray2d>,
        other: LuaReflectRefProxy<bevy::math::Ray2d>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Ray2d {
    origin: ReflectReference,
    direction: bevy::math::prelude::Dir2,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Ray3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Ray3d>,
    ) -> LuaReflectValProxy<bevy::math::Ray3d>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Ray3d>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Ray3d>,
        other: LuaReflectRefProxy<bevy::math::Ray3d>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Ray3d {
    origin: ReflectReference,
    direction: bevy::math::prelude::Dir3,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Rot2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::Rot2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Mul::<bevy::math::Rot2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
        rhs: LuaReflectValProxy<bevy::math::Rot2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Rotates the [`Dir2`] using a [`Rot2`].

    #[lua(as_trait = "std::ops::Mul::<bevy::math::prelude::Dir2>", composite = "mul")]
    fn mul(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
        direction: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir2>;

"#,
    r#"
/// Creates a [`Rot2`] from a counterclockwise angle in radians.
/// # Note
/// The input rotation will always be clamped to the range `(-π, π]` by design.
/// # Example
/// ```
/// # use bevy_math::Rot2;
/// # use approx::assert_relative_eq;
/// # use std::f32::consts::{FRAC_PI_2, PI};
/// let rot1 = Rot2::radians(3.0 * FRAC_PI_2);
/// let rot2 = Rot2::radians(-FRAC_PI_2);
/// assert_relative_eq!(rot1, rot2);
/// let rot3 = Rot2::radians(PI);
/// assert_relative_eq!(rot1 * rot1, rot3);
/// ```

    #[lua()]
    fn radians(radians: f32) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Creates a [`Rot2`] from a counterclockwise angle in degrees.
/// # Note
/// The input rotation will always be clamped to the range `(-180°, 180°]` by design.
/// # Example
/// ```
/// # use bevy_math::Rot2;
/// # use approx::assert_relative_eq;
/// let rot1 = Rot2::degrees(270.0);
/// let rot2 = Rot2::degrees(-90.0);
/// assert_relative_eq!(rot1, rot2);
/// let rot3 = Rot2::degrees(180.0);
/// assert_relative_eq!(rot1 * rot1, rot3);
/// ```

    #[lua()]
    fn degrees(degrees: f32) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Creates a [`Rot2`] from a counterclockwise fraction of a full turn of 360 degrees.
/// # Note
/// The input rotation will always be clamped to the range `(-50%, 50%]` by design.
/// # Example
/// ```
/// # use bevy_math::Rot2;
/// # use approx::assert_relative_eq;
/// let rot1 = Rot2::turn_fraction(0.75);
/// let rot2 = Rot2::turn_fraction(-0.25);
/// assert_relative_eq!(rot1, rot2);
/// let rot3 = Rot2::turn_fraction(0.5);
/// assert_relative_eq!(rot1 * rot1, rot3);
/// ```

    #[lua()]
    fn turn_fraction(fraction: f32) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Creates a [`Rot2`] from the sine and cosine of an angle in radians.
/// The rotation is only valid if `sin * sin + cos * cos == 1.0`.
/// # Panics
/// Panics if `sin * sin + cos * cos != 1.0` when the `glam_assert` feature is enabled.

    #[lua()]
    fn from_sin_cos(sin: f32, cos: f32) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Returns the rotation in radians in the `(-pi, pi]` range.

    #[lua()]
    fn as_radians(_self: LuaReflectValProxy<bevy::math::Rot2>) -> f32;

"#,
    r#"
/// Returns the rotation in degrees in the `(-180, 180]` range.

    #[lua()]
    fn as_degrees(_self: LuaReflectValProxy<bevy::math::Rot2>) -> f32;

"#,
    r#"
/// Returns the rotation as a fraction of a full 360 degree turn.

    #[lua()]
    fn as_turn_fraction(_self: LuaReflectValProxy<bevy::math::Rot2>) -> f32;

"#,
    r#"
/// Returns the sine and cosine of the rotation angle in radians.

    #[lua()]
    fn sin_cos(_self: LuaReflectValProxy<bevy::math::Rot2>) -> (f32, f32);

"#,
    r#"
/// Computes the length or norm of the complex number used to represent the rotation.
/// The length is typically expected to be `1.0`. Unexpectedly denormalized rotations
/// can be a result of incorrect construction or floating point error caused by
/// successive operations.

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::Rot2>) -> f32;

"#,
    r#"
/// Computes the squared length or norm of the complex number used to represent the rotation.
/// This is generally faster than [`Rot2::length()`], as it avoids a square
/// root operation.
/// The length is typically expected to be `1.0`. Unexpectedly denormalized rotations
/// can be a result of incorrect construction or floating point error caused by
/// successive operations.

    #[lua()]
    fn length_squared(_self: LuaReflectValProxy<bevy::math::Rot2>) -> f32;

"#,
    r#"
/// Computes `1.0 / self.length()`.
/// For valid results, `self` must _not_ have a length of zero.

    #[lua()]
    fn length_recip(_self: LuaReflectValProxy<bevy::math::Rot2>) -> f32;

"#,
    r#"
/// Returns `self` with a length of `1.0`.
/// Note that [`Rot2`] should typically already be normalized by design.
/// Manual normalization is only needed when successive operations result in
/// accumulated floating point error, or if the rotation was constructed
/// with invalid values.
/// # Panics
/// Panics if `self` has a length of zero, NaN, or infinity when debug assertions are enabled.

    #[lua()]
    fn normalize(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Returns `self` after an approximate normalization, assuming the value is already nearly normalized.
/// Useful for preventing numerical error accumulation.
/// See [`Dir3::fast_renormalize`](crate::Dir3::fast_renormalize) for an example of when such error accumulation might occur.

    #[lua()]
    fn fast_renormalize(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Returns `true` if the rotation is neither infinite nor NaN.

    #[lua()]
    fn is_finite(_self: LuaReflectValProxy<bevy::math::Rot2>) -> bool;

"#,
    r#"
/// Returns `true` if the rotation is NaN.

    #[lua()]
    fn is_nan(_self: LuaReflectValProxy<bevy::math::Rot2>) -> bool;

"#,
    r#"
/// Returns whether `self` has a length of `1.0` or not.
/// Uses a precision threshold of approximately `1e-4`.

    #[lua()]
    fn is_normalized(_self: LuaReflectValProxy<bevy::math::Rot2>) -> bool;

"#,
    r#"
/// Returns `true` if the rotation is near [`Rot2::IDENTITY`].

    #[lua()]
    fn is_near_identity(_self: LuaReflectValProxy<bevy::math::Rot2>) -> bool;

"#,
    r#"
/// Returns the angle in radians needed to make `self` and `other` coincide.

    #[lua()]
    fn angle_between(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
        other: LuaReflectValProxy<bevy::math::Rot2>,
    ) -> f32;

"#,
    r#"
/// Returns the inverse of the rotation. This is also the conjugate
/// of the unit complex number representing the rotation.

    #[lua()]
    fn inverse(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Performs a linear interpolation between `self` and `rhs` based on
/// the value `s`, and normalizes the rotation afterwards.
/// When `s == 0.0`, the result will be equal to `self`.
/// When `s == 1.0`, the result will be equal to `rhs`.
/// This is slightly more efficient than [`slerp`](Self::slerp), and produces a similar result
/// when the difference between the two rotations is small. At larger differences,
/// the result resembles a kind of ease-in-out effect.
/// If you would like the angular velocity to remain constant, consider using [`slerp`](Self::slerp) instead.
/// # Details
/// `nlerp` corresponds to computing an angle for a point at position `s` on a line drawn
/// between the endpoints of the arc formed by `self` and `rhs` on a unit circle,
/// and normalizing the result afterwards.
/// Note that if the angles are opposite like 0 and π, the line will pass through the origin,
/// and the resulting angle will always be either `self` or `rhs` depending on `s`.
/// If `s` happens to be `0.5` in this case, a valid rotation cannot be computed, and `self`
/// will be returned as a fallback.
/// # Example
/// ```
/// # use bevy_math::Rot2;
/// #
/// let rot1 = Rot2::IDENTITY;
/// let rot2 = Rot2::degrees(135.0);
/// let result1 = rot1.nlerp(rot2, 1.0 / 3.0);
/// assert_eq!(result1.as_degrees(), 28.675055);
/// let result2 = rot1.nlerp(rot2, 0.5);
/// assert_eq!(result2.as_degrees(), 67.5);
/// ```

    #[lua()]
    fn nlerp(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
        end: LuaReflectValProxy<bevy::math::Rot2>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Performs a spherical linear interpolation between `self` and `end`
/// based on the value `s`.
/// This corresponds to interpolating between the two angles at a constant angular velocity.
/// When `s == 0.0`, the result will be equal to `self`.
/// When `s == 1.0`, the result will be equal to `rhs`.
/// If you would like the rotation to have a kind of ease-in-out effect, consider
/// using the slightly more efficient [`nlerp`](Self::nlerp) instead.
/// # Example
/// ```
/// # use bevy_math::Rot2;
/// #
/// let rot1 = Rot2::IDENTITY;
/// let rot2 = Rot2::degrees(135.0);
/// let result1 = rot1.slerp(rot2, 1.0 / 3.0);
/// assert_eq!(result1.as_degrees(), 45.0);
/// let result2 = rot1.slerp(rot2, 0.5);
/// assert_eq!(result2.as_degrees(), 67.5);
/// ```

    #[lua()]
    fn slerp(
        _self: LuaReflectValProxy<bevy::math::Rot2>,
        end: LuaReflectValProxy<bevy::math::Rot2>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::Rot2>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::Rot2>,
        other: LuaReflectRefProxy<bevy::math::Rot2>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Rot2 {
    cos: f32,
    sin: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::prelude::Dir2",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a direction from its `x` and `y` components, assuming the resulting vector is normalized.
/// # Warning
/// The vector produced from `x` and `y` must be normalized, i.e its length must be `1.0`.

    #[lua()]
    fn from_xy_unchecked(
        x: f32,
        y: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir2>;

"#,
    r#"
/// Performs a spherical linear interpolation between `self` and `rhs`
/// based on the value `s`.
/// This corresponds to interpolating between the two directions at a constant angular velocity.
/// When `s == 0.0`, the result will be equal to `self`.
/// When `s == 1.0`, the result will be equal to `rhs`.
/// # Example
/// ```
/// # use bevy_math::Dir2;
/// # use approx::{assert_relative_eq, RelativeEq};
/// #
/// let dir1 = Dir2::X;
/// let dir2 = Dir2::Y;
/// let result1 = dir1.slerp(dir2, 1.0 / 3.0);
/// assert_relative_eq!(result1, Dir2::from_xy(0.75_f32.sqrt(), 0.5).unwrap());
/// let result2 = dir1.slerp(dir2, 0.5);
/// assert_relative_eq!(result2, Dir2::from_xy(0.5_f32.sqrt(), 0.5_f32.sqrt()).unwrap());
/// ```

    #[lua()]
    fn slerp(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
        rhs: LuaReflectValProxy<bevy::math::prelude::Dir2>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir2>;

"#,
    r#"
/// Get the rotation that rotates this direction to `other`.

    #[lua()]
    fn rotation_to(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
        other: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Get the rotation that rotates `other` to this direction.

    #[lua()]
    fn rotation_from(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
        other: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Get the rotation that rotates the X-axis to this direction.

    #[lua()]
    fn rotation_from_x(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Get the rotation that rotates this direction to the X-axis.

    #[lua()]
    fn rotation_to_x(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Get the rotation that rotates the Y-axis to this direction.

    #[lua()]
    fn rotation_from_y(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Get the rotation that rotates this direction to the Y-axis.

    #[lua()]
    fn rotation_to_y(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::Rot2>;

"#,
    r#"
/// Returns `self` after an approximate normalization, assuming the value is already nearly normalized.
/// Useful for preventing numerical error accumulation.
/// See [`Dir3::fast_renormalize`] for an example of when such error accumulation might occur.

    #[lua()]
    fn fast_renormalize(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir2>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::prelude::Dir2>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::Dir2>,
        other: LuaReflectRefProxy<bevy::math::prelude::Dir2>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir2>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir2>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir2>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Dir2();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::prelude::Dir3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::prelude::Dir3>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::Dir3>,
        other: LuaReflectRefProxy<bevy::math::prelude::Dir3>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir3>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3>;

"#,
    r#"
/// Create a direction from its `x`, `y`, and `z` components, assuming the resulting vector is normalized.
/// # Warning
/// The vector produced from `x`, `y`, and `z` must be normalized, i.e its length must be `1.0`.

    #[lua()]
    fn from_xyz_unchecked(
        x: f32,
        y: f32,
        z: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3>;

"#,
    r#"
/// Performs a spherical linear interpolation between `self` and `rhs`
/// based on the value `s`.
/// This corresponds to interpolating between the two directions at a constant angular velocity.
/// When `s == 0.0`, the result will be equal to `self`.
/// When `s == 1.0`, the result will be equal to `rhs`.
/// # Example
/// ```
/// # use bevy_math::Dir3;
/// # use approx::{assert_relative_eq, RelativeEq};
/// #
/// let dir1 = Dir3::X;
/// let dir2 = Dir3::Y;
/// let result1 = dir1.slerp(dir2, 1.0 / 3.0);
/// assert_relative_eq!(
///     result1,
///     Dir3::from_xyz(0.75_f32.sqrt(), 0.5, 0.0).unwrap(),
///     epsilon = 0.000001
/// );
/// let result2 = dir1.slerp(dir2, 0.5);
/// assert_relative_eq!(result2, Dir3::from_xyz(0.5_f32.sqrt(), 0.5_f32.sqrt(), 0.0).unwrap());
/// ```

    #[lua()]
    fn slerp(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir3>,
        rhs: LuaReflectValProxy<bevy::math::prelude::Dir3>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3>;

"#,
    r#"
/// Returns `self` after an approximate normalization, assuming the value is already nearly normalized.
/// Useful for preventing numerical error accumulation.
/// # Example
/// The following seemingly benign code would start accumulating errors over time,
/// leading to `dir` eventually not being normalized anymore.
/// ```
/// # use bevy_math::prelude::*;
/// # let N: usize = 200;
/// let mut dir = Dir3::X;
/// let quaternion = Quat::from_euler(EulerRot::XYZ, 1.0, 2.0, 3.0);
/// for i in 0..N {
///     dir = quaternion * dir;
/// }
/// ```
/// Instead, do the following.
/// ```
/// # use bevy_math::prelude::*;
/// # let N: usize = 200;
/// let mut dir = Dir3::X;
/// let quaternion = Quat::from_euler(EulerRot::XYZ, 1.0, 2.0, 3.0);
/// for i in 0..N {
///     dir = quaternion * dir;
///     dir = dir.fast_renormalize();
/// }
/// ```

    #[lua()]
    fn fast_renormalize(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir3>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::prelude::Dir3>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Dir3();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::prelude::Dir3A",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a direction from its `x`, `y`, and `z` components, assuming the resulting vector is normalized.
/// # Warning
/// The vector produced from `x`, `y`, and `z` must be normalized, i.e its length must be `1.0`.

    #[lua()]
    fn from_xyz_unchecked(
        x: f32,
        y: f32,
        z: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3A>;

"#,
    r#"
/// Performs a spherical linear interpolation between `self` and `rhs`
/// based on the value `s`.
/// This corresponds to interpolating between the two directions at a constant angular velocity.
/// When `s == 0.0`, the result will be equal to `self`.
/// When `s == 1.0`, the result will be equal to `rhs`.
/// # Example
/// ```
/// # use bevy_math::Dir3A;
/// # use approx::{assert_relative_eq, RelativeEq};
/// #
/// let dir1 = Dir3A::X;
/// let dir2 = Dir3A::Y;
/// let result1 = dir1.slerp(dir2, 1.0 / 3.0);
/// assert_relative_eq!(
///     result1,
///     Dir3A::from_xyz(0.75_f32.sqrt(), 0.5, 0.0).unwrap(),
///     epsilon = 0.000001
/// );
/// let result2 = dir1.slerp(dir2, 0.5);
/// assert_relative_eq!(result2, Dir3A::from_xyz(0.5_f32.sqrt(), 0.5_f32.sqrt(), 0.0).unwrap());
/// ```

    #[lua()]
    fn slerp(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir3A>,
        rhs: LuaReflectValProxy<bevy::math::prelude::Dir3A>,
        s: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3A>;

"#,
    r#"
/// Returns `self` after an approximate normalization, assuming the value is already nearly normalized.
/// Useful for preventing numerical error accumulation.
/// See [`Dir3::fast_renormalize`] for an example of when such error accumulation might occur.

    #[lua()]
    fn fast_renormalize(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir3A>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3A>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::prelude::Dir3A>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3A>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::prelude::Dir3A>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::Dir3A>,
        other: LuaReflectRefProxy<bevy::math::prelude::Dir3A>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::prelude::Dir3A>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Dir3A>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Dir3A();
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::prelude::IRect",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a new rectangle from two corner points.
/// The two points do not need to be the minimum and/or maximum corners.
/// They only need to be two opposite corners.
/// # Examples
/// ```
/// # use bevy_math::IRect;
/// let r = IRect::new(0, 4, 10, 6); // w=10 h=2
/// let r = IRect::new(2, 3, 5, -1); // w=3 h=4
/// ```

    #[lua()]
    fn new(
        x0: i32,
        y0: i32,
        x1: i32,
        y1: i32,
    ) -> LuaReflectValProxy<bevy::math::prelude::IRect>;

"#,
    r#"
/// Check if the rectangle is empty.
/// # Examples
/// ```
/// # use bevy_math::{IRect, IVec2};
/// let r = IRect::from_corners(IVec2::ZERO, IVec2::new(0, 1)); // w=0 h=1
/// assert!(r.is_empty());
/// ```

    #[lua()]
    fn is_empty(_self: LuaReflectRefProxy<bevy::math::prelude::IRect>) -> bool;

"#,
    r#"
/// Rectangle width (max.x - min.x).
/// # Examples
/// ```
/// # use bevy_math::IRect;
/// let r = IRect::new(0, 0, 5, 1); // w=5 h=1
/// assert_eq!(r.width(), 5);
/// ```

    #[lua()]
    fn width(_self: LuaReflectRefProxy<bevy::math::prelude::IRect>) -> i32;

"#,
    r#"
/// Rectangle height (max.y - min.y).
/// # Examples
/// ```
/// # use bevy_math::IRect;
/// let r = IRect::new(0, 0, 5, 1); // w=5 h=1
/// assert_eq!(r.height(), 1);
/// ```

    #[lua()]
    fn height(_self: LuaReflectRefProxy<bevy::math::prelude::IRect>) -> i32;

"#,
    r#"
/// Build a new rectangle formed of the union of this rectangle and another rectangle.
/// The union is the smallest rectangle enclosing both rectangles.
/// # Examples
/// ```
/// # use bevy_math::{IRect, IVec2};
/// let r1 = IRect::new(0, 0, 5, 1); // w=5 h=1
/// let r2 = IRect::new(1, -1, 3, 3); // w=2 h=4
/// let r = r1.union(r2);
/// assert_eq!(r.min, IVec2::new(0, -1));
/// assert_eq!(r.max, IVec2::new(5, 3));
/// ```

    #[lua()]
    fn union(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
        other: LuaReflectValProxy<bevy::math::prelude::IRect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::IRect>;

"#,
    r#"
/// Build a new rectangle formed of the intersection of this rectangle and another rectangle.
/// The intersection is the largest rectangle enclosed in both rectangles. If the intersection
/// is empty, this method returns an empty rectangle ([`IRect::is_empty()`] returns `true`), but
/// the actual values of [`IRect::min`] and [`IRect::max`] are implementation-dependent.
/// # Examples
/// ```
/// # use bevy_math::{IRect, IVec2};
/// let r1 = IRect::new(0, 0, 5, 1); // w=5 h=1
/// let r2 = IRect::new(1, -1, 3, 3); // w=2 h=4
/// let r = r1.intersect(r2);
/// assert_eq!(r.min, IVec2::new(1, 0));
/// assert_eq!(r.max, IVec2::new(3, 1));
/// ```

    #[lua()]
    fn intersect(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
        other: LuaReflectValProxy<bevy::math::prelude::IRect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::IRect>;

"#,
    r#"
/// Create a new rectangle by expanding it evenly on all sides.
/// A positive expansion value produces a larger rectangle,
/// while a negative expansion value produces a smaller rectangle.
/// If this would result in zero or negative width or height, [`IRect::EMPTY`] is returned instead.
/// # Examples
/// ```
/// # use bevy_math::{IRect, IVec2};
/// let r = IRect::new(0, 0, 5, 1); // w=5 h=1
/// let r2 = r.inflate(3); // w=11 h=7
/// assert_eq!(r2.min, IVec2::splat(-3));
/// assert_eq!(r2.max, IVec2::new(8, 4));
/// let r = IRect::new(0, -1, 4, 3); // w=4 h=4
/// let r2 = r.inflate(-1); // w=2 h=2
/// assert_eq!(r2.min, IVec2::new(1, 0));
/// assert_eq!(r2.max, IVec2::new(3, 2));
/// ```

    #[lua()]
    fn inflate(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
        expansion: i32,
    ) -> LuaReflectValProxy<bevy::math::prelude::IRect>;

"#,
    r#"
/// Returns self as [`Rect`] (f32)

    #[lua()]
    fn as_rect(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
/// Returns self as [`URect`] (u32)

    #[lua()]
    fn as_urect(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::URect>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
    ) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::prelude::IRect>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
        other: LuaReflectRefProxy<bevy::math::prelude::IRect>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::prelude::IRect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::IRect>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct IRect {
    min: ReflectReference,
    max: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::prelude::Rect",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a new rectangle from two corner points.
/// The two points do not need to be the minimum and/or maximum corners.
/// They only need to be two opposite corners.
/// # Examples
/// ```
/// # use bevy_math::Rect;
/// let r = Rect::new(0., 4., 10., 6.); // w=10 h=2
/// let r = Rect::new(2., 3., 5., -1.); // w=3 h=4
/// ```

    #[lua()]
    fn new(
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
/// Check if the rectangle is empty.
/// # Examples
/// ```
/// # use bevy_math::{Rect, Vec2};
/// let r = Rect::from_corners(Vec2::ZERO, Vec2::new(0., 1.)); // w=0 h=1
/// assert!(r.is_empty());
/// ```

    #[lua()]
    fn is_empty(_self: LuaReflectRefProxy<bevy::math::prelude::Rect>) -> bool;

"#,
    r#"
/// Rectangle width (max.x - min.x).
/// # Examples
/// ```
/// # use bevy_math::Rect;
/// let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
/// assert!((r.width() - 5.).abs() <= 1e-5);
/// ```

    #[lua()]
    fn width(_self: LuaReflectRefProxy<bevy::math::prelude::Rect>) -> f32;

"#,
    r#"
/// Rectangle height (max.y - min.y).
/// # Examples
/// ```
/// # use bevy_math::Rect;
/// let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
/// assert!((r.height() - 1.).abs() <= 1e-5);
/// ```

    #[lua()]
    fn height(_self: LuaReflectRefProxy<bevy::math::prelude::Rect>) -> f32;

"#,
    r#"
/// Build a new rectangle formed of the union of this rectangle and another rectangle.
/// The union is the smallest rectangle enclosing both rectangles.
/// # Examples
/// ```
/// # use bevy_math::{Rect, Vec2};
/// let r1 = Rect::new(0., 0., 5., 1.); // w=5 h=1
/// let r2 = Rect::new(1., -1., 3., 3.); // w=2 h=4
/// let r = r1.union(r2);
/// assert!(r.min.abs_diff_eq(Vec2::new(0., -1.), 1e-5));
/// assert!(r.max.abs_diff_eq(Vec2::new(5., 3.), 1e-5));
/// ```

    #[lua()]
    fn union(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
        other: LuaReflectValProxy<bevy::math::prelude::Rect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
/// Build a new rectangle formed of the intersection of this rectangle and another rectangle.
/// The intersection is the largest rectangle enclosed in both rectangles. If the intersection
/// is empty, this method returns an empty rectangle ([`Rect::is_empty()`] returns `true`), but
/// the actual values of [`Rect::min`] and [`Rect::max`] are implementation-dependent.
/// # Examples
/// ```
/// # use bevy_math::{Rect, Vec2};
/// let r1 = Rect::new(0., 0., 5., 1.); // w=5 h=1
/// let r2 = Rect::new(1., -1., 3., 3.); // w=2 h=4
/// let r = r1.intersect(r2);
/// assert!(r.min.abs_diff_eq(Vec2::new(1., 0.), 1e-5));
/// assert!(r.max.abs_diff_eq(Vec2::new(3., 1.), 1e-5));
/// ```

    #[lua()]
    fn intersect(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
        other: LuaReflectValProxy<bevy::math::prelude::Rect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
/// Create a new rectangle by expanding it evenly on all sides.
/// A positive expansion value produces a larger rectangle,
/// while a negative expansion value produces a smaller rectangle.
/// If this would result in zero or negative width or height, [`Rect::EMPTY`] is returned instead.
/// # Examples
/// ```
/// # use bevy_math::{Rect, Vec2};
/// let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
/// let r2 = r.inflate(3.); // w=11 h=7
/// assert!(r2.min.abs_diff_eq(Vec2::splat(-3.), 1e-5));
/// assert!(r2.max.abs_diff_eq(Vec2::new(8., 4.), 1e-5));
/// let r = Rect::new(0., -1., 6., 7.); // w=6 h=8
/// let r2 = r.inflate(-2.); // w=11 h=7
/// assert!(r2.min.abs_diff_eq(Vec2::new(2., 1.), 1e-5));
/// assert!(r2.max.abs_diff_eq(Vec2::new(4., 5.), 1e-5));
/// ```

    #[lua()]
    fn inflate(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
        expansion: f32,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
/// Build a new rectangle from this one with its coordinates expressed
/// relative to `other` in a normalized ([0..1] x [0..1]) coordinate system.
/// # Examples
/// ```
/// # use bevy_math::{Rect, Vec2};
/// let r = Rect::new(2., 3., 4., 6.);
/// let s = Rect::new(0., 0., 10., 10.);
/// let n = r.normalize(s);
/// assert_eq!(n.min.x, 0.2);
/// assert_eq!(n.min.y, 0.3);
/// assert_eq!(n.max.x, 0.4);
/// assert_eq!(n.max.y, 0.6);
/// ```

    #[lua()]
    fn normalize(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
        other: LuaReflectValProxy<bevy::math::prelude::Rect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
/// Returns self as [`IRect`] (i32)

    #[lua()]
    fn as_irect(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::IRect>;

"#,
    r#"
/// Returns self as [`URect`] (u32)

    #[lua()]
    fn as_urect(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::URect>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::prelude::Rect>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
        other: LuaReflectRefProxy<bevy::math::prelude::Rect>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::prelude::Rect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Rect {
    min: ReflectReference,
    max: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::prelude::URect",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::URect>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::prelude::URect>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
        other: LuaReflectRefProxy<bevy::math::prelude::URect>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
    ) -> ();

"#,
    r#"
/// Create a new rectangle from two corner points.
/// The two points do not need to be the minimum and/or maximum corners.
/// They only need to be two opposite corners.
/// # Examples
/// ```
/// # use bevy_math::URect;
/// let r = URect::new(0, 4, 10, 6); // w=10 h=2
/// let r = URect::new(2, 4, 5, 0); // w=3 h=4
/// ```

    #[lua()]
    fn new(
        x0: u32,
        y0: u32,
        x1: u32,
        y1: u32,
    ) -> LuaReflectValProxy<bevy::math::prelude::URect>;

"#,
    r#"
/// Check if the rectangle is empty.
/// # Examples
/// ```
/// # use bevy_math::{URect, UVec2};
/// let r = URect::from_corners(UVec2::ZERO, UVec2::new(0, 1)); // w=0 h=1
/// assert!(r.is_empty());
/// ```

    #[lua()]
    fn is_empty(_self: LuaReflectRefProxy<bevy::math::prelude::URect>) -> bool;

"#,
    r#"
/// Rectangle width (max.x - min.x).
/// # Examples
/// ```
/// # use bevy_math::URect;
/// let r = URect::new(0, 0, 5, 1); // w=5 h=1
/// assert_eq!(r.width(), 5);
/// ```

    #[lua()]
    fn width(_self: LuaReflectRefProxy<bevy::math::prelude::URect>) -> u32;

"#,
    r#"
/// Rectangle height (max.y - min.y).
/// # Examples
/// ```
/// # use bevy_math::URect;
/// let r = URect::new(0, 0, 5, 1); // w=5 h=1
/// assert_eq!(r.height(), 1);
/// ```

    #[lua()]
    fn height(_self: LuaReflectRefProxy<bevy::math::prelude::URect>) -> u32;

"#,
    r#"
/// Build a new rectangle formed of the union of this rectangle and another rectangle.
/// The union is the smallest rectangle enclosing both rectangles.
/// # Examples
/// ```
/// # use bevy_math::{URect, UVec2};
/// let r1 = URect::new(0, 0, 5, 1); // w=5 h=1
/// let r2 = URect::new(1, 0, 3, 8); // w=2 h=4
/// let r = r1.union(r2);
/// assert_eq!(r.min, UVec2::new(0, 0));
/// assert_eq!(r.max, UVec2::new(5, 8));
/// ```

    #[lua()]
    fn union(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
        other: LuaReflectValProxy<bevy::math::prelude::URect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::URect>;

"#,
    r#"
/// Build a new rectangle formed of the intersection of this rectangle and another rectangle.
/// The intersection is the largest rectangle enclosed in both rectangles. If the intersection
/// is empty, this method returns an empty rectangle ([`URect::is_empty()`] returns `true`), but
/// the actual values of [`URect::min`] and [`URect::max`] are implementation-dependent.
/// # Examples
/// ```
/// # use bevy_math::{URect, UVec2};
/// let r1 = URect::new(0, 0, 2, 2); // w=2 h=2
/// let r2 = URect::new(1, 1, 3, 3); // w=2 h=2
/// let r = r1.intersect(r2);
/// assert_eq!(r.min, UVec2::new(1, 1));
/// assert_eq!(r.max, UVec2::new(2, 2));
/// ```

    #[lua()]
    fn intersect(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
        other: LuaReflectValProxy<bevy::math::prelude::URect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::URect>;

"#,
    r#"
/// Create a new rectangle by expanding it evenly on all sides.
/// A positive expansion value produces a larger rectangle,
/// while a negative expansion value produces a smaller rectangle.
/// If this would result in zero width or height, [`URect::EMPTY`] is returned instead.
/// # Examples
/// ```
/// # use bevy_math::{URect, UVec2};
/// let r = URect::new(4, 4, 6, 6); // w=2 h=2
/// let r2 = r.inflate(1); // w=4 h=4
/// assert_eq!(r2.min, UVec2::splat(3));
/// assert_eq!(r2.max, UVec2::splat(7));
/// let r = URect::new(4, 4, 8, 8); // w=4 h=4
/// let r2 = r.inflate(-1); // w=2 h=2
/// assert_eq!(r2.min, UVec2::splat(5));
/// assert_eq!(r2.max, UVec2::splat(7));
/// ```

    #[lua()]
    fn inflate(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
        expansion: i32,
    ) -> LuaReflectValProxy<bevy::math::prelude::URect>;

"#,
    r#"
/// Returns self as [`Rect`] (f32)

    #[lua()]
    fn as_rect(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::Rect>;

"#,
    r#"
/// Returns self as [`IRect`] (i32)

    #[lua()]
    fn as_irect(
        _self: LuaReflectRefProxy<bevy::math::prelude::URect>,
    ) -> LuaReflectValProxy<bevy::math::prelude::IRect>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct URect {
    min: ReflectReference,
    max: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::Affine3",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[]
)]
pub struct Affine3 {
    matrix3: ReflectReference,
    translation: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::Aabb2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::Aabb2d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::Aabb2d>;

"#,
    r#"
/// Computes the smallest [`BoundingCircle`] containing this [`Aabb2d`].

    #[lua()]
    fn bounding_circle(
        _self: LuaReflectRefProxy<bevy::math::bounding::Aabb2d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingCircle>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Aabb2d {
    min: ReflectReference,
    max: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::BoundingCircle",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Get the radius of the bounding circle

    #[lua()]
    fn radius(_self: LuaReflectRefProxy<bevy::math::bounding::BoundingCircle>) -> f32;

"#,
    r#"
/// Computes the smallest [`Aabb2d`] containing this [`BoundingCircle`].

    #[lua()]
    fn aabb_2d(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingCircle>,
    ) -> LuaReflectValProxy<bevy::math::bounding::Aabb2d>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingCircle>,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingCircle>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BoundingCircle {
    center: ReflectReference,
    circle: bevy::math::primitives::Circle,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Circle",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a new [`Circle`] from a `radius`

    #[lua()]
    fn new(radius: f32) -> LuaReflectValProxy<bevy::math::primitives::Circle>;

"#,
    r#"
/// Get the diameter of the circle

    #[lua()]
    fn diameter(_self: LuaReflectRefProxy<bevy::math::primitives::Circle>) -> f32;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Circle>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Circle>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Circle>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Circle>,
        other: LuaReflectRefProxy<bevy::math::primitives::Circle>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Circle {
    radius: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Annulus",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Annulus>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Annulus>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Annulus>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Annulus>,
        other: LuaReflectRefProxy<bevy::math::primitives::Annulus>,
    ) -> bool;

"#,
    r#"
/// Create a new [`Annulus`] from the radii of the inner and outer circle

    #[lua()]
    fn new(
        inner_radius: f32,
        outer_radius: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Annulus>;

"#,
    r#"
/// Get the diameter of the annulus

    #[lua()]
    fn diameter(_self: LuaReflectRefProxy<bevy::math::primitives::Annulus>) -> f32;

"#,
    r#"
/// Get the thickness of the annulus

    #[lua()]
    fn thickness(_self: LuaReflectRefProxy<bevy::math::primitives::Annulus>) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Annulus {
    inner_circle: bevy::math::primitives::Circle,
    outer_circle: bevy::math::primitives::Circle,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Arc2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a new [`Arc2d`] from a `radius` and a `half_angle`

    #[lua()]
    fn new(
        radius: f32,
        half_angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Arc2d>;

"#,
    r#"
/// Create a new [`Arc2d`] from a `radius` and an `angle` in radians

    #[lua()]
    fn from_radians(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Arc2d>;

"#,
    r#"
/// Create a new [`Arc2d`] from a `radius` and an `angle` in degrees.

    #[lua()]
    fn from_degrees(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Arc2d>;

"#,
    r#"
/// Create a new [`Arc2d`] from a `radius` and a `fraction` of a single turn.
/// For instance, `0.5` turns is a semicircle.

    #[lua()]
    fn from_turns(
        radius: f32,
        fraction: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Arc2d>;

"#,
    r#"
/// Get the angle of the arc

    #[lua()]
    fn angle(_self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>) -> f32;

"#,
    r#"
/// Get the length of the arc

    #[lua()]
    fn length(_self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>) -> f32;

"#,
    r#"
/// Get half the distance between the endpoints (half the length of the chord)

    #[lua()]
    fn half_chord_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>,
    ) -> f32;

"#,
    r#"
/// Get the distance between the endpoints (the length of the chord)

    #[lua()]
    fn chord_length(_self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>) -> f32;

"#,
    r#"
/// Get the length of the apothem of this arc, that is,
/// the distance from the center of the circle to the midpoint of the chord, in the direction of the midpoint of the arc.
/// Equivalently, the [`radius`](Self::radius) minus the [`sagitta`](Self::sagitta).
/// Note that for a [`major`](Self::is_major) arc, the apothem will be negative.

    #[lua()]
    fn apothem(_self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>) -> f32;

"#,
    r#"
/// Get the length of the sagitta of this arc, that is,
/// the length of the line between the midpoints of the arc and its chord.
/// Equivalently, the height of the triangle whose base is the chord and whose apex is the midpoint of the arc.
/// The sagitta is also the sum of the [`radius`](Self::radius) and the [`apothem`](Self::apothem).

    #[lua()]
    fn sagitta(_self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>) -> f32;

"#,
    r#"
/// Produces true if the arc is at most half a circle.
/// **Note:** This is not the negation of [`is_major`](Self::is_major): an exact semicircle is both major and minor.

    #[lua()]
    fn is_minor(_self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>) -> bool;

"#,
    r#"
/// Produces true if the arc is at least half a circle.
/// **Note:** This is not the negation of [`is_minor`](Self::is_minor): an exact semicircle is both major and minor.

    #[lua()]
    fn is_major(_self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Arc2d>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Arc2d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Arc2d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Arc2d>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Arc2d {
    radius: f32,
    half_angle: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Capsule2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Capsule2d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Capsule2d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Capsule2d>,
    ) -> bool;

"#,
    r#"
/// Create a new `Capsule2d` from a radius and length

    #[lua()]
    fn new(
        radius: f32,
        length: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Capsule2d>;

"#,
    r#"
/// Get the part connecting the semicircular ends of the capsule as a [`Rectangle`]

    #[lua()]
    fn to_inner_rectangle(
        _self: LuaReflectRefProxy<bevy::math::primitives::Capsule2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Rectangle>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Capsule2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Capsule2d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Capsule2d {
    radius: f32,
    half_length: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::CircularSector",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a new [`CircularSector`] from a `radius` and an `angle`

    #[lua()]
    fn new(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSector>;

"#,
    r#"
/// Create a new [`CircularSector`] from a `radius` and an `angle` in radians.

    #[lua()]
    fn from_radians(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSector>;

"#,
    r#"
/// Create a new [`CircularSector`] from a `radius` and an `angle` in degrees.

    #[lua()]
    fn from_degrees(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSector>;

"#,
    r#"
/// Create a new [`CircularSector`] from a `radius` and a number of `turns` of a circle.
/// For instance, `0.5` turns is a semicircle.

    #[lua()]
    fn from_turns(
        radius: f32,
        fraction: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSector>;

"#,
    r#"
/// Get half the angle of the sector

    #[lua()]
    fn half_angle(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>,
    ) -> f32;

"#,
    r#"
/// Get the angle of the sector

    #[lua()]
    fn angle(_self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>) -> f32;

"#,
    r#"
/// Get the radius of the sector

    #[lua()]
    fn radius(_self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>) -> f32;

"#,
    r#"
/// Get the length of the arc defining the sector

    #[lua()]
    fn arc_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>,
    ) -> f32;

"#,
    r#"
/// Get half the length of the chord defined by the sector
/// See [`Arc2d::half_chord_length`]

    #[lua()]
    fn half_chord_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>,
    ) -> f32;

"#,
    r#"
/// Get the length of the chord defined by the sector
/// See [`Arc2d::chord_length`]

    #[lua()]
    fn chord_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>,
    ) -> f32;

"#,
    r#"
/// Get the length of the apothem of this sector
/// See [`Arc2d::apothem`]

    #[lua()]
    fn apothem(_self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>) -> f32;

"#,
    r#"
/// Get the length of the sagitta of this sector
/// See [`Arc2d::sagitta`]

    #[lua()]
    fn sagitta(_self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>) -> f32;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSector>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::CircularSector>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSector>,
        other: LuaReflectRefProxy<bevy::math::primitives::CircularSector>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct CircularSector {
    arc: bevy::math::primitives::Arc2d,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::CircularSegment",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSegment>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::CircularSegment>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
        other: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> bool;

"#,
    r#"
/// Create a new [`CircularSegment`] from a `radius`, and an `angle`

    #[lua()]
    fn new(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSegment>;

"#,
    r#"
/// Create a new [`CircularSegment`] from a `radius` and an `angle` in radians.

    #[lua()]
    fn from_radians(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSegment>;

"#,
    r#"
/// Create a new [`CircularSegment`] from a `radius` and an `angle` in degrees.

    #[lua()]
    fn from_degrees(
        radius: f32,
        angle: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSegment>;

"#,
    r#"
/// Create a new [`CircularSegment`] from a `radius` and a number of `turns` of a circle.
/// For instance, `0.5` turns is a semicircle.

    #[lua()]
    fn from_turns(
        radius: f32,
        fraction: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::CircularSegment>;

"#,
    r#"
/// Get the half-angle of the segment

    #[lua()]
    fn half_angle(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> f32;

"#,
    r#"
/// Get the angle of the segment

    #[lua()]
    fn angle(_self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>) -> f32;

"#,
    r#"
/// Get the radius of the segment

    #[lua()]
    fn radius(_self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>) -> f32;

"#,
    r#"
/// Get the length of the arc defining the segment

    #[lua()]
    fn arc_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> f32;

"#,
    r#"
/// Get half the length of the segment's base, also known as its chord

    #[lua()]
    fn half_chord_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> f32;

"#,
    r#"
/// Get the length of the segment's base, also known as its chord

    #[lua()]
    fn chord_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> f32;

"#,
    r#"
/// Get the length of the apothem of this segment,
/// which is the signed distance between the segment and the center of its circle
/// See [`Arc2d::apothem`]

    #[lua()]
    fn apothem(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> f32;

"#,
    r#"
/// Get the length of the sagitta of this segment, also known as its height
/// See [`Arc2d::sagitta`]

    #[lua()]
    fn sagitta(
        _self: LuaReflectRefProxy<bevy::math::primitives::CircularSegment>,
    ) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct CircularSegment {
    arc: bevy::math::primitives::Arc2d,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Ellipse",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Ellipse>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Ellipse>,
        other: LuaReflectRefProxy<bevy::math::primitives::Ellipse>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Ellipse>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Ellipse>;

"#,
    r#"
/// Create a new `Ellipse` from half of its width and height.
/// This corresponds to the two perpendicular radii defining the ellipse.

    #[lua()]
    fn new(
        half_width: f32,
        half_height: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Ellipse>;

"#,
    r#"
/// Returns the [eccentricity](https://en.wikipedia.org/wiki/Eccentricity_(mathematics)) of the ellipse.
/// It can be thought of as a measure of how "stretched" or elongated the ellipse is.
/// The value should be in the range [0, 1), where 0 represents a circle, and 1 represents a parabola.

    #[lua()]
    fn eccentricity(_self: LuaReflectRefProxy<bevy::math::primitives::Ellipse>) -> f32;

"#,
    r#"
/// Get the focal length of the ellipse. This corresponds to the distance between one of the foci and the center of the ellipse.
/// The focal length of an ellipse is related to its eccentricity by `eccentricity = focal_length / semi_major`

    #[lua()]
    fn focal_length(_self: LuaReflectRefProxy<bevy::math::primitives::Ellipse>) -> f32;

"#,
    r#"
/// Returns the length of the semi-major axis. This corresponds to the longest radius of the ellipse.

    #[lua()]
    fn semi_major(_self: LuaReflectRefProxy<bevy::math::primitives::Ellipse>) -> f32;

"#,
    r#"
/// Returns the length of the semi-minor axis. This corresponds to the shortest radius of the ellipse.

    #[lua()]
    fn semi_minor(_self: LuaReflectRefProxy<bevy::math::primitives::Ellipse>) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Ellipse {
    half_size: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Line2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Line2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Line2d>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Line2d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Line2d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Line2d>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Line2d {
    direction: bevy::math::prelude::Dir2,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Plane2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Plane2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Plane2d>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Plane2d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Plane2d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Plane2d>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Plane2d {
    normal: bevy::math::prelude::Dir2,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Rectangle",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Rectangle>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Rectangle>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Rectangle>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Rectangle>,
        other: LuaReflectRefProxy<bevy::math::primitives::Rectangle>,
    ) -> bool;

"#,
    r#"
/// Create a new `Rectangle` from a full width and height

    #[lua()]
    fn new(
        width: f32,
        height: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Rectangle>;

"#,
    r#"
/// Create a `Rectangle` from a single length.
/// The resulting `Rectangle` will be the same size in every direction.

    #[lua()]
    fn from_length(length: f32) -> LuaReflectValProxy<bevy::math::primitives::Rectangle>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Rectangle {
    half_size: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::RegularPolygon",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> LuaReflectValProxy<bevy::math::primitives::RegularPolygon>;

"#,
    r#"
/// Create a new `RegularPolygon`
/// from the radius of the circumcircle and a number of sides
/// # Panics
/// Panics if `circumradius` is negative

    #[lua()]
    fn new(
        circumradius: f32,
        sides: u32,
    ) -> LuaReflectValProxy<bevy::math::primitives::RegularPolygon>;

"#,
    r#"
/// Get the radius of the circumcircle on which all vertices
/// of the regular polygon lie

    #[lua()]
    fn circumradius(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> f32;

"#,
    r#"
/// Get the inradius or apothem of the regular polygon.
/// This is the radius of the largest circle that can
/// be drawn within the polygon

    #[lua()]
    fn inradius(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> f32;

"#,
    r#"
/// Get the length of one side of the regular polygon

    #[lua()]
    fn side_length(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> f32;

"#,
    r#"
/// Get the internal angle of the regular polygon in degrees.
/// This is the angle formed by two adjacent sides with points
/// within the angle being in the interior of the polygon

    #[lua()]
    fn internal_angle_degrees(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> f32;

"#,
    r#"
/// Get the internal angle of the regular polygon in radians.
/// This is the angle formed by two adjacent sides with points
/// within the angle being in the interior of the polygon

    #[lua()]
    fn internal_angle_radians(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> f32;

"#,
    r#"
/// Get the external angle of the regular polygon in degrees.
/// This is the angle formed by two adjacent sides with points
/// within the angle being in the exterior of the polygon

    #[lua()]
    fn external_angle_degrees(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> f32;

"#,
    r#"
/// Get the external angle of the regular polygon in radians.
/// This is the angle formed by two adjacent sides with points
/// within the angle being in the exterior of the polygon

    #[lua()]
    fn external_angle_radians(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> f32;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::RegularPolygon>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
        other: LuaReflectRefProxy<bevy::math::primitives::RegularPolygon>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RegularPolygon {
    circumcircle: bevy::math::primitives::Circle,
    sides: u32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Rhombus",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Rhombus>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Rhombus>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Rhombus>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Rhombus>,
        other: LuaReflectRefProxy<bevy::math::primitives::Rhombus>,
    ) -> bool;

"#,
    r#"
/// Create a new `Rhombus` from a vertical and horizontal diagonal sizes.

    #[lua()]
    fn new(
        horizontal_diagonal: f32,
        vertical_diagonal: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Rhombus>;

"#,
    r#"
/// Create a new `Rhombus` from a side length with all inner angles equal.

    #[lua()]
    fn from_side(side: f32) -> LuaReflectValProxy<bevy::math::primitives::Rhombus>;

"#,
    r#"
/// Create a new `Rhombus` from a given inradius with all inner angles equal.

    #[lua()]
    fn from_inradius(
        inradius: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Rhombus>;

"#,
    r#"
/// Get the length of each side of the rhombus

    #[lua()]
    fn side(_self: LuaReflectRefProxy<bevy::math::primitives::Rhombus>) -> f32;

"#,
    r#"
/// Get the radius of the circumcircle on which all vertices
/// of the rhombus lie

    #[lua()]
    fn circumradius(_self: LuaReflectRefProxy<bevy::math::primitives::Rhombus>) -> f32;

"#,
    r#"
/// Get the radius of the largest circle that can
/// be drawn within the rhombus

    #[lua()]
    fn inradius(_self: LuaReflectRefProxy<bevy::math::primitives::Rhombus>) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Rhombus {
    half_diagonals: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Segment2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a new `Segment2d` from a direction and full length of the segment

    #[lua()]
    fn new(
        direction: LuaReflectValProxy<bevy::math::prelude::Dir2>,
        length: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Segment2d>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Segment2d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Segment2d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Segment2d>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Segment2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Segment2d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Segment2d {
    direction: bevy::math::prelude::Dir2,
    half_length: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Triangle2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Triangle2d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Triangle2d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Triangle2d>,
    ) -> bool;

"#,
    r#"
/// Checks if the triangle is degenerate, meaning it has zero area.
/// A triangle is degenerate if the cross product of the vectors `ab` and `ac` has a length less than `10e-7`.
/// This indicates that the three vertices are collinear or nearly collinear.

    #[lua()]
    fn is_degenerate(
        _self: LuaReflectRefProxy<bevy::math::primitives::Triangle2d>,
    ) -> bool;

"#,
    r#"
/// Checks if the triangle is acute, meaning all angles are less than 90 degrees

    #[lua()]
    fn is_acute(_self: LuaReflectRefProxy<bevy::math::primitives::Triangle2d>) -> bool;

"#,
    r#"
/// Checks if the triangle is obtuse, meaning one angle is greater than 90 degrees

    #[lua()]
    fn is_obtuse(_self: LuaReflectRefProxy<bevy::math::primitives::Triangle2d>) -> bool;

"#,
    r#"
/// Reverse the [`WindingOrder`] of the triangle
/// by swapping the first and last vertices.

    #[lua()]
    fn reverse(_self: LuaReflectRefMutProxy<bevy::math::primitives::Triangle2d>) -> ();

"#,
    r#"
/// This triangle but reversed.

    #[lua()]
    fn reversed(
        _self: LuaReflectValProxy<bevy::math::primitives::Triangle2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Triangle2d>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Triangle2d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Triangle2d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Triangle2d {
    vertices: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::Aabb3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Computes the smallest [`BoundingSphere`] containing this [`Aabb3d`].

    #[lua()]
    fn bounding_sphere(
        _self: LuaReflectRefProxy<bevy::math::bounding::Aabb3d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingSphere>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::Aabb3d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::Aabb3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Aabb3d {
    min: ReflectReference,
    max: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::BoundingSphere",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingSphere>,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingSphere>;

"#,
    r#"
/// Get the radius of the bounding sphere

    #[lua()]
    fn radius(_self: LuaReflectRefProxy<bevy::math::bounding::BoundingSphere>) -> f32;

"#,
    r#"
/// Computes the smallest [`Aabb3d`] containing this [`BoundingSphere`].

    #[lua()]
    fn aabb_3d(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingSphere>,
    ) -> LuaReflectValProxy<bevy::math::bounding::Aabb3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BoundingSphere {
    center: ReflectReference,
    sphere: bevy::math::primitives::Sphere,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Sphere",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Sphere>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Sphere>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Sphere>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Sphere>,
        other: LuaReflectRefProxy<bevy::math::primitives::Sphere>,
    ) -> bool;

"#,
    r#"
/// Create a new [`Sphere`] from a `radius`

    #[lua()]
    fn new(radius: f32) -> LuaReflectValProxy<bevy::math::primitives::Sphere>;

"#,
    r#"
/// Get the diameter of the sphere

    #[lua()]
    fn diameter(_self: LuaReflectRefProxy<bevy::math::primitives::Sphere>) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Sphere {
    radius: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Cuboid",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Create a new `Cuboid` from a full x, y, and z length

    #[lua()]
    fn new(
        x_length: f32,
        y_length: f32,
        z_length: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Cuboid>;

"#,
    r#"
/// Create a `Cuboid` from a single length.
/// The resulting `Cuboid` will be the same size in every direction.

    #[lua()]
    fn from_length(length: f32) -> LuaReflectValProxy<bevy::math::primitives::Cuboid>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Cuboid>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cuboid>,
        other: LuaReflectRefProxy<bevy::math::primitives::Cuboid>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cuboid>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Cuboid>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Cuboid {
    half_size: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Cylinder",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cylinder>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Cylinder>;

"#,
    r#"
/// Create a new `Cylinder` from a radius and full height

    #[lua()]
    fn new(
        radius: f32,
        height: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Cylinder>;

"#,
    r#"
/// Get the base of the cylinder as a [`Circle`]

    #[lua()]
    fn base(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cylinder>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Circle>;

"#,
    r#"
/// Get the surface area of the side of the cylinder,
/// also known as the lateral area

    #[lua()]
    fn lateral_area(_self: LuaReflectRefProxy<bevy::math::primitives::Cylinder>) -> f32;

"#,
    r#"
/// Get the surface area of one base of the cylinder

    #[lua()]
    fn base_area(_self: LuaReflectRefProxy<bevy::math::primitives::Cylinder>) -> f32;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Cylinder>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cylinder>,
        other: LuaReflectRefProxy<bevy::math::primitives::Cylinder>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Cylinder {
    radius: f32,
    half_height: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Capsule3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Capsule3d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Capsule3d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Capsule3d>,
    ) -> bool;

"#,
    r#"
/// Create a new `Capsule3d` from a radius and length

    #[lua()]
    fn new(
        radius: f32,
        length: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Capsule3d>;

"#,
    r#"
/// Get the part connecting the hemispherical ends
/// of the capsule as a [`Cylinder`]

    #[lua()]
    fn to_cylinder(
        _self: LuaReflectRefProxy<bevy::math::primitives::Capsule3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Cylinder>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Capsule3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Capsule3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Capsule3d {
    radius: f32,
    half_length: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Cone",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Cone>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cone>,
        other: LuaReflectRefProxy<bevy::math::primitives::Cone>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cone>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Cone>;

"#,
    r#"
/// Create a new [`Cone`] from a radius and height.

    #[lua()]
    fn new(radius: f32, height: f32) -> LuaReflectValProxy<bevy::math::primitives::Cone>;

"#,
    r#"
/// Get the base of the cone as a [`Circle`]

    #[lua()]
    fn base(
        _self: LuaReflectRefProxy<bevy::math::primitives::Cone>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Circle>;

"#,
    r#"
/// Get the slant height of the cone, the length of the line segment
/// connecting a point on the base to the apex

    #[lua()]
    fn slant_height(_self: LuaReflectRefProxy<bevy::math::primitives::Cone>) -> f32;

"#,
    r#"
/// Get the surface area of the side of the cone,
/// also known as the lateral area

    #[lua()]
    fn lateral_area(_self: LuaReflectRefProxy<bevy::math::primitives::Cone>) -> f32;

"#,
    r#"
/// Get the surface area of the base of the cone

    #[lua()]
    fn base_area(_self: LuaReflectRefProxy<bevy::math::primitives::Cone>) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Cone {
    radius: f32,
    height: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::ConicalFrustum",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::ConicalFrustum>,
    ) -> LuaReflectValProxy<bevy::math::primitives::ConicalFrustum>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::ConicalFrustum>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::ConicalFrustum>,
        other: LuaReflectRefProxy<bevy::math::primitives::ConicalFrustum>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct ConicalFrustum {
    radius_top: f32,
    radius_bottom: f32,
    height: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::InfinitePlane3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::InfinitePlane3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::InfinitePlane3d>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::InfinitePlane3d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::InfinitePlane3d>,
        other: LuaReflectRefProxy<bevy::math::primitives::InfinitePlane3d>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct InfinitePlane3d {
    normal: bevy::math::prelude::Dir3,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Line3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Line3d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Line3d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Line3d>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Line3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Line3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Line3d {
    direction: bevy::math::prelude::Dir3,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Segment3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Segment3d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Segment3d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Segment3d>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Segment3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Segment3d>;

"#,
    r#"
/// Create a new `Segment3d` from a direction and full length of the segment

    #[lua()]
    fn new(
        direction: LuaReflectValProxy<bevy::math::prelude::Dir3>,
        length: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Segment3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Segment3d {
    direction: bevy::math::prelude::Dir3,
    half_length: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Torus",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Torus>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Torus>,
        other: LuaReflectRefProxy<bevy::math::primitives::Torus>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Torus>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Torus>;

"#,
    r#"
/// Create a new `Torus` from an inner and outer radius.
/// The inner radius is the radius of the hole, and the outer radius
/// is the radius of the entire object

    #[lua()]
    fn new(
        inner_radius: f32,
        outer_radius: f32,
    ) -> LuaReflectValProxy<bevy::math::primitives::Torus>;

"#,
    r#"
/// Get the inner radius of the torus.
/// For a ring torus, this corresponds to the radius of the hole,
/// or `major_radius - minor_radius`

    #[lua()]
    fn inner_radius(_self: LuaReflectRefProxy<bevy::math::primitives::Torus>) -> f32;

"#,
    r#"
/// Get the outer radius of the torus.
/// This corresponds to the overall radius of the entire object,
/// or `major_radius + minor_radius`

    #[lua()]
    fn outer_radius(_self: LuaReflectRefProxy<bevy::math::primitives::Torus>) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Torus {
    minor_radius: f32,
    major_radius: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Triangle3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Checks if the triangle is degenerate, meaning it has zero area.
/// A triangle is degenerate if the cross product of the vectors `ab` and `ac` has a length less than `10e-7`.
/// This indicates that the three vertices are collinear or nearly collinear.

    #[lua()]
    fn is_degenerate(
        _self: LuaReflectRefProxy<bevy::math::primitives::Triangle3d>,
    ) -> bool;

"#,
    r#"
/// Checks if the triangle is acute, meaning all angles are less than 90 degrees

    #[lua()]
    fn is_acute(_self: LuaReflectRefProxy<bevy::math::primitives::Triangle3d>) -> bool;

"#,
    r#"
/// Checks if the triangle is obtuse, meaning one angle is greater than 90 degrees

    #[lua()]
    fn is_obtuse(_self: LuaReflectRefProxy<bevy::math::primitives::Triangle3d>) -> bool;

"#,
    r#"
/// Reverse the triangle by swapping the first and last vertices.

    #[lua()]
    fn reverse(_self: LuaReflectRefMutProxy<bevy::math::primitives::Triangle3d>) -> ();

"#,
    r#"
/// This triangle but reversed.

    #[lua()]
    fn reversed(
        _self: LuaReflectValProxy<bevy::math::primitives::Triangle3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Triangle3d>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Triangle3d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Triangle3d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Triangle3d>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Triangle3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Triangle3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Triangle3d {
    vertices: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::RayCast2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Construct a [`RayCast2d`] from a [`Ray2d`] and max distance.

    #[lua()]
    fn from_ray(
        ray: LuaReflectValProxy<bevy::math::Ray2d>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::bounding::RayCast2d>;

"#,
    r#"
/// Get the distance of an intersection with an [`Aabb2d`], if any.

    #[lua()]
    fn aabb_intersection_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::RayCast2d>,
        aabb: LuaReflectRefProxy<bevy::math::bounding::Aabb2d>,
    ) -> std::option::Option<f32>;

"#,
    r#"
/// Get the distance of an intersection with a [`BoundingCircle`], if any.

    #[lua()]
    fn circle_intersection_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::RayCast2d>,
        circle: LuaReflectRefProxy<bevy::math::bounding::BoundingCircle>,
    ) -> std::option::Option<f32>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::RayCast2d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::RayCast2d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RayCast2d {
    ray: bevy::math::Ray2d,
    max: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::AabbCast2d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Construct an [`AabbCast2d`] from an [`Aabb2d`], [`Ray2d`], and max distance.

    #[lua()]
    fn from_ray(
        aabb: LuaReflectValProxy<bevy::math::bounding::Aabb2d>,
        ray: LuaReflectValProxy<bevy::math::Ray2d>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::bounding::AabbCast2d>;

"#,
    r#"
/// Get the distance at which the [`Aabb2d`]s collide, if at all.

    #[lua()]
    fn aabb_collision_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::AabbCast2d>,
        aabb: LuaReflectValProxy<bevy::math::bounding::Aabb2d>,
    ) -> std::option::Option<f32>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::AabbCast2d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::AabbCast2d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AabbCast2d {
    ray: bevy::math::bounding::RayCast2d,
    aabb: bevy::math::bounding::Aabb2d,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::BoundingCircleCast",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingCircleCast>,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingCircleCast>;

"#,
    r#"
/// Construct a [`BoundingCircleCast`] from a [`BoundingCircle`], [`Ray2d`], and max distance.

    #[lua()]
    fn from_ray(
        circle: LuaReflectValProxy<bevy::math::bounding::BoundingCircle>,
        ray: LuaReflectValProxy<bevy::math::Ray2d>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingCircleCast>;

"#,
    r#"
/// Get the distance at which the [`BoundingCircle`]s collide, if at all.

    #[lua()]
    fn circle_collision_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingCircleCast>,
        circle: LuaReflectValProxy<bevy::math::bounding::BoundingCircle>,
    ) -> std::option::Option<f32>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BoundingCircleCast {
    ray: bevy::math::bounding::RayCast2d,
    circle: bevy::math::bounding::BoundingCircle,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::RayCast3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::RayCast3d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::RayCast3d>;

"#,
    r#"
/// Construct a [`RayCast3d`] from a [`Ray3d`] and max distance.

    #[lua()]
    fn from_ray(
        ray: LuaReflectValProxy<bevy::math::Ray3d>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::bounding::RayCast3d>;

"#,
    r#"
/// Get the distance of an intersection with an [`Aabb3d`], if any.

    #[lua()]
    fn aabb_intersection_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::RayCast3d>,
        aabb: LuaReflectRefProxy<bevy::math::bounding::Aabb3d>,
    ) -> std::option::Option<f32>;

"#,
    r#"
/// Get the distance of an intersection with a [`BoundingSphere`], if any.

    #[lua()]
    fn sphere_intersection_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::RayCast3d>,
        sphere: LuaReflectRefProxy<bevy::math::bounding::BoundingSphere>,
    ) -> std::option::Option<f32>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RayCast3d {
    origin: ReflectReference,
    direction: bevy::math::prelude::Dir3A,
    max: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::AabbCast3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::AabbCast3d>,
    ) -> LuaReflectValProxy<bevy::math::bounding::AabbCast3d>;

"#,
    r#"
/// Construct an [`AabbCast3d`] from an [`Aabb3d`], [`Ray3d`], and max distance.

    #[lua()]
    fn from_ray(
        aabb: LuaReflectValProxy<bevy::math::bounding::Aabb3d>,
        ray: LuaReflectValProxy<bevy::math::Ray3d>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::bounding::AabbCast3d>;

"#,
    r#"
/// Get the distance at which the [`Aabb3d`]s collide, if at all.

    #[lua()]
    fn aabb_collision_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::AabbCast3d>,
        aabb: LuaReflectValProxy<bevy::math::bounding::Aabb3d>,
    ) -> std::option::Option<f32>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AabbCast3d {
    ray: bevy::math::bounding::RayCast3d,
    aabb: bevy::math::bounding::Aabb3d,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::bounding::BoundingSphereCast",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingSphereCast>,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingSphereCast>;

"#,
    r#"
/// Construct a [`BoundingSphereCast`] from a [`BoundingSphere`], [`Ray3d`], and max distance.

    #[lua()]
    fn from_ray(
        sphere: LuaReflectValProxy<bevy::math::bounding::BoundingSphere>,
        ray: LuaReflectValProxy<bevy::math::Ray3d>,
        max: f32,
    ) -> LuaReflectValProxy<bevy::math::bounding::BoundingSphereCast>;

"#,
    r#"
/// Get the distance at which the [`BoundingSphere`]s collide, if at all.

    #[lua()]
    fn sphere_collision_at(
        _self: LuaReflectRefProxy<bevy::math::bounding::BoundingSphereCast>,
        sphere: LuaReflectValProxy<bevy::math::bounding::BoundingSphere>,
    ) -> std::option::Option<f32>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct BoundingSphereCast {
    ray: bevy::math::bounding::RayCast3d,
    sphere: bevy::math::bounding::BoundingSphere,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::curve::interval::Interval",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::curve::interval::Interval>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::curve::interval::Interval>,
        other: LuaReflectRefProxy<bevy::math::curve::interval::Interval>,
    ) -> bool;

"#,
    r#"
/// Get the start of this interval.

    #[lua()]
    fn start(_self: LuaReflectValProxy<bevy::math::curve::interval::Interval>) -> f32;

"#,
    r#"
/// Get the end of this interval.

    #[lua()]
    fn end(_self: LuaReflectValProxy<bevy::math::curve::interval::Interval>) -> f32;

"#,
    r#"
/// Get the length of this interval. Note that the result may be infinite (`f32::INFINITY`).

    #[lua()]
    fn length(_self: LuaReflectValProxy<bevy::math::curve::interval::Interval>) -> f32;

"#,
    r#"
/// Returns `true` if this interval is bounded — that is, if both its start and end are finite.
/// Equivalently, an interval is bounded if its length is finite.

    #[lua()]
    fn is_bounded(
        _self: LuaReflectValProxy<bevy::math::curve::interval::Interval>,
    ) -> bool;

"#,
    r#"
/// Returns `true` if this interval has a finite start.

    #[lua()]
    fn has_finite_start(
        _self: LuaReflectValProxy<bevy::math::curve::interval::Interval>,
    ) -> bool;

"#,
    r#"
/// Returns `true` if this interval has a finite end.

    #[lua()]
    fn has_finite_end(
        _self: LuaReflectValProxy<bevy::math::curve::interval::Interval>,
    ) -> bool;

"#,
    r#"
/// Returns `true` if `item` is contained in this interval.

    #[lua()]
    fn contains(
        _self: LuaReflectValProxy<bevy::math::curve::interval::Interval>,
        item: f32,
    ) -> bool;

"#,
    r#"
/// Returns `true` if the other interval is contained in this interval.
/// This is non-strict: each interval will contain itself.

    #[lua()]
    fn contains_interval(
        _self: LuaReflectValProxy<bevy::math::curve::interval::Interval>,
        other: LuaReflectValProxy<bevy::math::curve::interval::Interval>,
    ) -> bool;

"#,
    r#"
/// Clamp the given `value` to lie within this interval.

    #[lua()]
    fn clamp(
        _self: LuaReflectValProxy<bevy::math::curve::interval::Interval>,
        value: f32,
    ) -> f32;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::curve::interval::Interval>,
    ) -> LuaReflectValProxy<bevy::math::curve::interval::Interval>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Interval {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::FloatOrd",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::PartialEq::<bevy::math::FloatOrd>", composite = "eq")]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::FloatOrd>,
        other: LuaReflectRefProxy<bevy::math::FloatOrd>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::FloatOrd>,
    ) -> LuaReflectValProxy<bevy::math::FloatOrd>;

"#,
    r#"

    #[lua(as_trait = "std::ops::Neg", composite = "neg")]
    fn neg(
        _self: LuaReflectValProxy<bevy::math::FloatOrd>,
    ) -> LuaReflectValProxy<bevy::math::FloatOrd>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialOrd::<bevy::math::FloatOrd>")]
    fn lt(
        _self: LuaReflectRefProxy<bevy::math::FloatOrd>,
        other: LuaReflectRefProxy<bevy::math::FloatOrd>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialOrd::<bevy::math::FloatOrd>")]
    fn le(
        _self: LuaReflectRefProxy<bevy::math::FloatOrd>,
        other: LuaReflectRefProxy<bevy::math::FloatOrd>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialOrd::<bevy::math::FloatOrd>")]
    fn gt(
        _self: LuaReflectRefProxy<bevy::math::FloatOrd>,
        other: LuaReflectRefProxy<bevy::math::FloatOrd>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::PartialOrd::<bevy::math::FloatOrd>")]
    fn ge(
        _self: LuaReflectRefProxy<bevy::math::FloatOrd>,
        other: LuaReflectRefProxy<bevy::math::FloatOrd>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct FloatOrd(f32);
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Plane3d",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Plane3d>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Plane3d>,
        other: LuaReflectRefProxy<bevy::math::primitives::Plane3d>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Plane3d>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Plane3d>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Plane3d {
    normal: bevy::math::prelude::Dir3,
    half_size: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::primitives::Tetrahedron",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::primitives::Tetrahedron>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::primitives::Tetrahedron>,
        other: LuaReflectRefProxy<bevy::math::primitives::Tetrahedron>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::primitives::Tetrahedron>,
    ) -> LuaReflectValProxy<bevy::math::primitives::Tetrahedron>;

"#,
    r#"
/// Get the signed volume of the tetrahedron.
/// If it's negative, the normal vector of the face defined by
/// the first three points using the right-hand rule points
/// away from the fourth vertex.

    #[lua()]
    fn signed_volume(
        _self: LuaReflectRefProxy<bevy::math::primitives::Tetrahedron>,
    ) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Tetrahedron {
    vertices: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::math::curve::easing::EaseFunction",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::math::curve::easing::EaseFunction>",
        composite = "eq",
    )]
    fn eq(
        _self: LuaReflectRefProxy<bevy::math::curve::easing::EaseFunction>,
        other: LuaReflectRefProxy<bevy::math::curve::easing::EaseFunction>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: LuaReflectRefProxy<bevy::math::curve::easing::EaseFunction>,
    ) -> LuaReflectValProxy<bevy::math::curve::easing::EaseFunction>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct EaseFunction {}
#[derive(Default)]
pub(crate) struct Globals;
impl crate::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: crate::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> crate::tealr::mlu::mlua::Result<()> {
        instances
            .add_instance(
                "Isometry2d",
                crate::tealr::mlu::UserDataProxy::<LuaIsometry2d>::new,
            )?;
        instances
            .add_instance(
                "Isometry3d",
                crate::tealr::mlu::UserDataProxy::<LuaIsometry3d>::new,
            )?;
        instances
            .add_instance("Rot2", crate::tealr::mlu::UserDataProxy::<LuaRot2>::new)?;
        instances
            .add_instance("Dir2", crate::tealr::mlu::UserDataProxy::<LuaDir2>::new)?;
        instances
            .add_instance("Dir3", crate::tealr::mlu::UserDataProxy::<LuaDir3>::new)?;
        instances
            .add_instance("Dir3A", crate::tealr::mlu::UserDataProxy::<LuaDir3A>::new)?;
        instances
            .add_instance("IRect", crate::tealr::mlu::UserDataProxy::<LuaIRect>::new)?;
        instances
            .add_instance("Rect", crate::tealr::mlu::UserDataProxy::<LuaRect>::new)?;
        instances
            .add_instance("URect", crate::tealr::mlu::UserDataProxy::<LuaURect>::new)?;
        instances
            .add_instance("Circle", crate::tealr::mlu::UserDataProxy::<LuaCircle>::new)?;
        instances
            .add_instance(
                "Annulus",
                crate::tealr::mlu::UserDataProxy::<LuaAnnulus>::new,
            )?;
        instances
            .add_instance("Arc2d", crate::tealr::mlu::UserDataProxy::<LuaArc2d>::new)?;
        instances
            .add_instance(
                "Capsule2d",
                crate::tealr::mlu::UserDataProxy::<LuaCapsule2d>::new,
            )?;
        instances
            .add_instance(
                "CircularSector",
                crate::tealr::mlu::UserDataProxy::<LuaCircularSector>::new,
            )?;
        instances
            .add_instance(
                "CircularSegment",
                crate::tealr::mlu::UserDataProxy::<LuaCircularSegment>::new,
            )?;
        instances
            .add_instance(
                "Ellipse",
                crate::tealr::mlu::UserDataProxy::<LuaEllipse>::new,
            )?;
        instances
            .add_instance(
                "Rectangle",
                crate::tealr::mlu::UserDataProxy::<LuaRectangle>::new,
            )?;
        instances
            .add_instance(
                "RegularPolygon",
                crate::tealr::mlu::UserDataProxy::<LuaRegularPolygon>::new,
            )?;
        instances
            .add_instance(
                "Rhombus",
                crate::tealr::mlu::UserDataProxy::<LuaRhombus>::new,
            )?;
        instances
            .add_instance(
                "Segment2d",
                crate::tealr::mlu::UserDataProxy::<LuaSegment2d>::new,
            )?;
        instances
            .add_instance("Sphere", crate::tealr::mlu::UserDataProxy::<LuaSphere>::new)?;
        instances
            .add_instance("Cuboid", crate::tealr::mlu::UserDataProxy::<LuaCuboid>::new)?;
        instances
            .add_instance(
                "Cylinder",
                crate::tealr::mlu::UserDataProxy::<LuaCylinder>::new,
            )?;
        instances
            .add_instance(
                "Capsule3d",
                crate::tealr::mlu::UserDataProxy::<LuaCapsule3d>::new,
            )?;
        instances
            .add_instance("Cone", crate::tealr::mlu::UserDataProxy::<LuaCone>::new)?;
        instances
            .add_instance(
                "Segment3d",
                crate::tealr::mlu::UserDataProxy::<LuaSegment3d>::new,
            )?;
        instances
            .add_instance("Torus", crate::tealr::mlu::UserDataProxy::<LuaTorus>::new)?;
        instances
            .add_instance(
                "RayCast2d",
                crate::tealr::mlu::UserDataProxy::<LuaRayCast2d>::new,
            )?;
        instances
            .add_instance(
                "AabbCast2d",
                crate::tealr::mlu::UserDataProxy::<LuaAabbCast2d>::new,
            )?;
        instances
            .add_instance(
                "BoundingCircleCast",
                crate::tealr::mlu::UserDataProxy::<LuaBoundingCircleCast>::new,
            )?;
        instances
            .add_instance(
                "RayCast3d",
                crate::tealr::mlu::UserDataProxy::<LuaRayCast3d>::new,
            )?;
        instances
            .add_instance(
                "AabbCast3d",
                crate::tealr::mlu::UserDataProxy::<LuaAabbCast3d>::new,
            )?;
        instances
            .add_instance(
                "BoundingSphereCast",
                crate::tealr::mlu::UserDataProxy::<LuaBoundingSphereCast>::new,
            )?;
        Ok(())
    }
}
fn bevy_math_context_initializer(
    _: &bevy_mod_scripting_core::script::ScriptId,
    ctx: &mut crate::prelude::Lua,
) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
    crate::tealr::mlu::set_global_env(Globals, ctx)?;
    Ok(())
}
pub struct BevyMathScriptingPlugin;
impl bevy::app::Plugin for BevyMathScriptingPlugin {
    fn build(&self, app: &mut bevy::prelude::App) {
        app.register_lua_proxy::<bevy::math::AspectRatio>();
        app.register_lua_proxy::<bevy::math::CompassOctant>();
        app.register_lua_proxy::<bevy::math::CompassQuadrant>();
        app.register_lua_proxy::<bevy::math::Isometry2d>();
        app.register_lua_proxy::<bevy::math::Isometry3d>();
        app.register_lua_proxy::<bevy::math::Ray2d>();
        app.register_lua_proxy::<bevy::math::Ray3d>();
        app.register_lua_proxy::<bevy::math::Rot2>();
        app.register_lua_proxy::<bevy::math::prelude::Dir2>();
        app.register_lua_proxy::<bevy::math::prelude::Dir3>();
        app.register_lua_proxy::<bevy::math::prelude::Dir3A>();
        app.register_lua_proxy::<bevy::math::prelude::IRect>();
        app.register_lua_proxy::<bevy::math::prelude::Rect>();
        app.register_lua_proxy::<bevy::math::prelude::URect>();
        app.register_lua_proxy::<bevy::math::Affine3>();
        app.register_lua_proxy::<bevy::math::bounding::Aabb2d>();
        app.register_lua_proxy::<bevy::math::bounding::BoundingCircle>();
        app.register_lua_proxy::<bevy::math::primitives::Circle>();
        app.register_lua_proxy::<bevy::math::primitives::Annulus>();
        app.register_lua_proxy::<bevy::math::primitives::Arc2d>();
        app.register_lua_proxy::<bevy::math::primitives::Capsule2d>();
        app.register_lua_proxy::<bevy::math::primitives::CircularSector>();
        app.register_lua_proxy::<bevy::math::primitives::CircularSegment>();
        app.register_lua_proxy::<bevy::math::primitives::Ellipse>();
        app.register_lua_proxy::<bevy::math::primitives::Line2d>();
        app.register_lua_proxy::<bevy::math::primitives::Plane2d>();
        app.register_lua_proxy::<bevy::math::primitives::Rectangle>();
        app.register_lua_proxy::<bevy::math::primitives::RegularPolygon>();
        app.register_lua_proxy::<bevy::math::primitives::Rhombus>();
        app.register_lua_proxy::<bevy::math::primitives::Segment2d>();
        app.register_lua_proxy::<bevy::math::primitives::Triangle2d>();
        app.register_lua_proxy::<bevy::math::bounding::Aabb3d>();
        app.register_lua_proxy::<bevy::math::bounding::BoundingSphere>();
        app.register_lua_proxy::<bevy::math::primitives::Sphere>();
        app.register_lua_proxy::<bevy::math::primitives::Cuboid>();
        app.register_lua_proxy::<bevy::math::primitives::Cylinder>();
        app.register_lua_proxy::<bevy::math::primitives::Capsule3d>();
        app.register_lua_proxy::<bevy::math::primitives::Cone>();
        app.register_lua_proxy::<bevy::math::primitives::ConicalFrustum>();
        app.register_lua_proxy::<bevy::math::primitives::InfinitePlane3d>();
        app.register_lua_proxy::<bevy::math::primitives::Line3d>();
        app.register_lua_proxy::<bevy::math::primitives::Segment3d>();
        app.register_lua_proxy::<bevy::math::primitives::Torus>();
        app.register_lua_proxy::<bevy::math::primitives::Triangle3d>();
        app.register_lua_proxy::<bevy::math::bounding::RayCast2d>();
        app.register_lua_proxy::<bevy::math::bounding::AabbCast2d>();
        app.register_lua_proxy::<bevy::math::bounding::BoundingCircleCast>();
        app.register_lua_proxy::<bevy::math::bounding::RayCast3d>();
        app.register_lua_proxy::<bevy::math::bounding::AabbCast3d>();
        app.register_lua_proxy::<bevy::math::bounding::BoundingSphereCast>();
        app.register_lua_proxy::<bevy::math::curve::interval::Interval>();
        app.register_lua_proxy::<bevy::math::FloatOrd>();
        app.register_lua_proxy::<bevy::math::primitives::Plane3d>();
        app.register_lua_proxy::<bevy::math::primitives::Tetrahedron>();
        app.register_lua_proxy::<bevy::math::curve::easing::EaseFunction>();
        app.add_context_initializer::<()>(bevy_math_context_initializer);
        app.add_documentation_fragment(
            crate::docs::LuaDocumentationFragment::new(
                "BevyMathAPI",
                |tw| {
                    tw.document_global_instance::<Globals>()
                        .expect("Something went wrong documenting globals")
                        .process_type::<LuaAspectRatio>()
                        .process_type::<LuaCompassOctant>()
                        .process_type::<LuaCompassQuadrant>()
                        .process_type::<LuaIsometry2d>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaIsometry2d>,
                        >()
                        .process_type::<LuaIsometry3d>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaIsometry3d>,
                        >()
                        .process_type::<LuaRay2d>()
                        .process_type::<LuaRay3d>()
                        .process_type::<LuaRot2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaRot2>>()
                        .process_type::<LuaDir2>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDir2>>()
                        .process_type::<LuaDir3>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDir3>>()
                        .process_type::<LuaDir3A>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaDir3A>>()
                        .process_type::<LuaIRect>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaIRect>>()
                        .process_type::<LuaRect>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaRect>>()
                        .process_type::<LuaURect>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaURect>>()
                        .process_type::<LuaAffine3>()
                        .process_type::<LuaAabb2d>()
                        .process_type::<LuaBoundingCircle>()
                        .process_type::<LuaCircle>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaCircle>>()
                        .process_type::<LuaAnnulus>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaAnnulus>>()
                        .process_type::<LuaArc2d>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaArc2d>>()
                        .process_type::<LuaCapsule2d>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaCapsule2d>>()
                        .process_type::<LuaCircularSector>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaCircularSector>,
                        >()
                        .process_type::<LuaCircularSegment>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaCircularSegment>,
                        >()
                        .process_type::<LuaEllipse>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaEllipse>>()
                        .process_type::<LuaLine2d>()
                        .process_type::<LuaPlane2d>()
                        .process_type::<LuaRectangle>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaRectangle>>()
                        .process_type::<LuaRegularPolygon>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaRegularPolygon>,
                        >()
                        .process_type::<LuaRhombus>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaRhombus>>()
                        .process_type::<LuaSegment2d>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaSegment2d>>()
                        .process_type::<LuaTriangle2d>()
                        .process_type::<LuaAabb3d>()
                        .process_type::<LuaBoundingSphere>()
                        .process_type::<LuaSphere>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaSphere>>()
                        .process_type::<LuaCuboid>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaCuboid>>()
                        .process_type::<LuaCylinder>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaCylinder>>()
                        .process_type::<LuaCapsule3d>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaCapsule3d>>()
                        .process_type::<LuaCone>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaCone>>()
                        .process_type::<LuaConicalFrustum>()
                        .process_type::<LuaInfinitePlane3d>()
                        .process_type::<LuaLine3d>()
                        .process_type::<LuaSegment3d>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaSegment3d>>()
                        .process_type::<LuaTorus>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaTorus>>()
                        .process_type::<LuaTriangle3d>()
                        .process_type::<LuaRayCast2d>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaRayCast2d>>()
                        .process_type::<LuaAabbCast2d>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaAabbCast2d>,
                        >()
                        .process_type::<LuaBoundingCircleCast>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaBoundingCircleCast>,
                        >()
                        .process_type::<LuaRayCast3d>()
                        .process_type::<crate::tealr::mlu::UserDataProxy<LuaRayCast3d>>()
                        .process_type::<LuaAabbCast3d>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaAabbCast3d>,
                        >()
                        .process_type::<LuaBoundingSphereCast>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaBoundingSphereCast>,
                        >()
                        .process_type::<LuaInterval>()
                        .process_type::<LuaFloatOrd>()
                        .process_type::<LuaPlane3d>()
                        .process_type::<LuaTetrahedron>()
                        .process_type::<LuaEaseFunction>()
                },
            ),
        );
    }
}
