// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::bevy_ecs::*;
use super::bevy_reflect::*;
use super::bevy_core::*;
use super::bevy_math::*;
use bevy_mod_scripting_core::{
    AddContextInitializer, StoreDocumentation, bindings::ReflectReference,
};
use crate::{
    bindings::proxy::{
        LuaReflectRefProxy, LuaReflectRefMutProxy, LuaReflectValProxy, LuaValProxy,
        LuaIdentityProxy,
    },
    type_data::RegisterLua, tealr::mlu::mlua::IntoLua,
};
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::Gamepad",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Returns the USB vendor ID as assigned by the USB-IF, if available.

    #[lua()]
    fn vendor_id(_self: Ref<bevy::input::gamepad::Gamepad>) -> std::option::Option<u16>;

"#,
    r#"
/// Returns the USB product ID as assigned by the [vendor], if available.
/// [vendor]: Self::vendor_id

    #[lua()]
    fn product_id(_self: Ref<bevy::input::gamepad::Gamepad>) -> std::option::Option<u16>;

"#,
    r#"
/// Returns `true` if the [`GamepadButton`] has been pressed.

    #[lua()]
    fn pressed(
        _self: Ref<bevy::input::gamepad::Gamepad>,
        button_type: Val<bevy::input::gamepad::GamepadButton>,
    ) -> bool;

"#,
    r#"
/// Returns `true` if the [`GamepadButton`] has been pressed during the current frame.
/// Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_released`].

    #[lua()]
    fn just_pressed(
        _self: Ref<bevy::input::gamepad::Gamepad>,
        button_type: Val<bevy::input::gamepad::GamepadButton>,
    ) -> bool;

"#,
    r#"
/// Returns `true` if the [`GamepadButton`] has been released during the current frame.
/// Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_pressed`].

    #[lua()]
    fn just_released(
        _self: Ref<bevy::input::gamepad::Gamepad>,
        button_type: Val<bevy::input::gamepad::GamepadButton>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Gamepad {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadAxis",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::gamepad::GamepadAxis>) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadAxis>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadAxis>,
        other: Ref<bevy::input::gamepad::GamepadAxis>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadAxis>,
    ) -> Val<bevy::input::gamepad::GamepadAxis>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadAxis {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadButton",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadButton>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadButton>,
        other: Ref<bevy::input::gamepad::GamepadButton>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadButton>,
    ) -> Val<bevy::input::gamepad::GamepadButton>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::input::gamepad::GamepadButton>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadButton {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadSettings",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadSettings>,
    ) -> Val<bevy::input::gamepad::GamepadSettings>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadSettings {
    default_button_settings: bevy::input::gamepad::ButtonSettings,
    default_axis_settings: bevy::input::gamepad::AxisSettings,
    default_button_axis_settings: bevy::input::gamepad::ButtonAxisSettings,
    button_settings: ReflectReference,
    axis_settings: ReflectReference,
    button_axis_settings: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::keyboard::KeyCode",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::keyboard::KeyCode>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::keyboard::KeyCode>,
        other: Ref<bevy::input::keyboard::KeyCode>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::keyboard::KeyCode>,
    ) -> Val<bevy::input::keyboard::KeyCode>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::keyboard::KeyCode>) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct KeyCode {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::mouse::MouseButton",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::mouse::MouseButton>) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::mouse::MouseButton>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::mouse::MouseButton>,
        other: Ref<bevy::input::mouse::MouseButton>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::mouse::MouseButton>,
    ) -> Val<bevy::input::mouse::MouseButton>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct MouseButton {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::touch::TouchInput",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::touch::TouchInput>,
    ) -> Val<bevy::input::touch::TouchInput>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::touch::TouchInput>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::touch::TouchInput>,
        other: Ref<bevy::input::touch::TouchInput>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct TouchInput {
    phase: bevy::input::touch::TouchPhase,
    position: ReflectReference,
    window: ReflectReference,
    force: ReflectReference,
    id: u64,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::keyboard::KeyboardFocusLost",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::keyboard::KeyboardFocusLost>,
    ) -> Val<bevy::input::keyboard::KeyboardFocusLost>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::input::keyboard::KeyboardFocusLost>,
    ) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::keyboard::KeyboardFocusLost>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::keyboard::KeyboardFocusLost>,
        other: Ref<bevy::input::keyboard::KeyboardFocusLost>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct KeyboardFocusLost {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::keyboard::KeyboardInput",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::keyboard::KeyboardInput>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::keyboard::KeyboardInput>,
        other: Ref<bevy::input::keyboard::KeyboardInput>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::keyboard::KeyboardInput>,
    ) -> Val<bevy::input::keyboard::KeyboardInput>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::input::keyboard::KeyboardInput>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct KeyboardInput {
    key_code: bevy::input::keyboard::KeyCode,
    logical_key: bevy::input::keyboard::Key,
    state: bevy::input::ButtonState,
    repeat: bool,
    window: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::mouse::AccumulatedMouseMotion",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::mouse::AccumulatedMouseMotion>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::mouse::AccumulatedMouseMotion>,
        other: Ref<bevy::input::mouse::AccumulatedMouseMotion>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::mouse::AccumulatedMouseMotion>,
    ) -> Val<bevy::input::mouse::AccumulatedMouseMotion>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AccumulatedMouseMotion {
    delta: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::mouse::AccumulatedMouseScroll",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::mouse::AccumulatedMouseScroll>,
    ) -> Val<bevy::input::mouse::AccumulatedMouseScroll>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::mouse::AccumulatedMouseScroll>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::mouse::AccumulatedMouseScroll>,
        other: Ref<bevy::input::mouse::AccumulatedMouseScroll>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AccumulatedMouseScroll {
    unit: bevy::input::mouse::MouseScrollUnit,
    delta: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::mouse::MouseButtonInput",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::mouse::MouseButtonInput>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::mouse::MouseButtonInput>,
        other: Ref<bevy::input::mouse::MouseButtonInput>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::mouse::MouseButtonInput>,
    ) -> Val<bevy::input::mouse::MouseButtonInput>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::input::mouse::MouseButtonInput>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct MouseButtonInput {
    button: bevy::input::mouse::MouseButton,
    state: bevy::input::ButtonState,
    window: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::mouse::MouseMotion",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::mouse::MouseMotion>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::mouse::MouseMotion>,
        other: Ref<bevy::input::mouse::MouseMotion>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::mouse::MouseMotion>,
    ) -> Val<bevy::input::mouse::MouseMotion>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct MouseMotion {
    delta: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::mouse::MouseWheel",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::mouse::MouseWheel>,
    ) -> Val<bevy::input::mouse::MouseWheel>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::mouse::MouseWheel>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::mouse::MouseWheel>,
        other: Ref<bevy::input::mouse::MouseWheel>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct MouseWheel {
    unit: bevy::input::mouse::MouseScrollUnit,
    x: f32,
    y: f32,
    window: ReflectReference,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadAxisChangedEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadAxisChangedEvent>,
    ) -> Val<bevy::input::gamepad::GamepadAxisChangedEvent>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadAxisChangedEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadAxisChangedEvent>,
        other: Ref<bevy::input::gamepad::GamepadAxisChangedEvent>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadAxisChangedEvent {
    entity: ReflectReference,
    axis: bevy::input::gamepad::GamepadAxis,
    value: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadButtonChangedEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadButtonChangedEvent>,
    ) -> Val<bevy::input::gamepad::GamepadButtonChangedEvent>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadButtonChangedEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadButtonChangedEvent>,
        other: Ref<bevy::input::gamepad::GamepadButtonChangedEvent>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadButtonChangedEvent {
    entity: ReflectReference,
    button: bevy::input::gamepad::GamepadButton,
    state: bevy::input::ButtonState,
    value: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadButtonStateChangedEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadButtonStateChangedEvent>,
    ) -> Val<bevy::input::gamepad::GamepadButtonStateChangedEvent>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadButtonStateChangedEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadButtonStateChangedEvent>,
        other: Ref<bevy::input::gamepad::GamepadButtonStateChangedEvent>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::input::gamepad::GamepadButtonStateChangedEvent>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadButtonStateChangedEvent {
    entity: ReflectReference,
    button: bevy::input::gamepad::GamepadButton,
    state: bevy::input::ButtonState,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadConnection",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadConnection>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadConnection>,
        other: Ref<bevy::input::gamepad::GamepadConnection>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadConnection>,
    ) -> Val<bevy::input::gamepad::GamepadConnection>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadConnection {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadConnectionEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Is the gamepad connected?

    #[lua()]
    fn connected(_self: Ref<bevy::input::gamepad::GamepadConnectionEvent>) -> bool;

"#,
    r#"
/// Is the gamepad disconnected?

    #[lua()]
    fn disconnected(_self: Ref<bevy::input::gamepad::GamepadConnectionEvent>) -> bool;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadConnectionEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadConnectionEvent>,
        other: Ref<bevy::input::gamepad::GamepadConnectionEvent>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadConnectionEvent>,
    ) -> Val<bevy::input::gamepad::GamepadConnectionEvent>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadConnectionEvent {
    gamepad: ReflectReference,
    connection: bevy::input::gamepad::GamepadConnection,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadEvent>,
        other: Ref<bevy::input::gamepad::GamepadEvent>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadEvent>,
    ) -> Val<bevy::input::gamepad::GamepadEvent>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadEvent {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadInput",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::gamepad::GamepadInput>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadInput>,
    ) -> Val<bevy::input::gamepad::GamepadInput>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadInput>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadInput>,
        other: Ref<bevy::input::gamepad::GamepadInput>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadInput {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadRumbleRequest",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadRumbleRequest>,
    ) -> Val<bevy::input::gamepad::GamepadRumbleRequest>;

"#]
)]
pub struct GamepadRumbleRequest {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::RawGamepadAxisChangedEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::RawGamepadAxisChangedEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::RawGamepadAxisChangedEvent>,
        other: Ref<bevy::input::gamepad::RawGamepadAxisChangedEvent>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::RawGamepadAxisChangedEvent>,
    ) -> Val<bevy::input::gamepad::RawGamepadAxisChangedEvent>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RawGamepadAxisChangedEvent {
    gamepad: ReflectReference,
    axis: bevy::input::gamepad::GamepadAxis,
    value: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::RawGamepadButtonChangedEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::RawGamepadButtonChangedEvent>,
    ) -> Val<bevy::input::gamepad::RawGamepadButtonChangedEvent>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::RawGamepadButtonChangedEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::RawGamepadButtonChangedEvent>,
        other: Ref<bevy::input::gamepad::RawGamepadButtonChangedEvent>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RawGamepadButtonChangedEvent {
    gamepad: ReflectReference,
    button: bevy::input::gamepad::GamepadButton,
    value: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::RawGamepadEvent",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::RawGamepadEvent>,
    ) -> Val<bevy::input::gamepad::RawGamepadEvent>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::RawGamepadEvent>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::RawGamepadEvent>,
        other: Ref<bevy::input::gamepad::RawGamepadEvent>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RawGamepadEvent {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gestures::PinchGesture",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gestures::PinchGesture>,
    ) -> Val<bevy::input::gestures::PinchGesture>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gestures::PinchGesture>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gestures::PinchGesture>,
        other: Ref<bevy::input::gestures::PinchGesture>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct PinchGesture(f32);
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gestures::RotationGesture",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gestures::RotationGesture>,
    ) -> Val<bevy::input::gestures::RotationGesture>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gestures::RotationGesture>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gestures::RotationGesture>,
        other: Ref<bevy::input::gestures::RotationGesture>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct RotationGesture(f32);
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gestures::DoubleTapGesture",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gestures::DoubleTapGesture>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gestures::DoubleTapGesture>,
        other: Ref<bevy::input::gestures::DoubleTapGesture>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gestures::DoubleTapGesture>,
    ) -> Val<bevy::input::gestures::DoubleTapGesture>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct DoubleTapGesture {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gestures::PanGesture",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gestures::PanGesture>,
    ) -> Val<bevy::input::gestures::PanGesture>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gestures::PanGesture>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gestures::PanGesture>,
        other: Ref<bevy::input::gestures::PanGesture>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct PanGesture(ReflectReference);
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::ButtonState",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::ButtonState>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::ButtonState>,
        other: Ref<bevy::input::ButtonState>,
    ) -> bool;

"#,
    r#"
/// Is this button pressed?

    #[lua()]
    fn is_pressed(_self: Ref<bevy::input::ButtonState>) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::ButtonState>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(_self: Ref<bevy::input::ButtonState>) -> Val<bevy::input::ButtonState>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct ButtonState {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::ButtonSettings",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::ButtonSettings>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::ButtonSettings>,
        other: Ref<bevy::input::gamepad::ButtonSettings>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::ButtonSettings>,
    ) -> Val<bevy::input::gamepad::ButtonSettings>;

"#,
    r#"
/// Returns `true` if the button is pressed.
/// A button is considered pressed if the `value` passed is greater than or equal to the press threshold.

    #[lua()]
    fn is_pressed(_self: Ref<bevy::input::gamepad::ButtonSettings>, value: f32) -> bool;

"#,
    r#"
/// Returns `true` if the button is released.
/// A button is considered released if the `value` passed is lower than or equal to the release threshold.

    #[lua()]
    fn is_released(_self: Ref<bevy::input::gamepad::ButtonSettings>, value: f32) -> bool;

"#,
    r#"
/// Get the button input threshold above which the button is considered pressed.

    #[lua()]
    fn press_threshold(_self: Ref<bevy::input::gamepad::ButtonSettings>) -> f32;

"#,
    r#"
/// Try to set the button input threshold above which the button is considered pressed.
/// If the value passed is outside the range [release threshold..=1.0], the value will not be changed.
/// Returns the new value of the press threshold.

    #[lua()]
    fn set_press_threshold(
        _self: Mut<bevy::input::gamepad::ButtonSettings>,
        value: f32,
    ) -> f32;

"#,
    r#"
/// Get the button input threshold below which the button is considered released.

    #[lua()]
    fn release_threshold(_self: Ref<bevy::input::gamepad::ButtonSettings>) -> f32;

"#,
    r#"
/// Try to set the button input threshold below which the button is considered released. If the
/// value passed is outside the range [0.0..=press threshold], the value will not be changed.
/// Returns the new value of the release threshold.

    #[lua()]
    fn set_release_threshold(
        _self: Mut<bevy::input::gamepad::ButtonSettings>,
        value: f32,
    ) -> f32;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct ButtonSettings {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::AxisSettings",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::AxisSettings>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::AxisSettings>,
        other: Ref<bevy::input::gamepad::AxisSettings>,
    ) -> bool;

"#,
    r#"
/// Get the value above which inputs will be rounded up to 1.0.

    #[lua()]
    fn livezone_upperbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32;

"#,
    r#"
/// Try to set the value above which inputs will be rounded up to 1.0.
/// If the value passed is negative or less than `deadzone_upperbound`,
/// the value will not be changed.
/// Returns the new value of `livezone_upperbound`.

    #[lua()]
    fn set_livezone_upperbound(
        _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32;

"#,
    r#"
/// Get the value below which positive inputs will be rounded down to 0.0.

    #[lua()]
    fn deadzone_upperbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32;

"#,
    r#"
/// Try to set the value below which positive inputs will be rounded down to 0.0.
/// If the value passed is negative or greater than `livezone_upperbound`,
/// the value will not be changed.
/// Returns the new value of `deadzone_upperbound`.

    #[lua()]
    fn set_deadzone_upperbound(
        _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32;

"#,
    r#"
/// Get the value below which negative inputs will be rounded down to -1.0.

    #[lua()]
    fn livezone_lowerbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32;

"#,
    r#"
/// Try to set the value below which negative inputs will be rounded down to -1.0.
/// If the value passed is positive or greater than `deadzone_lowerbound`,
/// the value will not be changed.
/// Returns the new value of `livezone_lowerbound`.

    #[lua()]
    fn set_livezone_lowerbound(
        _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32;

"#,
    r#"
/// Get the value above which inputs will be rounded up to 0.0.

    #[lua()]
    fn deadzone_lowerbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32;

"#,
    r#"
/// Try to set the value above which inputs will be rounded up to 0.0.
/// If the value passed is less than -1.0 or less than `livezone_lowerbound`,
/// the value will not be changed.
/// Returns the new value of `deadzone_lowerbound`.

    #[lua()]
    fn set_deadzone_lowerbound(
        _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32;

"#,
    r#"
/// Get the minimum value by which input must change before the change is registered.

    #[lua()]
    fn threshold(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32;

"#,
    r#"
/// Try to set the minimum value by which input must change before the changes will be applied.
/// If the value passed is not within [0.0..=2.0], the value will not be changed.
/// Returns the new value of threshold.

    #[lua()]
    fn set_threshold(_self: Mut<bevy::input::gamepad::AxisSettings>, value: f32) -> f32;

"#,
    r#"
/// Clamps the `raw_value` according to the `AxisSettings`.

    #[lua()]
    fn clamp(_self: Ref<bevy::input::gamepad::AxisSettings>, new_value: f32) -> f32;

"#,
    r#"
/// Filters the `new_value` based on the `old_value`, according to the [`AxisSettings`].
/// Returns the clamped `new_value` if the change exceeds the settings threshold,
/// and `None` otherwise.

    #[lua()]
    fn filter(
        _self: Ref<bevy::input::gamepad::AxisSettings>,
        new_value: f32,
        old_value: std::option::Option<f32>,
    ) -> std::option::Option<f32>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::AxisSettings>,
    ) -> Val<bevy::input::gamepad::AxisSettings>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct AxisSettings {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::ButtonAxisSettings",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Filters the `new_value` based on the `old_value`, according to the [`ButtonAxisSettings`].
/// Returns the clamped `new_value`, according to the [`ButtonAxisSettings`], if the change
/// exceeds the settings threshold, and `None` otherwise.

    #[lua()]
    fn filter(
        _self: Ref<bevy::input::gamepad::ButtonAxisSettings>,
        new_value: f32,
        old_value: std::option::Option<f32>,
    ) -> std::option::Option<f32>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::ButtonAxisSettings>,
    ) -> Val<bevy::input::gamepad::ButtonAxisSettings>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct ButtonAxisSettings {
    high: f32,
    low: f32,
    threshold: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::gamepad::GamepadRumbleIntensity",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"
/// Creates a new rumble intensity with weak motor intensity set to the given value.
/// Clamped within the `0.0` to `1.0` range.

    #[lua()]
    fn weak_motor(intensity: f32) -> Val<bevy::input::gamepad::GamepadRumbleIntensity>;

"#,
    r#"
/// Creates a new rumble intensity with strong motor intensity set to the given value.
/// Clamped within the `0.0` to `1.0` range.

    #[lua()]
    fn strong_motor(intensity: f32) -> Val<bevy::input::gamepad::GamepadRumbleIntensity>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::gamepad::GamepadRumbleIntensity>,
    ) -> Val<bevy::input::gamepad::GamepadRumbleIntensity>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::gamepad::GamepadRumbleIntensity>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::gamepad::GamepadRumbleIntensity>,
        other: Ref<bevy::input::gamepad::GamepadRumbleIntensity>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct GamepadRumbleIntensity {
    strong_motor: f32,
    weak_motor: f32,
}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::keyboard::Key",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::keyboard::Key>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(_self: Ref<bevy::input::keyboard::Key>) -> Val<bevy::input::keyboard::Key>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::keyboard::Key>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::keyboard::Key>,
        other: Ref<bevy::input::keyboard::Key>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct Key {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::keyboard::NativeKeyCode",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::keyboard::NativeKeyCode>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::keyboard::NativeKeyCode>,
        other: Ref<bevy::input::keyboard::NativeKeyCode>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::keyboard::NativeKeyCode>,
    ) -> Val<bevy::input::keyboard::NativeKeyCode>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::input::keyboard::NativeKeyCode>,
    ) -> ();

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct NativeKeyCode {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::keyboard::NativeKey",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::keyboard::NativeKey>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::keyboard::NativeKey>,
        other: Ref<bevy::input::keyboard::NativeKey>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::keyboard::NativeKey>) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::keyboard::NativeKey>,
    ) -> Val<bevy::input::keyboard::NativeKey>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct NativeKey {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::mouse::MouseScrollUnit",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::mouse::MouseScrollUnit>,
    ) -> Val<bevy::input::mouse::MouseScrollUnit>;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::input::mouse::MouseScrollUnit>,
    ) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::mouse::MouseScrollUnit>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::mouse::MouseScrollUnit>,
        other: Ref<bevy::input::mouse::MouseScrollUnit>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct MouseScrollUnit {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::touch::TouchPhase",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(_self: Ref<bevy::input::touch::TouchPhase>) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::touch::TouchPhase>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::touch::TouchPhase>,
        other: Ref<bevy::input::touch::TouchPhase>,
    ) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::touch::TouchPhase>,
    ) -> Val<bevy::input::touch::TouchPhase>;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct TouchPhase {}
#[derive(bevy_mod_scripting_derive::LuaProxy)]
#[proxy(
    remote = "bevy::input::touch::ForceTouch",
    bms_core_path = "bevy_mod_scripting_core",
    bms_lua_path = "crate",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone")]
    fn clone(
        _self: Ref<bevy::input::touch::ForceTouch>,
    ) -> Val<bevy::input::touch::ForceTouch>;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq::<bevy::input::touch::ForceTouch>",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        _self: Ref<bevy::input::touch::ForceTouch>,
        other: Ref<bevy::input::touch::ForceTouch>,
    ) -> bool;

"#,
    r#"
#[lua(metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
pub struct ForceTouch {}
#[derive(Default)]
pub(crate) struct Globals;
impl crate::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: crate::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> crate::tealr::mlu::mlua::Result<()> {
        instances
            .add_instance(
                "GamepadRumbleIntensity",
                crate::tealr::mlu::UserDataProxy::<LuaGamepadRumbleIntensity>::new,
            )?;
        Ok(())
    }
}
fn bevy_input_context_initializer(
    _: &bevy_mod_scripting_core::script::ScriptId,
    ctx: &mut crate::prelude::Lua,
) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
    crate::tealr::mlu::set_global_env(Globals, ctx)?;
    Ok(())
}
pub struct BevyInputScriptingPlugin;
impl bevy::app::Plugin for BevyInputScriptingPlugin {
    fn build(&self, app: &mut bevy::prelude::App) {
        app.register_lua_proxy::<bevy::input::gamepad::Gamepad>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadAxis>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadButton>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadSettings>();
        app.register_lua_proxy::<bevy::input::keyboard::KeyCode>();
        app.register_lua_proxy::<bevy::input::mouse::MouseButton>();
        app.register_lua_proxy::<bevy::input::touch::TouchInput>();
        app.register_lua_proxy::<bevy::input::keyboard::KeyboardFocusLost>();
        app.register_lua_proxy::<bevy::input::keyboard::KeyboardInput>();
        app.register_lua_proxy::<bevy::input::mouse::AccumulatedMouseMotion>();
        app.register_lua_proxy::<bevy::input::mouse::AccumulatedMouseScroll>();
        app.register_lua_proxy::<bevy::input::mouse::MouseButtonInput>();
        app.register_lua_proxy::<bevy::input::mouse::MouseMotion>();
        app.register_lua_proxy::<bevy::input::mouse::MouseWheel>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadAxisChangedEvent>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadButtonChangedEvent>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadButtonStateChangedEvent>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadConnection>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadConnectionEvent>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadEvent>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadInput>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadRumbleRequest>();
        app.register_lua_proxy::<bevy::input::gamepad::RawGamepadAxisChangedEvent>();
        app.register_lua_proxy::<bevy::input::gamepad::RawGamepadButtonChangedEvent>();
        app.register_lua_proxy::<bevy::input::gamepad::RawGamepadEvent>();
        app.register_lua_proxy::<bevy::input::gestures::PinchGesture>();
        app.register_lua_proxy::<bevy::input::gestures::RotationGesture>();
        app.register_lua_proxy::<bevy::input::gestures::DoubleTapGesture>();
        app.register_lua_proxy::<bevy::input::gestures::PanGesture>();
        app.register_lua_proxy::<bevy::input::ButtonState>();
        app.register_lua_proxy::<bevy::input::gamepad::ButtonSettings>();
        app.register_lua_proxy::<bevy::input::gamepad::AxisSettings>();
        app.register_lua_proxy::<bevy::input::gamepad::ButtonAxisSettings>();
        app.register_lua_proxy::<bevy::input::gamepad::GamepadRumbleIntensity>();
        app.register_lua_proxy::<bevy::input::keyboard::Key>();
        app.register_lua_proxy::<bevy::input::keyboard::NativeKeyCode>();
        app.register_lua_proxy::<bevy::input::keyboard::NativeKey>();
        app.register_lua_proxy::<bevy::input::mouse::MouseScrollUnit>();
        app.register_lua_proxy::<bevy::input::touch::TouchPhase>();
        app.register_lua_proxy::<bevy::input::touch::ForceTouch>();
        app.add_context_initializer::<()>(bevy_input_context_initializer);
        app.add_documentation_fragment(
            crate::docs::LuaDocumentationFragment::new(
                "BevyInputAPI",
                |tw| {
                    tw.document_global_instance::<Globals>()
                        .expect("Something went wrong documenting globals")
                        .process_type::<LuaGamepad>()
                        .process_type::<LuaGamepadAxis>()
                        .process_type::<LuaGamepadButton>()
                        .process_type::<LuaGamepadSettings>()
                        .process_type::<LuaKeyCode>()
                        .process_type::<LuaMouseButton>()
                        .process_type::<LuaTouchInput>()
                        .process_type::<LuaKeyboardFocusLost>()
                        .process_type::<LuaKeyboardInput>()
                        .process_type::<LuaAccumulatedMouseMotion>()
                        .process_type::<LuaAccumulatedMouseScroll>()
                        .process_type::<LuaMouseButtonInput>()
                        .process_type::<LuaMouseMotion>()
                        .process_type::<LuaMouseWheel>()
                        .process_type::<LuaGamepadAxisChangedEvent>()
                        .process_type::<LuaGamepadButtonChangedEvent>()
                        .process_type::<LuaGamepadButtonStateChangedEvent>()
                        .process_type::<LuaGamepadConnection>()
                        .process_type::<LuaGamepadConnectionEvent>()
                        .process_type::<LuaGamepadEvent>()
                        .process_type::<LuaGamepadInput>()
                        .process_type::<LuaGamepadRumbleRequest>()
                        .process_type::<LuaRawGamepadAxisChangedEvent>()
                        .process_type::<LuaRawGamepadButtonChangedEvent>()
                        .process_type::<LuaRawGamepadEvent>()
                        .process_type::<LuaPinchGesture>()
                        .process_type::<LuaRotationGesture>()
                        .process_type::<LuaDoubleTapGesture>()
                        .process_type::<LuaPanGesture>()
                        .process_type::<LuaButtonState>()
                        .process_type::<LuaButtonSettings>()
                        .process_type::<LuaAxisSettings>()
                        .process_type::<LuaButtonAxisSettings>()
                        .process_type::<LuaGamepadRumbleIntensity>()
                        .process_type::<
                            crate::tealr::mlu::UserDataProxy<LuaGamepadRumbleIntensity>,
                        >()
                        .process_type::<LuaKey>()
                        .process_type::<LuaNativeKeyCode>()
                        .process_type::<LuaNativeKey>()
                        .process_type::<LuaMouseScrollUnit>()
                        .process_type::<LuaTouchPhase>()
                        .process_type::<LuaForceTouch>()
                },
            ),
        );
    }
}
