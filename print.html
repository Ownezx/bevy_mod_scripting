<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bevy Scripting</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Bevy Scripting library">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bevy Scripting</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/makspll/bevy_mod_scripting" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>First you need to install the crate by adding this entry to your <code>Cargo.toml</code> dependencies list:</p>
<pre><code class="language-toml">bevy_mod_scripting = { version = "0.9.0", features = ["lua54"]}
</code></pre>
<p>Choose the language features you wish enabled and add them to the features block.</p>
<h2 id="bevy-plugin"><a class="header" href="#bevy-plugin">Bevy Plugin</a></h2>
<p>The next step is to add the BMS plugin to your application, on top of any other extras you want included in your app:</p>
<pre><code class="language-rust ignore">app.add_plugins(LuaScriptingPlugin::default());</code></pre>
<p>The above is how you'd setup BMS for Lua, if you want to use another language, simply use a corresponding plugin from the integration crate.</p>
<h2 id="language-features"><a class="header" href="#language-features">Language Features</a></h2>
<p>Each language supported by BMS can be switched-on via feature flag as below:</p>
<div class="table-wrapper"><table><thead><tr><th>Language</th><th>Feature Flag</th></tr></thead><tbody>
<tr><td>Lua51</td><td>lua51</td></tr>
<tr><td>Lua52</td><td>lua54</td></tr>
<tr><td>Lua53</td><td>lua53</td></tr>
<tr><td>Lua54</td><td>lua54</td></tr>
<tr><td>Luajit</td><td>luajit</td></tr>
<tr><td>Luajit52</td><td>luajit52</td></tr>
<tr><td>Luau</td><td>luau</td></tr>
<tr><td>Rhai</td><td>rhai</td></tr>
<tr><td>Rune</td><td>rune</td></tr>
</tbody></table>
</div>
<h2 id="extra-features"><a class="header" href="#extra-features">Extra Features</a></h2>
<p>In order to fit as many use cases as possible, BMS allows you to disable a lot of its functionality.</p>
<p>By default all of the useful features are enabled, but you may disable them if you wish if you are only needing BMS for script lifecycle management, and want to populate the bindings yourself.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td>core_functions</td><td>If enabled, will enable all core functions, i.e. bevy integrations which let you interact with Bevy via reflection</td></tr>
<tr><td>bevy_bindings</td><td>If enabled, populates the function registry with additiona automatically generated bevy bindings. This includes functions on <code>glam</code> and <code>bevy::ecs</code> types. These are useful but will slow down compilation considerably.</td></tr>
<tr><td>mlua_async</td><td>Enables <code>mlua/async</code></td></tr>
<tr><td>mlua_serialize</td><td>Enables <code>mlua/serialize</code></td></tr>
<tr><td>mlua_macros</td><td>Enables <code>mlua/macros</code></td></tr>
<tr><td>unsafe_lua_modules</td><td>Allows loading unsafe modules via <code>require</code> in lua</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="managing-scripts"><a class="header" href="#managing-scripts">Managing Scripts</a></h1>
<p>Scripts live in the standard bevy <code>assets</code> directory. Loading a script means:</p>
<ul>
<li>Parsing the script body</li>
<li>Creating or updating the resources which store script state</li>
<li>Assigning a name/id to the script so it can be referred to by the rest of the application.</li>
</ul>
<h2 id="loading"><a class="header" href="#loading">Loading</a></h2>
<p>BMS listens to <code>ScriptAsset</code> events and reacts accordingly. In order to load a script, all you need to do is request a handle to it via the asset server and store it somewhere.</p>
<p>Below is an example system which loads a script called <code>assets/my_script.lua</code> and stores the handle in a local system parameter:</p>
<pre><code class="language-rust ignore">fn load_script(server: Res&lt;AssetServer&gt;, mut handle: Local&lt;Handle&lt;ScriptAsset&gt;&gt;) {
    let handle_ = server.load::&lt;ScriptAsset&gt;("my_script.lua");
    *handle = handle_;
}</code></pre>
<p>In practice you will likely store this handle in a resource or component, when your load all the scripts necessary for your application.</p>
<h2 id="unloading"><a class="header" href="#unloading">Unloading</a></h2>
<p>Scripts are automatically unloaded when the asset is dropped. This means that if you have a handle to a script and it goes out of scope, the script will be unloaded.</p>
<p>This will delete references to the script and remove any internal handles to the asset. You will also need to clean up any handles to the asset you hold in your application in order for the asset to be unloaded.</p>
<h2 id="hot-loading-scripts"><a class="header" href="#hot-loading-scripts">Hot-loading scripts</a></h2>
<p>To enable hot-loading of assets, you need to enable the necessary bevy features as normal <a href="https://bevy-cheatbook.github.io/assets/hot-reload.html">see the bevy cheatbook for instructions</a>.</p>
<p>Assuming that hot-reloading is enabled for your app, any changes to script assets will automatically be picked up and the scripts re-loaded.</p>
<h2 id="manually-reloading-scripts"><a class="header" href="#manually-reloading-scripts">Manually (re)loading scripts</a></h2>
<p>In order to manually re-load or load a script you can issue the <code>CreateOrUpdateScript</code> command:</p>
<pre><code class="language-rust ignore">CreateOrUpdateScript::&lt;LuaScriptingPlugin&gt;::new("my_script.lua".into(), "print(\"hello world from new script body\")".into(), asset_handle)</code></pre>
<p>replace <code>LuaScriptingPlugin</code> with the scripting plugin you are using.</p>
<h2 id="manually-deleting-scripts"><a class="header" href="#manually-deleting-scripts">Manually Deleting scripts</a></h2>
<p>In order to delete a previously loaded script, you will need to issue a <code>DeleteScript</code> command like so:</p>
<pre><code class="language-rust ignore">DeleteScript::&lt;LuaScriptingPlugin&gt;::new("my_script.lua".into())</code></pre>
<p>replace <code>LuaScriptingPlugin</code> with the scripting plugin you are using.</p>
<h2 id="loadingunloading-timeframe"><a class="header" href="#loadingunloading-timeframe">Loading/Unloading timeframe</a></h2>
<p>Scripts asset events are processed within the same frame they are issued. This means the moment an asset is loaded, it should be loaded and ready to use in the <code>Update</code> schedule. Similarly, the moment an asset is deleted, it should be unloaded and no longer usable in the <code>Update</code> schedule.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attaching-scripts"><a class="header" href="#attaching-scripts">Attaching Scripts</a></h1>
<p>Once you have scripts discovered and loaded, you'll want to run them. At the moment BMS supports one method of triggering scripts, and that is by attaching them to entities via <code>ScriptComponent</code>'s and then sending script event's which trigger callbacks on the scripts.</p>
<p>In order to attach a script and make it runnable simply add a <code>ScriptComponent</code> to an entity</p>
<pre><code class="language-rust ignore">    commands.entity(my_entity).insert(ScriptComponent::new(vec!["my_script.lua", "my_other_script.lua"]));</code></pre>
<h1 id="running-scripts"><a class="header" href="#running-scripts">Running Scripts</a></h1>
<p>Scripts can run logic either when loaded or when triggered by an event. For example the script:</p>
<pre><code class="language-lua">print("hello from load time")
function on_event(arg1)
    print("hello from event time")
    print(arg1)
end
</code></pre>
<p>Will print "hello from load time" when the script is loaded, and "hello from event time" when the script receives an event targeting the <code>on_event</code> callback with a receiver list including this script or entity.</p>
<p>In order to trigger <code>on_event</code> you need to first define a label, then send an event containing the label:</p>
<pre><code class="language-rust ignore">
#[derive(Reflect)]
pub struct MyReflectType;

// define the label, you can define as many as you like here
callback_labels!(OnEvent =&gt; "on_event");

// trigger the event
fn send_event(mut writer: EventWriter&lt;ScriptCallbackEvent&gt;, mut allocator: ResMut&lt;AppReflectAllocator&gt;) {

    let allocator = allocator.write();
    let my_reflect_payload = ReflectReference::new_allocated(MyReflectType, &amp;mut allocator);

    writer.send(ScriptCallbackEvent::new_for_all(
        OnEvent,
        vec![my_reflect_payload.into()],
    ));
}</code></pre>
<p>Note the second argument is the payload we are sending with the event, in this case we are sending an arbitrary reflect type <code>MyReflectType</code>. This can be any type you like, as long as it implements <code>Reflect</code>.</p>
<p>Other variants of the <code>ScriptValue</code> enum are available for sending different types of data, such as <code>ScriptValue::Integer</code> for primtive, types.</p>
<h1 id="event-handlers"><a class="header" href="#event-handlers">Event Handlers</a></h1>
<p>In order for the events you send to actually be picked up, you need to inject special systems into your application. These systems will listen for the events and trigger the appropriate callbacks on the scripts:</p>
<pre><code class="language-rust ignore">app.add_systems(Update, event_handler::&lt;OnEvent, LuaScriptingPlugin&gt;);</code></pre>
<p>Note the system is parameterized by the label we defined earlier, and the scripting plugin we are using. You can add as many of these systems as you like.</p>
<p>The event handler will catch all events with the label <code>OnEvent</code> and trigger the <code>on_event</code> callback on all targeted scripts which have that callback defined.</p>
<p>In order to handle events in the same frame and not accidentally have events "spill over" into the next frame, you should make sure to order any systems which produce these events <em>before</em> the event handler systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controlling-script-bindings"><a class="header" href="#controlling-script-bindings">Controlling Script Bindings</a></h1>
<p>In this book we reffer to anything accessible by a script, which allows it to communicate with your Rust code a <code>binding</code> (which in previous versions was more generically referred to as a script API).</p>
<p>The "binding" here being used as in: binding <code>script</code> code to <code>rust</code> code.</p>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>Namespaces are a way to group functions together, and are used to prevent naming conflicts. You can have multiple namespaces, and each namespace can have multiple functions.</p>
<p>Language implementations will also look for specific functions registered on your type first before looking at the generic <code>ReflectReference</code> namespace.</p>
<h2 id="dynamic-functions"><a class="header" href="#dynamic-functions">Dynamic Functions</a></h2>
<p>Everything callable by scripts must first be registered in the dynamic function registry. Notably we do not make use of the normal bevy function registry to improve performance and usability. This means you cannot call just any function.</p>
<p>In order for a function to be callable by a script it must adhere to a few requirements:</p>
<ul>
<li>Each argument must implement <code>FromScript</code>.</li>
<li>Each return type must implement <code>IntoScript</code>.</li>
<li>Each argument must also implement <code>GetInnerTypeDependencies</code></li>
<li>Each return type must also implement <code>GetInnerTypeDependencies</code></li>
</ul>
<p>The into/from requirements allow us to convert these types to <code>ScriptValue</code>'s, and each supported scripting language can then marshall these into the script.</p>
<p>Note these types are implemented for primitives, but if you want to interact with one of your <code>Reflect</code> implementing types, you will need to use one of <code>Ref&lt;T&gt;</code>, <code>Mut&lt;T&gt;</code> or <code>Val&lt;T&gt;</code> wrappers in place of <code>&amp;T</code>, <code>&amp;mut T</code> and <code>T</code> respectively.</p>
<p>These wrappers enable us to safely interact with bevy, and claim any necessary mutex'es on <code>Resources</code>, <code>Components</code> or <code>Allocations</code>.</p>
<p>The <code>GetInnerTypeDependencies</code>, trait is simply a local trait alias for <code>GetTypeRegistration</code> with less strict type requirements. It allows us to register all the types necessary for the function calls, so that you don't have to register anything manually. If your type implements <code>GetTypeRegistration</code> you should not face any issues on this front.</p>
<h2 id="registering-script-functions"><a class="header" href="#registering-script-functions">Registering Script Functions</a></h2>
<p>Registering functions can be done via the <code>NamespaceBuilder</code> like below:</p>
<pre><code class="language-rust ignore">    NamespaceBuilder::&lt;ReflectReference&gt;::new(&amp;mut world)
        .register(
            "hello_world",
            |s: String| {
                println!(s)
            },
        );

    NamespaceBuilder::&lt;GlobalNamespace&gt;::new_unregistered(&amp;mut world)
        .register(
            "hello_world2",
            |s: String| {
                println!(s)
            },
        );</code></pre>
<p>This will allow you to call this function within lua like so:</p>
<pre><code class="language-lua">some_type:hello_world("hi from method!");
hello_world2("hi from global!");
</code></pre>
<p>Note the <code>new_unregistered</code> call instead of <code>new</code>, this is because <code>GlobalNamespace</code> is not a <code>Reflect</code> type, and the <code>new</code> call also automatically registers the type in the reflection registry.</p>
<h2 id="context-arguments"><a class="header" href="#context-arguments">Context Arguments</a></h2>
<p>Each script function call always receives an additional context argument: <code>FunctionCallContext</code>.
You can opt-in to receive this argument in your own function definitions by adding it as the first argument.</p>
<p>The context contains requests from the caller to your function, such as "I am calling you from a 1-indexed array system, please convert the index first", This argument is only relevant if you're targeting multiple languages.</p>
<p>It also allows you to retrieve the world via <code>FunctionCallContext::world()</code>.</p>
<p>You can use this as follows:</p>
<pre><code class="language-rust ignore">    NamespaceBuilder::&lt;ReflectReference&gt;::new(&amp;mut world)
        .register(
            "hello_world",
            |ctx: FunctionCallContext, s: String| {
                let world = ctx.world()?;
                let should_use_0_indexing = ctx.convert_to_0_indexed;
                println!(should_use_0_indexing);
                println!(s)
                Ok(())
            },
        );</code></pre>
<h2 id="generic-arguments"><a class="header" href="#generic-arguments">Generic Arguments</a></h2>
<p>Sometimes you might want to be generic over the type of argument you're accepting, you can do so by accepting <code>ScriptValue</code> arguments like so:</p>
<pre><code class="language-rust ignore">    NamespaceBuilder::&lt;ReflectReference&gt;::new(&amp;mut world)
        .register(
            "is_integer",
            |s: ScriptValue| {
                match s {
                    ScriptValue::Integer(i) =&gt; true,
                    _ =&gt; false
                }
            },
        );</code></pre>
<p>You can treat return values similarly.</p>
<h2 id="fallible-functions"><a class="header" href="#fallible-functions">Fallible functions</a></h2>
<p>Your script functions can return errors either by:</p>
<ul>
<li>Returning <code>Result&lt;T: IntoScript, InteropError&gt;</code></li>
<li>Returning <code>ScriptValue</code> and manually creating the <code>ScriptValue::Error(into_interop_erorr.into())</code> variant.</li>
</ul>
<h2 id="reserved-functions"><a class="header" href="#reserved-functions">Reserved Functions</a></h2>
<p>There are a few reserved functions that you can override by registering them on a specific type:</p>
<div class="table-wrapper"><table><thead><tr><th>Function Name</th><th>Description</th><th>Overridable?</th><th>Has Default Implementation?</th></tr></thead><tbody>
<tr><td>get</td><td>a getter function, used for indexing into a type</td><td>✅</td><td>✅</td></tr>
<tr><td>set</td><td>a setter function, used for setting a value on a type</td><td>✅</td><td>✅</td></tr>
<tr><td>sub</td><td>a subtraction function, used for subtracting two values</td><td>✅</td><td>❌</td></tr>
<tr><td>add</td><td>an addition function, used for adding two values</td><td>✅</td><td>❌</td></tr>
<tr><td>mul</td><td>a multiplication function, used for multiplying two values</td><td>✅</td><td>❌</td></tr>
<tr><td>div</td><td>a division function, used for dividing two values</td><td>✅</td><td>❌</td></tr>
<tr><td>rem</td><td>a remainder function, used for getting the remainder of two values</td><td>✅</td><td>❌</td></tr>
<tr><td>neg</td><td>a negation function, used for negating a value</td><td>✅</td><td>❌</td></tr>
<tr><td>pow</td><td>a power function, used for raising a value to a power</td><td>✅</td><td>❌</td></tr>
<tr><td>eq</td><td>an equality function, used for checking if two values are equal</td><td>✅</td><td>❌</td></tr>
<tr><td>lt</td><td>a less than function, used for checking if a value is less than another</td><td>✅</td><td>❌</td></tr>
<tr><td>iter</td><td>an iterator function, used for iterating over a value</td><td>❌</td><td>✅</td></tr>
<tr><td>display_ref</td><td>a display function, used for displaying a reference to a value</td><td>❌</td><td>✅</td></tr>
<tr><td>display_value</td><td>a display function, used for displaying a mutable reference to a value</td><td>❌</td><td>✅</td></tr>
</tbody></table>
</div>
<p>In this context <code>overridable</code> indicates whether language implementations will look for a specific function on your type before looking at the generic <code>ReflectReference</code> namespace. You can still remove the existing registration for these functions on the <code>ReflectReference</code> namespace if you want to replace them with your own implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-script-contexts"><a class="header" href="#modifying-script-contexts">Modifying Script Contexts</a></h1>
<p>You should be able to achieve what you need by registering script functions in most cases. However sometimes you might want to override the way contexts are loaded, or how the runtime is initialized.</p>
<p>This is possible using <code>Context Initializers</code> and <code>Context Pre Handling Initializers</code> as well as <code>Runtime Initializers</code>.</p>
<p>It is however always reccomened to use the dynamic script function registry whenever possible, as it is more flexible and easier to use. It also allows you to introspect available functions easier.</p>
<h2 id="context-initializers"><a class="header" href="#context-initializers">Context Initializers</a></h2>
<p>For example, let's say you want to set a dynamic amount of globals in your script, depending on some setting in your app.</p>
<p>You could do this by customizing the scripting plugin:</p>
<pre><code class="language-rust ignore">let plugin = LuaScriptingPlugin::default().add_context_initializer(|script_id: &amp;str, context: &amp;mut Lua| {
    let globals = context.globals();
    for i in 0..10 {
        globals.set(i, i);
    }
    Ok(())
});

app.add_plugins(plugin)</code></pre>
<p>The above will run every time the script is loaded or re-loaded and before it handles any callbacks.</p>
<h2 id="context-pre-handling-initializers"><a class="header" href="#context-pre-handling-initializers">Context Pre Handling Initializers</a></h2>
<p>If you want to customize your context before every time it's about to handle events (and when it's loaded + reloaded), you can use <code>Context Pre Handling Initializers</code>:</p>
<pre><code class="language-rust ignore">let plugin = LuaScriptingPlugin::default().add_context_pre_handling_initializer(|script_id: &amp;str, entity: Entity, context: &amp;mut Lua| {
    let globals = context.globals();
    globals.set("script_name", script_id.to_owned());
    Ok(())
});</code></pre>
<h2 id="runtime-initializers"><a class="header" href="#runtime-initializers">Runtime Initializers</a></h2>
<p>Some scripting languages, have the concept of a <code>runtime</code>. This is a global object which is shared between all contexts. You can customize this object using <code>Runtime Initializers</code>:</p>
<pre><code class="language-rust ignore">let plugin = SomeScriptingPlugin::default().add_runtime_initializer(|runtime: &amp;mut Runtime| {
    runtime.set_max_stack_size(1000);
    Ok(())
});</code></pre>
<p>In the case of Lua, the runtime type is <code>()</code> i.e. This is because <code>mlua</code> does not have a separate runtime concept.</p>
<h2 id="accessing-the-world-in-initializers"><a class="header" href="#accessing-the-world-in-initializers">Accessing the World in Initializers</a></h2>
<p>You can access the world in these initializers by using the thread local: <code>ThreadWorldContainer</code>:</p>
<pre><code class="language-rust ignore">
let plugin = LuaScriptingPlugin::default();
plugin.add_context_initializer(|script_id: &amp;str, context: &amp;mut Lua| {
    let world = ThreadWorldContainer.try_get_world().unwrap();
    world.with_resource::&lt;MyResource&gt;(|res| println!("My resource: {:?}", res));
    Ok(())
});</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-contexts"><a class="header" href="#shared-contexts">Shared Contexts</a></h1>
<p>By default BMS will create an individual script context, or sandbox, for each script that is run. This means that each script will have its own set of global variables and functions that are isolated from other scripts. However, sometimes this might not be desirable, if you aren't worried about scripts interfering with each other, or if you want to easilly share data between scripts. In these cases, you can use shared contexts.</p>
<h2 id="enabling-shared-contexts"><a class="header" href="#enabling-shared-contexts">Enabling Shared Contexts</a></h2>
<p>You can enable shared contexts by configuring the relevant scripting plugin like so:</p>
<pre><code class="language-rust ignore">let mut plugin = LuaScriptingPlugin::default().enable_context_sharing();

app.add_plugins(plugin);</code></pre>
<h2 id="context-loading-settings"><a class="header" href="#context-loading-settings">Context Loading Settings</a></h2>
<p>All context loading settings are stored in a separate resource per scripting plugin namely: <code>ContextLoadingSettings&lt;Plugin&gt;</code>.</p>
<p>The settings are as follows:</p>
<ul>
<li><code>loader</code> - the load and unload strategy for contexts. Each scripting plugin will have a load and unload function which is hooked up through here</li>
<li><code>assigner</code> - the strategy for assigning/unassigning contexts to scripts. This is used to determine how to assign a context to a script when it is run, and what to do with the context when the script is finished.</li>
<li><code>context_initializers</code> - stores all context initializers for the plugin</li>
<li><code>context_pre_handling_initializers</code> - stores all context pre-handling initializers for the plugin</li>
</ul>
<p>More advanced applications might want to customize these settings to suit their needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="script-id-mapping"><a class="header" href="#script-id-mapping">Script ID mapping</a></h1>
<p>Every script is currently identified by a unique ID.</p>
<p>ID's are derived from the script asset path for scripts loaded via the asset system.</p>
<p>By default this is an identity mapping, but you can override this by modifying the <code>AssetPathToScriptIdMapper</code> inside the <code>ScriptAssetSettings</code> resource before loading the script.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting-reference"><a class="header" href="#scripting-reference">Scripting Reference</a></h1>
<p>This part of the book covers the user-facing API of the scripting languages supported by BMS. This will be where you will want to forward your script users to get started with scripting in BMS.</p>
<p>If you are a modder, welcome! 👋, apologies for the rust-centricity of this guide, we are working on it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-bindings"><a class="header" href="#core-bindings">Core Bindings</a></h1>
<p>The core bindings are manually written utilities for interacting with the <code>Bevy</code> world and everything contained within it. These bindings are used to create and manipulate entities, components, resources, and systems.</p>
<p>Every language BMS supports will support these.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="world"><a class="header" href="#world">World</a></h2>
<p>The <code>World</code> is the entry point for interacting with <code>Bevy</code>. It is provided to scripts under either the <code>world</code> or <code>World</code> static variable.</p>
<h3 id="get_type_by_name"><a class="header" href="#get_type_by_name">get_type_by_name</a></h3>
<p>Returns either a <code>ScriptComponentRegistration</code> or <code>ScriptResourceRegistration</code> depending on the type of the type requested. If the type is neither returns a <code>ScriptTypeRegistration</code>.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>type_name</code></td><td><code>String</code></td><td>The name of the type to get, this can be either the short type name, i.e. <code>my_type</code> or the long name i.e. <code>my_crate::my_module::my_type</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Option&lt;ScriptTypeRegistration OR scriptComponentRegistration OR scriptResourceRegistration&gt;</code></td><td>The registration for the type if it exists, otherwise <code>None</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">MyType = world.get_type_by_name("MyType")
if MyType == nil then
    print("MyType not found")
end
</code></pre>
<h3 id="get_component"><a class="header" href="#get_component">get_component</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to get the component from</td></tr>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the component</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Option&lt;ReflectReference&gt;</code></td><td>The reference to the component if it exists, otherwise <code>None</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local component = world.get_component(entity, MyType)
if component ~= nil then
    print("found component:" .. component)
end
</code></pre>
<h3 id="has_component"><a class="header" href="#has_component">has_component</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to check the component for</td></tr>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the component</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>true</code> if the entity has the component, otherwise <code>false</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">if world.has_component(entity, MyType) then
    print("Entity has MyType")
end
</code></pre>
<h3 id="remove_component"><a class="header" href="#remove_component">remove_component</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to remove the component from</td></tr>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the component</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.remove_component(entity, MyType)
</code></pre>
<h3 id="get_resource"><a class="header" href="#get_resource">get_resource</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the resource</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Option&lt;ReflectReference&gt;</code></td><td>The resource if it exists, otherwise <code>None</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local resource = world.get_resource(MyType)
if resource ~= nil then
    print("found resource:" .. resource)
end
</code></pre>
<h3 id="has_resource"><a class="header" href="#has_resource">has_resource</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the resource</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>true</code> if the resource exists, otherwise <code>false</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local hasResource = world.has_resource(MyType)
</code></pre>
<h3 id="remove_resource"><a class="header" href="#remove_resource">remove_resource</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the resource</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.remove_resource(MyType)
</code></pre>
<h3 id="add_default_component"><a class="header" href="#add_default_component">add_default_component</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to add the component to</td></tr>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the component</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.add_default_component(entity, MyType)
</code></pre>
<h3 id="insert_component"><a class="header" href="#insert_component">insert_component</a></h3>
<p>Inserts or applies the given value to the component of the entity. If the component does not exist it will be added.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to add the component to</td></tr>
<tr><td><code>registration</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code> of the component</td></tr>
<tr><td><code>component</code></td><td><code>ReflectReference</code></td><td>A reference to an existing component value to be inserted</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local existingComponent = world.get_component(otherEntity, MyType)
world.insert_component(entity, MyType, existingComponent)
</code></pre>
<h3 id="spawn"><a class="header" href="#spawn">spawn</a></h3>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Entity</code></td><td>The spawned entity</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local entity = world.spawn()
</code></pre>
<h3 id="insert_children"><a class="header" href="#insert_children">insert_children</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The parent entity</td></tr>
<tr><td><code>index</code></td><td><code>usize</code></td><td>The index to insert the children at</td></tr>
<tr><td><code>children</code></td><td><code>Vec&lt;Entity&gt;</code></td><td>The children entities to insert</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.insert_children(parent, 1, {child1, child2})
</code></pre>
<h3 id="push_children"><a class="header" href="#push_children">push_children</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The parent entity</td></tr>
<tr><td><code>children</code></td><td><code>Vec&lt;Entity&gt;</code></td><td>The children entities to push</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.push_children(parent, {child1, child2})
</code></pre>
<h3 id="get_children"><a class="header" href="#get_children">get_children</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The parent entity</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Vec&lt;Entity&gt;</code></td><td>The children entities</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local children = world.get_children(parent)
for _, child in pairs(children) do
    print("child: " .. child)
end
</code></pre>
<h3 id="get_parent"><a class="header" href="#get_parent">get_parent</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The child entity</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Option&lt;Entity&gt;</code></td><td>The parent entity if it exists, otherwise <code>None</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local parent = world.get_parent(child)
if parent ~= nil then
    print("parent: " .. parent)
end
</code></pre>
<h3 id="despawn"><a class="header" href="#despawn">despawn</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to despawn</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.despawn(entity)
</code></pre>
<h3 id="despawn_descendants"><a class="header" href="#despawn_descendants">despawn_descendants</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to despawn descendants of</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.despawn_descendants(entity)
</code></pre>
<h3 id="despawn_recursive"><a class="header" href="#despawn_recursive">despawn_recursive</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to despawn recursively</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">world.despawn_recursive(entity)
</code></pre>
<h3 id="has_entity"><a class="header" href="#has_entity">has_entity</a></h3>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity</code></td><td><code>Entity</code></td><td>The entity to check</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>true</code> if the entity exists, otherwise <code>false</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local exists = world.has_entity(entity)
if exists then
    print("entity exists")
end
</code></pre>
<h3 id="query"><a class="header" href="#query">query</a></h3>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptQueryBuilder</code></td><td>The query builder</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local queryBuilder = world.query()
</code></pre>
<h3 id="exit"><a class="header" href="#exit">exit</a></h3>
<p>Send the exit signal to the application, will gracefully shutdown the application.</p>
<pre><code class="language-lua">world.exit()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflectreference"><a class="header" href="#reflectreference">ReflectReference</a></h1>
<p>ReflectReferences are simply references to data living either in:</p>
<ul>
<li>A component</li>
<li>A resource</li>
<li>The allocator</li>
</ul>
<p>Reflect references contain a standard interface which operates over the reflection layer exposed by <code>Bevy</code> and also provides a way to call various dynamic functions registered on the underlying pointed to data.</p>
<h2 id="display_ref"><a class="header" href="#display_ref">display_ref</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ReflectReference</code></td><td>The reference to display</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The reference in string format</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">print(ref:display_ref())
print(ref)
</code></pre>
<h2 id="display_value"><a class="header" href="#display_value">display_value</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ReflectReference</code></td><td>The reference to display</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The value in string format</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">print(ref:display_value())
</code></pre>
<h2 id="get"><a class="header" href="#get">get</a></h2>
<p>The index function, allows you to index into the reflect reference.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key</code></td><td><code>ScriptValue</code></td><td>The key to get the value for</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptValue</code></td><td>The value</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local value = ref:get(key)
-- same as
local value = ref.key
local value = ref[key]
local value = ref["key"]
-- for tuple structs
local valye = ref._1
</code></pre>
<h2 id="set"><a class="header" href="#set">set</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key</code></td><td><code>ScriptValue</code></td><td>The key to set the value for</td></tr>
<tr><td><code>value</code></td><td><code>ScriptValue</code></td><td>The value to set</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptValue</code></td><td>The result</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">ref:set(key, value)
-- same as
ref.key = value
ref[key] = value
ref["key"] = value
-- for tuple structs
ref._1 = value
</code></pre>
<h2 id="push"><a class="header" href="#push">push</a></h2>
<p>Generic push method, if the underlying type supports it, will push the value into the end of the reference.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>value</code></td><td><code>ScriptValue</code></td><td>The value to push</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">ref:push(value)
</code></pre>
<h2 id="pop"><a class="header" href="#pop">pop</a></h2>
<p>Generic pop method, if the underlying type supports it, will pop the value from the end of the reference.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ReflectReference</code></td><td>The reference to pop from</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptValue</code></td><td>The popped value</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local value = ref:pop()
</code></pre>
<h2 id="insert"><a class="header" href="#insert">insert</a></h2>
<p>Generic insert method, if the underlying type supports it, will insert the value at the key.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key</code></td><td><code>ScriptValue</code></td><td>The key to insert the value for</td></tr>
<tr><td><code>value</code></td><td><code>ScriptValue</code></td><td>The value to insert</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">ref:insert(key, value)
</code></pre>
<h2 id="clear"><a class="header" href="#clear">clear</a></h2>
<p>Generic clear method, if the underlying type supports it, will clear the referenced container type.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ReflectReference</code></td><td>The reference to clear</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">ref:clear()
</code></pre>
<h2 id="len"><a class="header" href="#len">len</a></h2>
<p>Generic length method, if the underlying type supports it, will return the length of the referenced container or length relevant to the type itself (number of fields etc.).</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ReflectReference</code></td><td>The reference to get the length of</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>usize</code></td><td>The length</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">length = ref:len()
</code></pre>
<h2 id="remove"><a class="header" href="#remove">remove</a></h2>
<p>Generic remove method, if the underlying type supports it, will remove the value at the key.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key</code></td><td><code>ScriptValue</code></td><td>The key to remove the value for</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptValue</code></td><td>The removed value</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local value = ref:remove(key)
</code></pre>
<h2 id="iter"><a class="header" href="#iter">iter</a></h2>
<p>The iterator function, returns a function which can be called to iterate over the reference.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ReflectReference</code></td><td>The reference to iterate over</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptFunctionMut</code></td><td>The iterator function</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local iter = ref:iter()
local val = iter()
while val do
    print(val)
    next = iter()
end

-- same as 
for val in pairs(ref) do
    print(val)
end
</code></pre>
<h2 id="functions"><a class="header" href="#functions">functions</a></h2>
<p>Returns a list of functions that can be called on the reference.</p>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Vec&lt;FunctionInfo&gt;</code></td><td>The list of functions</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local functions = ref:functions()
for _, func in ipairs(functions) do
    print(func.name)
    
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripttyperegistration"><a class="header" href="#scripttyperegistration">ScriptTypeRegistration</a></h1>
<p>A reference to a type registration, in general think of this as a handle to a type.</p>
<h2 id="type_name"><a class="header" href="#type_name">type_name</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The type name</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local name = MyType:type_name()
</code></pre>
<h2 id="short_name"><a class="header" href="#short_name">short_name</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The short name</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local name = MyType:short_name()
</code></pre>
<h2 id="is_resource"><a class="header" href="#is_resource">is_resource</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>true</code> if the type is a resource, otherwise <code>false</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">if MyType:is_resource() then
    print("MyType is a resource")
end
</code></pre>
<h2 id="is_component"><a class="header" href="#is_component">is_component</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptTypeRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>true</code> if the type is a component, otherwise <code>false</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">if MyType:is_component() then
    print("MyType is a component")
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scriptcomponentregistration"><a class="header" href="#scriptcomponentregistration">ScriptComponentRegistration</a></h1>
<p>A reference to a component type's registration, in general think of this as a handle to a type.</p>
<h2 id="type_name-1"><a class="header" href="#type_name-1">type_name</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptComponentRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The type name</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local name = MyType:type_name()
</code></pre>
<h2 id="short_name-1"><a class="header" href="#short_name-1">short_name</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptComponentRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The short name</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local name = MyType:short_name()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scriptresourceregistration"><a class="header" href="#scriptresourceregistration">ScriptResourceRegistration</a></h1>
<p>A reference to a resource type's registration, in general think of this as a handle to a type.</p>
<h2 id="type_name-2"><a class="header" href="#type_name-2">type_name</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptResourceRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The type name</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local name = MyType:type_name()
</code></pre>
<h2 id="short_name-2"><a class="header" href="#short_name-2">short_name</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptResourceRegistration</code></td><td>The type registration as returned by <code>get_type_by_name</code></td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>The short name</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local name = MyType:short_name()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scriptquerybuilder"><a class="header" href="#scriptquerybuilder">ScriptQueryBuilder</a></h1>
<p>The query builder is used to build queries for entities with specific components. Can be used to interact with arbitrary entities in the world.</p>
<h2 id="component"><a class="header" href="#component">component</a></h2>
<p>Adds a component to the query, this will be accessible in the query results under the index corresponding to the index of this component in the query.</p>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptQueryBuilder</code></td><td>The query builder</td></tr>
<tr><td><code>component</code></td><td><code>ScriptComponentRegistration</code></td><td>The component to query for</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptQueryBuilder</code></td><td>The updated query builder</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">query:component(MyType):component(MyOtherType)
</code></pre>
<h2 id="with"><a class="header" href="#with">with</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptQueryBuilder</code></td><td>The query builder</td></tr>
<tr><td><code>with</code></td><td><code>ScriptComponentRegistration</code></td><td>The component to include in the query</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptQueryBuilder</code></td><td>The updated query builder</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">query:with(MyType):with(MyOtherType)
</code></pre>
<h2 id="without"><a class="header" href="#without">without</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptQueryBuilder</code></td><td>The query builder</td></tr>
<tr><td><code>without</code></td><td><code>ScriptComponentRegistration</code></td><td>The component to exclude from the query</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ScriptQueryBuilder</code></td><td>The updated query builder</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">query:without(MyType):without(MyOtherType)
</code></pre>
<h2 id="build"><a class="header" href="#build">build</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptQueryBuilder</code></td><td>The query builder</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Vec&lt;ScriptQueryResult&gt;</code></td><td>The query results</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local results = query:build()
for _, result in pairs(results) do
    print(result)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scriptqueryresult"><a class="header" href="#scriptqueryresult">ScriptQueryResult</a></h1>
<p>The result of a query, built by the query builder.</p>
<h2 id="entity"><a class="header" href="#entity">entity</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptQueryResult</code></td><td>The query result</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Entity</code></td><td>The entity</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">local entity = result:entity()
</code></pre>
<h2 id="components"><a class="header" href="#components">components</a></h2>
<p>Arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>ScriptQueryResult</code></td><td>The query result</td></tr>
</tbody></table>
</div>
<p>Returns:</p>
<div class="table-wrapper"><table><thead><tr><th>Return</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Vec&lt;ReflectReference&gt;</code></td><td>The components</td></tr>
</tbody></table>
</div>
<pre><code class="language-lua">for _, component in pairs(result:components()) do
    print(component)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-callbacks"><a class="header" href="#core-callbacks">Core Callbacks</a></h1>
<p>On top of callbacks which are registered by your application, BMS provides a set of core callbacks which are always available.</p>
<p>The two core callbacks are:</p>
<ul>
<li><code>on_script_loaded</code></li>
<li><code>on_script_unloaded</code></li>
</ul>
<h2 id="on_script_loaded"><a class="header" href="#on_script_loaded"><code>on_script_loaded</code></a></h2>
<p>This will be called right after a script has been loaded or reloaded. This is a good place to initialize your script. You should avoid placing a lot of logic into the global body of your script, and instead put it into this callback. Otherwise errors in the initialization will fail the loading of the script.</p>
<pre><code class="language-lua">print("you can also use this space, but it's not recommended")
function on_script_loaded()
    print("Hello world")
end
</code></pre>
<h2 id="on_script_unloaded"><a class="header" href="#on_script_unloaded"><code>on_script_unloaded</code></a></h2>
<p>This will be called right before a script is unloaded. This is a good place to clean up any resources that your script has allocated. Note this is not called when a script is reloaded, only when it is being removed from the system.</p>
<pre><code class="language-lua">function on_script_unloaded()
    print("Goodbye world")
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-bms"><a class="header" href="#developing-bms">Developing BMS</a></h1>
<p>This section is for developers who want to contribute to the BMS project. It covers various topics necessary for understanding the project and contributing to it.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Please see the <a href="https://github.com/makspll/bevy_mod_scripting/blob/main/CODE_OF_CONDUCT.md">code of conduct</a> as well as the <a href="https://github.com/makspll/bevy_mod_scripting/blob/main/CONTRIBUTING.md">contributing guidelines</a> first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>this crate contains a work in progress <code>xtask</code> setup which in theory should allow you to setup everything you need for local development by running:</p>
<pre><code class="language-sh">cargo xtask init
</code></pre>
<p>This command currently supports the following IDE's</p>
<ul>
<li><a href="https://code.visualstudio.com/">VSCode</a></li>
</ul>
<p>If you'd like to add support for another IDE, please feel free to open a PR!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-new-languages-to-bms"><a class="header" href="#adding-new-languages-to-bms">Adding New Languages to BMS</a></h1>
<p>If you are interested in adding a new language to BMS, please read this section first. Adding a new language is a non-trivial task depending on the language you want to add. It also requires a lot of effort and time to maintain a new language, so unless the language you want to add is widely used and has a large community, it might not be worth the effort.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluating-feasibility"><a class="header" href="#evaluating-feasibility">Evaluating Feasibility</a></h1>
<p>In order for a language to work well with BMS it's necessary it supports the following features:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Interoperability with Rust. If you can't call it from Rust easilly and there is no existing crate that can do it for you, it's a no-go.</li>
<li><input disabled="" type="checkbox"/>
First class functions. Or at least the ability to call an arbitrary function with an arbitrary number of arguments from a script. Without this feature, you would need to separately generate code for the bevy bindings which is painful and goes against the grain of BMS.</li>
</ul>
<h2 id="first-classs-functions"><a class="header" href="#first-classs-functions">First Classs Functions</a></h2>
<p>They don't necessarily have to be first class from the script POV, but they need to be first class from the POV of the host language. This means that the host language needs to be able to call a function with an arbitrary number of arguments.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Let's say your language supports a <code>Value</code> type which can be returned to the script. And it has a <code>Value::Function</code> variant. The type on the Rust side would look something like this:</p>
<pre><code class="language-rust ignore">pub enum Value {
    Function(Arc&lt;Fn(&amp;[Value]) -&gt; Value&gt;),
    // other variants
}</code></pre>
<p>This is fine, and can be integrated with BMS. Since an Fn function can be a closure capturing a <code>DynamicScriptFunction</code>. If there is no support for <code>FnMut</code> closures though, you might face issues in the implementation. Iterators in <code>bevy_mod_scripting_functions</code> for example use <code>DynamicScriptFunctionMut</code> which cannot work with <code>Fn</code> closures.</p>
<p>Now let's imagine instead another language with a similar enum, supports this type instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Value {
    Function(Arc&lt;dyn Function&gt;),
    // other variants
}

pub trait Function {
    fn call(&amp;self, args: Vec&lt;Value&gt;) -&gt; Value;

    fn num_params() -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<p>This implies that to call this function, you need to be able to know the amount of arguments it expects at COMPILE time. This is not compatibile with dynamic functions, and would require a lot of code generation to make work with BMS.
Languages with no support for dynamic functions are not compatible with BMS.</p>
<h2 id="interoperability-with-rust"><a class="header" href="#interoperability-with-rust">Interoperability with Rust</a></h2>
<p>Not all languages can easilly be called from Rust. Lua has a wonderful crate which works out the ffi and safety issues for us. But not all languages have this luxury. If you can't call it from Rust easilly and there is no existing crate that can do it for you, integrating with BMS might not be the best idea.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="necessary-features"><a class="header" href="#necessary-features">Necessary Features</a></h1>
<p>In order for a language to be called "implemented" in BMS, it needs to support the following features:</p>
<ul>
<li>Every script function which is registered on a type's namespace must:
<ul>
<li>Be callable on a <code>ReflectReference</code> representing object of that type in the script</li>
</ul>
<pre><code class="language-lua">local my_reference = ...
my_reference:my_Registered_function()
</code></pre>
<ul>
<li>If it's static it must be callable from a global proxy object for that type, i.e.</li>
</ul>
<pre><code class="language-lua">MyType.my_static_function()
</code></pre>
</li>
<li><code>ReflectReferences</code> must support a set of basic features:
<ul>
<li>Access to fields via reflection i.e.:</li>
</ul>
<pre><code class="language-lua">local my_reference = ...
my_reference.my_field = 5
print(my_reference.my_field)
</code></pre>
<ul>
<li>Basic operators and standard operations are overloaded with the appropriate standard dynamic function registered:
<ul>
<li>Addition: dispatches to the <code>add</code> binary function on the type</li>
<li>Multiplication: dispatches to the <code>mul</code> binary function on the type</li>
<li>Division: dispatches to the <code>div</code> binary function on the type</li>
<li>Subtraction: dispatches to the <code>sub</code> binary function on the type</li>
<li>Modulo: dispatches to the <code>rem</code> binary function on the type</li>
<li>Negation: dispatches to the <code>neg</code> unary function on the type</li>
<li>Exponentiation: dispatches to the <code>pow</code> binary function on the type</li>
<li>Equality: dispatches to the <code>eq</code> binary function on the type</li>
<li>Less than: dispatches to the <code>lt</code> binary function on the type</li>
<li>Length: calls the <code>len</code> method on <code>ReflectReference</code> or on the table if the value is one.</li>
<li>Iteration: dispatches to the <code>iter</code> method on <code>ReflectReference</code> which returns an iterator function, this can be repeatedly called until it returns <code>ScriptValue::Unit</code> to signal the end of the iteration.</li>
<li>Print: calls the <code>display_ref</code> method on <code>ReflectReference</code> or on the table if the value is one.</li>
</ul>
</li>
</ul>
</li>
<li>Script handlers, loaders etc. must be implemented such that the <code>ThreadWorldContainer</code> is set for every interaction with script contexts, or anywhere else it might be needed.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="multi-code-block.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
